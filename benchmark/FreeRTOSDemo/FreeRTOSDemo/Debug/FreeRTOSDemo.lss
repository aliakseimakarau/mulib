
FreeRTOSDemo.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002fb0  00000000  00000000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000008  20000000  00002fb0  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000ba8  20000008  00002fb8  00020008  2**2
                  ALLOC
  3 .stack        00002000  20000bb0  00003b60  00020008  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00020008  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020030  2**0
                  CONTENTS, READONLY
  6 .debug_info   00025b21  00000000  00000000  00020089  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003230  00000000  00000000  00045baa  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000f194  00000000  00000000  00048dda  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000c50  00000000  00000000  00057f6e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000013a0  00000000  00000000  00058bbe  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00019167  00000000  00000000  00059f5e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000ed7b  00000000  00000000  000730c5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0008f679  00000000  00000000  00081e40  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00002114  00000000  00000000  001114bc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	b0 2b 00 20 25 01 00 00 21 01 00 00 21 01 00 00     .+. %...!...!...
	...
      2c:	a5 0f 00 00 00 00 00 00 00 00 00 00 71 10 00 00     ............q...
      3c:	b5 10 00 00 21 01 00 00 21 01 00 00 21 01 00 00     ....!...!...!...
      4c:	21 01 00 00 21 01 00 00 21 01 00 00 21 01 00 00     !...!...!...!...
      5c:	21 01 00 00 21 01 00 00 21 01 00 00 21 01 00 00     !...!...!...!...
      6c:	21 01 00 00 61 09 00 00 21 01 00 00 21 01 00 00     !...a...!...!...
      7c:	21 01 00 00 21 01 00 00 21 01 00 00 21 01 00 00     !...!...!...!...
      8c:	21 01 00 00 21 01 00 00 21 01 00 00 21 01 00 00     !...!...!...!...
      9c:	21 01 00 00 21 01 00 00 21 01 00 00 21 01 00 00     !...!...!...!...
      ac:	21 01 00 00 00 00 00 00                             !.......

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	20000008 	.word	0x20000008
      d4:	00000000 	.word	0x00000000
      d8:	00002fb0 	.word	0x00002fb0

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	2000000c 	.word	0x2000000c
     108:	00002fb0 	.word	0x00002fb0
     10c:	00002fb0 	.word	0x00002fb0
     110:	00000000 	.word	0x00000000

00000114 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     114:	b510      	push	{r4, lr}
	system_init();
     116:	4b01      	ldr	r3, [pc, #4]	; (11c <atmel_start_init+0x8>)
     118:	4798      	blx	r3
}
     11a:	bd10      	pop	{r4, pc}
     11c:	000002ad 	.word	0x000002ad

00000120 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     120:	e7fe      	b.n	120 <Dummy_Handler>
	...

00000124 <Reset_Handler>:
{
     124:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
     126:	4a2a      	ldr	r2, [pc, #168]	; (1d0 <Reset_Handler+0xac>)
     128:	4b2a      	ldr	r3, [pc, #168]	; (1d4 <Reset_Handler+0xb0>)
     12a:	429a      	cmp	r2, r3
     12c:	d011      	beq.n	152 <Reset_Handler+0x2e>
                for (; pDest < &_erelocate;) {
     12e:	001a      	movs	r2, r3
     130:	4b29      	ldr	r3, [pc, #164]	; (1d8 <Reset_Handler+0xb4>)
     132:	429a      	cmp	r2, r3
     134:	d20d      	bcs.n	152 <Reset_Handler+0x2e>
     136:	4a29      	ldr	r2, [pc, #164]	; (1dc <Reset_Handler+0xb8>)
     138:	3303      	adds	r3, #3
     13a:	1a9b      	subs	r3, r3, r2
     13c:	089b      	lsrs	r3, r3, #2
     13e:	3301      	adds	r3, #1
     140:	009b      	lsls	r3, r3, #2
     142:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
     144:	4823      	ldr	r0, [pc, #140]	; (1d4 <Reset_Handler+0xb0>)
     146:	4922      	ldr	r1, [pc, #136]	; (1d0 <Reset_Handler+0xac>)
     148:	588c      	ldr	r4, [r1, r2]
     14a:	5084      	str	r4, [r0, r2]
     14c:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
     14e:	429a      	cmp	r2, r3
     150:	d1fa      	bne.n	148 <Reset_Handler+0x24>
        for (pDest = &_szero; pDest < &_ezero;) {
     152:	4a23      	ldr	r2, [pc, #140]	; (1e0 <Reset_Handler+0xbc>)
     154:	4b23      	ldr	r3, [pc, #140]	; (1e4 <Reset_Handler+0xc0>)
     156:	429a      	cmp	r2, r3
     158:	d20a      	bcs.n	170 <Reset_Handler+0x4c>
     15a:	43d3      	mvns	r3, r2
     15c:	4921      	ldr	r1, [pc, #132]	; (1e4 <Reset_Handler+0xc0>)
     15e:	185b      	adds	r3, r3, r1
     160:	2103      	movs	r1, #3
     162:	438b      	bics	r3, r1
     164:	3304      	adds	r3, #4
     166:	189b      	adds	r3, r3, r2
                *pDest++ = 0;
     168:	2100      	movs	r1, #0
     16a:	c202      	stmia	r2!, {r1}
        for (pDest = &_szero; pDest < &_ezero;) {
     16c:	4293      	cmp	r3, r2
     16e:	d1fc      	bne.n	16a <Reset_Handler+0x46>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     170:	4a1d      	ldr	r2, [pc, #116]	; (1e8 <Reset_Handler+0xc4>)
     172:	21ff      	movs	r1, #255	; 0xff
     174:	4b1d      	ldr	r3, [pc, #116]	; (1ec <Reset_Handler+0xc8>)
     176:	438b      	bics	r3, r1
     178:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
     17a:	39fd      	subs	r1, #253	; 0xfd
     17c:	2390      	movs	r3, #144	; 0x90
     17e:	005b      	lsls	r3, r3, #1
     180:	4a1b      	ldr	r2, [pc, #108]	; (1f0 <Reset_Handler+0xcc>)
     182:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
     184:	4a1b      	ldr	r2, [pc, #108]	; (1f4 <Reset_Handler+0xd0>)
     186:	78d3      	ldrb	r3, [r2, #3]
     188:	2503      	movs	r5, #3
     18a:	43ab      	bics	r3, r5
     18c:	2402      	movs	r4, #2
     18e:	4323      	orrs	r3, r4
     190:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
     192:	78d3      	ldrb	r3, [r2, #3]
     194:	270c      	movs	r7, #12
     196:	43bb      	bics	r3, r7
     198:	2608      	movs	r6, #8
     19a:	4333      	orrs	r3, r6
     19c:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
     19e:	4b16      	ldr	r3, [pc, #88]	; (1f8 <Reset_Handler+0xd4>)
     1a0:	7b98      	ldrb	r0, [r3, #14]
     1a2:	2230      	movs	r2, #48	; 0x30
     1a4:	4390      	bics	r0, r2
     1a6:	2220      	movs	r2, #32
     1a8:	4310      	orrs	r0, r2
     1aa:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
     1ac:	7b99      	ldrb	r1, [r3, #14]
     1ae:	43b9      	bics	r1, r7
     1b0:	4331      	orrs	r1, r6
     1b2:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
     1b4:	7b9a      	ldrb	r2, [r3, #14]
     1b6:	43aa      	bics	r2, r5
     1b8:	4322      	orrs	r2, r4
     1ba:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
     1bc:	4a0f      	ldr	r2, [pc, #60]	; (1fc <Reset_Handler+0xd8>)
     1be:	6853      	ldr	r3, [r2, #4]
     1c0:	2180      	movs	r1, #128	; 0x80
     1c2:	430b      	orrs	r3, r1
     1c4:	6053      	str	r3, [r2, #4]
        __libc_init_array();
     1c6:	4b0e      	ldr	r3, [pc, #56]	; (200 <Reset_Handler+0xdc>)
     1c8:	4798      	blx	r3
        main();
     1ca:	4b0e      	ldr	r3, [pc, #56]	; (204 <Reset_Handler+0xe0>)
     1cc:	4798      	blx	r3
     1ce:	e7fe      	b.n	1ce <Reset_Handler+0xaa>
     1d0:	00002fb0 	.word	0x00002fb0
     1d4:	20000000 	.word	0x20000000
     1d8:	20000008 	.word	0x20000008
     1dc:	20000004 	.word	0x20000004
     1e0:	20000008 	.word	0x20000008
     1e4:	20000bb0 	.word	0x20000bb0
     1e8:	e000ed00 	.word	0xe000ed00
     1ec:	00000000 	.word	0x00000000
     1f0:	41007000 	.word	0x41007000
     1f4:	41005000 	.word	0x41005000
     1f8:	41004800 	.word	0x41004800
     1fc:	41004000 	.word	0x41004000
     200:	00002c7d 	.word	0x00002c7d
     204:	00000b4d 	.word	0x00000b4d

00000208 <EDBG_COM_PORT_init>:

struct usart_os_descriptor EDBG_COM;
uint8_t                    EDBG_COM_buffer[EDBG_COM_BUFFER_SIZE];

void EDBG_COM_PORT_init(void)
{
     208:	b530      	push	{r4, r5, lr}
static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     20a:	4b0e      	ldr	r3, [pc, #56]	; (244 <EDBG_COM_PORT_init+0x3c>)
     20c:	2256      	movs	r2, #86	; 0x56
     20e:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
     210:	2501      	movs	r5, #1
     212:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     214:	2401      	movs	r4, #1
     216:	4321      	orrs	r1, r4
     218:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     21a:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     21c:	203b      	movs	r0, #59	; 0x3b
     21e:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     220:	3a47      	subs	r2, #71	; 0x47
     222:	4391      	bics	r1, r2
	tmp |= PORT_PMUX_PMUXE(data);
     224:	3a0d      	subs	r2, #13
     226:	4311      	orrs	r1, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     228:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     22a:	2157      	movs	r1, #87	; 0x57
     22c:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     22e:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     230:	4322      	orrs	r2, r4
     232:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     234:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     236:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     238:	3948      	subs	r1, #72	; 0x48
     23a:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
     23c:	3111      	adds	r1, #17
     23e:	430a      	orrs	r2, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     240:	541a      	strb	r2, [r3, r0]

	gpio_set_pin_function(EDBG_COM_TX, PINMUX_PA22C_SERCOM3_PAD0);

	gpio_set_pin_function(EDBG_COM_RX, PINMUX_PA23C_SERCOM3_PAD1);
}
     242:	bd30      	pop	{r4, r5, pc}
     244:	41004400 	.word	0x41004400

00000248 <EDBG_COM_CLOCK_init>:
			peripheral = (uint32_t)_pm_get_apbb_index(module);
			PM->APBBMASK.reg |= 1 << peripheral;
		}
		break;
	case PM_BUS_APBC:
		PM->APBCMASK.reg |= 1 << peripheral;
     248:	4a04      	ldr	r2, [pc, #16]	; (25c <EDBG_COM_CLOCK_init+0x14>)
     24a:	6a13      	ldr	r3, [r2, #32]
     24c:	2120      	movs	r1, #32
     24e:	430b      	orrs	r3, r1
     250:	6213      	str	r3, [r2, #32]
}

static inline void hri_gclk_write_CLKCTRL_reg(const void *const hw, hri_gclk_clkctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->CLKCTRL.reg = data;
     252:	4a03      	ldr	r2, [pc, #12]	; (260 <EDBG_COM_CLOCK_init+0x18>)
     254:	4b03      	ldr	r3, [pc, #12]	; (264 <EDBG_COM_CLOCK_init+0x1c>)
     256:	805a      	strh	r2, [r3, #2]

void EDBG_COM_CLOCK_init(void)
{
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM3);
	_gclk_enable_channel(SERCOM3_GCLK_ID_CORE, CONF_GCLK_SERCOM3_CORE_SRC);
}
     258:	4770      	bx	lr
     25a:	46c0      	nop			; (mov r8, r8)
     25c:	40000400 	.word	0x40000400
     260:	00004017 	.word	0x00004017
     264:	40000c00 	.word	0x40000c00

00000268 <EDBG_COM_init>:

void EDBG_COM_init(void)
{
     268:	b530      	push	{r4, r5, lr}
     26a:	b083      	sub	sp, #12

	EDBG_COM_CLOCK_init();
     26c:	4b08      	ldr	r3, [pc, #32]	; (290 <EDBG_COM_init+0x28>)
     26e:	4798      	blx	r3
	usart_os_init(&EDBG_COM, SERCOM3, EDBG_COM_buffer, EDBG_COM_BUFFER_SIZE, (void *)NULL);
     270:	4c08      	ldr	r4, [pc, #32]	; (294 <EDBG_COM_init+0x2c>)
     272:	2300      	movs	r3, #0
     274:	9300      	str	r3, [sp, #0]
     276:	3310      	adds	r3, #16
     278:	4a07      	ldr	r2, [pc, #28]	; (298 <EDBG_COM_init+0x30>)
     27a:	4908      	ldr	r1, [pc, #32]	; (29c <EDBG_COM_init+0x34>)
     27c:	0020      	movs	r0, r4
     27e:	4d08      	ldr	r5, [pc, #32]	; (2a0 <EDBG_COM_init+0x38>)
     280:	47a8      	blx	r5
	usart_os_enable(&EDBG_COM);
     282:	0020      	movs	r0, r4
     284:	4b07      	ldr	r3, [pc, #28]	; (2a4 <EDBG_COM_init+0x3c>)
     286:	4798      	blx	r3
	EDBG_COM_PORT_init();
     288:	4b07      	ldr	r3, [pc, #28]	; (2a8 <EDBG_COM_init+0x40>)
     28a:	4798      	blx	r3
}
     28c:	b003      	add	sp, #12
     28e:	bd30      	pop	{r4, r5, pc}
     290:	00000249 	.word	0x00000249
     294:	20000b64 	.word	0x20000b64
     298:	20000b54 	.word	0x20000b54
     29c:	42001400 	.word	0x42001400
     2a0:	000004fd 	.word	0x000004fd
     2a4:	00000605 	.word	0x00000605
     2a8:	00000209 	.word	0x00000209

000002ac <system_init>:

void system_init(void)
{
     2ac:	b510      	push	{r4, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
     2ae:	4b0b      	ldr	r3, [pc, #44]	; (2dc <system_init+0x30>)
     2b0:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     2b2:	23c0      	movs	r3, #192	; 0xc0
     2b4:	05db      	lsls	r3, r3, #23
     2b6:	2280      	movs	r2, #128	; 0x80
     2b8:	05d2      	lsls	r2, r2, #23
     2ba:	2194      	movs	r1, #148	; 0x94
     2bc:	505a      	str	r2, [r3, r1]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     2be:	390c      	subs	r1, #12
     2c0:	505a      	str	r2, [r3, r1]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     2c2:	4b07      	ldr	r3, [pc, #28]	; (2e0 <system_init+0x34>)
     2c4:	3120      	adds	r1, #32
     2c6:	505a      	str	r2, [r3, r1]
     2c8:	4a06      	ldr	r2, [pc, #24]	; (2e4 <system_init+0x38>)
     2ca:	505a      	str	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     2cc:	3136      	adds	r1, #54	; 0x36
     2ce:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
     2d0:	2001      	movs	r0, #1
     2d2:	4382      	bics	r2, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     2d4:	545a      	strb	r2, [r3, r1]
	// Set pin direction to output
	gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(LED0, GPIO_PIN_FUNCTION_OFF);

	EDBG_COM_init();
     2d6:	4b04      	ldr	r3, [pc, #16]	; (2e8 <system_init+0x3c>)
     2d8:	4798      	blx	r3
}
     2da:	bd10      	pop	{r4, pc}
     2dc:	00000739 	.word	0x00000739
     2e0:	41004400 	.word	0x41004400
     2e4:	c0004000 	.word	0xc0004000
     2e8:	00000269 	.word	0x00000269

000002ec <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
     2ec:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
     2f0:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
     2f2:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
     2f4:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
     2f8:	4770      	bx	lr

000002fa <atomic_leave_critical>:
     2fa:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
     2fe:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
     300:	f383 8810 	msr	PRIMASK, r3
}
     304:	4770      	bx	lr
	...

00000308 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
     308:	b570      	push	{r4, r5, r6, lr}
     30a:	0006      	movs	r6, r0
     30c:	000c      	movs	r4, r1
     30e:	0015      	movs	r5, r2
	ASSERT(io_descr && buf);
     310:	2800      	cmp	r0, #0
     312:	d00d      	beq.n	330 <io_write+0x28>
     314:	0008      	movs	r0, r1
     316:	1e43      	subs	r3, r0, #1
     318:	4198      	sbcs	r0, r3
     31a:	b2c0      	uxtb	r0, r0
     31c:	2234      	movs	r2, #52	; 0x34
     31e:	4905      	ldr	r1, [pc, #20]	; (334 <io_write+0x2c>)
     320:	4b05      	ldr	r3, [pc, #20]	; (338 <io_write+0x30>)
     322:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
     324:	6833      	ldr	r3, [r6, #0]
     326:	002a      	movs	r2, r5
     328:	0021      	movs	r1, r4
     32a:	0030      	movs	r0, r6
     32c:	4798      	blx	r3
}
     32e:	bd70      	pop	{r4, r5, r6, pc}
     330:	2000      	movs	r0, #0
     332:	e7f3      	b.n	31c <io_write+0x14>
     334:	00002d04 	.word	0x00002d04
     338:	00000631 	.word	0x00000631

0000033c <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
     33c:	b570      	push	{r4, r5, r6, lr}
     33e:	0006      	movs	r6, r0
     340:	000c      	movs	r4, r1
     342:	0015      	movs	r5, r2
	ASSERT(io_descr && buf);
     344:	2800      	cmp	r0, #0
     346:	d00d      	beq.n	364 <io_read+0x28>
     348:	0008      	movs	r0, r1
     34a:	1e43      	subs	r3, r0, #1
     34c:	4198      	sbcs	r0, r3
     34e:	b2c0      	uxtb	r0, r0
     350:	223d      	movs	r2, #61	; 0x3d
     352:	4905      	ldr	r1, [pc, #20]	; (368 <io_read+0x2c>)
     354:	4b05      	ldr	r3, [pc, #20]	; (36c <io_read+0x30>)
     356:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
     358:	6873      	ldr	r3, [r6, #4]
     35a:	002a      	movs	r2, r5
     35c:	0021      	movs	r1, r4
     35e:	0030      	movs	r0, r6
     360:	4798      	blx	r3
}
     362:	bd70      	pop	{r4, r5, r6, pc}
     364:	2000      	movs	r0, #0
     366:	e7f3      	b.n	350 <io_read+0x14>
     368:	00002d04 	.word	0x00002d04
     36c:	00000631 	.word	0x00000631

00000370 <usart_os_error>:
 * \brief Process error interrupt
 *
 * \param[in] device The pointer to device structure
 */
static void usart_os_error(struct _usart_async_device *device)
{
     370:	b510      	push	{r4, lr}
	struct usart_os_descriptor *descr = CONTAINER_OF(device, struct usart_os_descriptor, device);

	sem_up(&descr->rx_sem);
     372:	303c      	adds	r0, #60	; 0x3c
     374:	4b01      	ldr	r3, [pc, #4]	; (37c <usart_os_error+0xc>)
     376:	4798      	blx	r3
}
     378:	bd10      	pop	{r4, pc}
     37a:	46c0      	nop			; (mov r8, r8)
     37c:	00000e21 	.word	0x00000e21

00000380 <usart_os_transmission_complete>:
{
     380:	b510      	push	{r4, lr}
	sem_up(&descr->tx_sem);
     382:	3040      	adds	r0, #64	; 0x40
     384:	4b01      	ldr	r3, [pc, #4]	; (38c <usart_os_transmission_complete+0xc>)
     386:	4798      	blx	r3
}
     388:	bd10      	pop	{r4, pc}
     38a:	46c0      	nop			; (mov r8, r8)
     38c:	00000e21 	.word	0x00000e21

00000390 <usart_os_fill_rx_buffer>:
{
     390:	b570      	push	{r4, r5, r6, lr}
	if (descr->rx_buffer == NULL) {
     392:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
     394:	2a00      	cmp	r2, #0
     396:	d00a      	beq.n	3ae <usart_os_fill_rx_buffer+0x1e>
		descr->rx_buffer[descr->rx_size++] = data;
     398:	0003      	movs	r3, r0
     39a:	8e04      	ldrh	r4, [r0, #48]	; 0x30
     39c:	1c65      	adds	r5, r4, #1
     39e:	8605      	strh	r5, [r0, #48]	; 0x30
     3a0:	5511      	strb	r1, [r2, r4]
		if (descr->rx_size >= descr->rx_length) {
     3a2:	8e02      	ldrh	r2, [r0, #48]	; 0x30
		descr->rx_buffer[descr->rx_size++] = data;
     3a4:	3b08      	subs	r3, #8
		if (descr->rx_size >= descr->rx_length) {
     3a6:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
     3a8:	429a      	cmp	r2, r3
     3aa:	d204      	bcs.n	3b6 <usart_os_fill_rx_buffer+0x26>
}
     3ac:	bd70      	pop	{r4, r5, r6, pc}
		ringbuffer_put(&descr->rx, data);
     3ae:	301c      	adds	r0, #28
     3b0:	4b04      	ldr	r3, [pc, #16]	; (3c4 <usart_os_fill_rx_buffer+0x34>)
     3b2:	4798      	blx	r3
     3b4:	e7fa      	b.n	3ac <usart_os_fill_rx_buffer+0x1c>
			descr->rx_buffer = NULL;
     3b6:	2200      	movs	r2, #0
     3b8:	62c2      	str	r2, [r0, #44]	; 0x2c
			sem_up(&descr->rx_sem);
     3ba:	303c      	adds	r0, #60	; 0x3c
     3bc:	4b02      	ldr	r3, [pc, #8]	; (3c8 <usart_os_fill_rx_buffer+0x38>)
     3be:	4798      	blx	r3
}
     3c0:	e7f4      	b.n	3ac <usart_os_fill_rx_buffer+0x1c>
     3c2:	46c0      	nop			; (mov r8, r8)
     3c4:	000006d5 	.word	0x000006d5
     3c8:	00000e21 	.word	0x00000e21

000003cc <usart_os_process_byte_sent>:
{
     3cc:	b570      	push	{r4, r5, r6, lr}
     3ce:	0004      	movs	r4, r0
	if (descr->tx_por != descr->tx_buffer_length) {
     3d0:	8f03      	ldrh	r3, [r0, #56]	; 0x38
     3d2:	8f42      	ldrh	r2, [r0, #58]	; 0x3a
     3d4:	429a      	cmp	r2, r3
     3d6:	d00d      	beq.n	3f4 <usart_os_process_byte_sent+0x28>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
     3d8:	0002      	movs	r2, r0
     3da:	6b41      	ldr	r1, [r0, #52]	; 0x34
     3dc:	3a08      	subs	r2, #8
     3de:	1c5d      	adds	r5, r3, #1
     3e0:	2040      	movs	r0, #64	; 0x40
     3e2:	5215      	strh	r5, [r2, r0]
     3e4:	5cc9      	ldrb	r1, [r1, r3]
     3e6:	0020      	movs	r0, r4
     3e8:	4b04      	ldr	r3, [pc, #16]	; (3fc <usart_os_process_byte_sent+0x30>)
     3ea:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
     3ec:	0020      	movs	r0, r4
     3ee:	4b04      	ldr	r3, [pc, #16]	; (400 <usart_os_process_byte_sent+0x34>)
     3f0:	4798      	blx	r3
}
     3f2:	bd70      	pop	{r4, r5, r6, pc}
		_usart_async_enable_tx_done_irq(&descr->device);
     3f4:	4b03      	ldr	r3, [pc, #12]	; (404 <usart_os_process_byte_sent+0x38>)
     3f6:	4798      	blx	r3
}
     3f8:	e7fb      	b.n	3f2 <usart_os_process_byte_sent+0x26>
     3fa:	46c0      	nop			; (mov r8, r8)
     3fc:	000008d5 	.word	0x000008d5
     400:	000008dd 	.word	0x000008dd
     404:	000008e5 	.word	0x000008e5

00000408 <usart_os_write>:
{
     408:	b570      	push	{r4, r5, r6, lr}
     40a:	0004      	movs	r4, r0
     40c:	0015      	movs	r5, r2
	descr->tx_buffer        = (uint8_t *)buf;
     40e:	63c1      	str	r1, [r0, #60]	; 0x3c
	descr->tx_buffer_length = length;
     410:	2342      	movs	r3, #66	; 0x42
     412:	52e2      	strh	r2, [r4, r3]
	descr->tx_por           = 0;
     414:	2200      	movs	r2, #0
     416:	3b02      	subs	r3, #2
     418:	52c2      	strh	r2, [r0, r3]
	_usart_async_enable_byte_sent_irq(&descr->device);
     41a:	3008      	adds	r0, #8
     41c:	4b07      	ldr	r3, [pc, #28]	; (43c <usart_os_write+0x34>)
     41e:	4798      	blx	r3
	return sem_down(&descr->tx_sem, ~0) == 0 ? length : ERR_TIMEOUT;
     420:	0020      	movs	r0, r4
     422:	3048      	adds	r0, #72	; 0x48
     424:	2101      	movs	r1, #1
     426:	4249      	negs	r1, r1
     428:	4b05      	ldr	r3, [pc, #20]	; (440 <usart_os_write+0x38>)
     42a:	4798      	blx	r3
     42c:	2800      	cmp	r0, #0
     42e:	d101      	bne.n	434 <usart_os_write+0x2c>
     430:	0028      	movs	r0, r5
}
     432:	bd70      	pop	{r4, r5, r6, pc}
	return sem_down(&descr->tx_sem, ~0) == 0 ? length : ERR_TIMEOUT;
     434:	2008      	movs	r0, #8
     436:	4240      	negs	r0, r0
     438:	e7fb      	b.n	432 <usart_os_write+0x2a>
     43a:	46c0      	nop			; (mov r8, r8)
     43c:	000008dd 	.word	0x000008dd
     440:	00000e65 	.word	0x00000e65

00000444 <usart_os_read>:
{
     444:	b5f0      	push	{r4, r5, r6, r7, lr}
     446:	b085      	sub	sp, #20
     448:	0004      	movs	r4, r0
     44a:	000e      	movs	r6, r1
     44c:	0017      	movs	r7, r2
	ASSERT(buf);
     44e:	0008      	movs	r0, r1
     450:	1e43      	subs	r3, r0, #1
     452:	4198      	sbcs	r0, r3
     454:	b2c0      	uxtb	r0, r0
     456:	2292      	movs	r2, #146	; 0x92
     458:	0052      	lsls	r2, r2, #1
     45a:	4921      	ldr	r1, [pc, #132]	; (4e0 <usart_os_read+0x9c>)
     45c:	4b21      	ldr	r3, [pc, #132]	; (4e4 <usart_os_read+0xa0>)
     45e:	4798      	blx	r3
	if (ringbuffer_num(&descr->rx) < length) {
     460:	2324      	movs	r3, #36	; 0x24
     462:	469c      	mov	ip, r3
     464:	44a4      	add	ip, r4
     466:	4663      	mov	r3, ip
     468:	9301      	str	r3, [sp, #4]
     46a:	4660      	mov	r0, ip
     46c:	4b1e      	ldr	r3, [pc, #120]	; (4e8 <usart_os_read+0xa4>)
     46e:	4798      	blx	r3
     470:	42b8      	cmp	r0, r7
     472:	d310      	bcc.n	496 <usart_os_read+0x52>
		while (was_read < length) {
     474:	2f00      	cmp	r7, #0
     476:	d00b      	beq.n	490 <usart_os_read+0x4c>
     478:	0034      	movs	r4, r6
     47a:	1e7b      	subs	r3, r7, #1
     47c:	b29b      	uxth	r3, r3
     47e:	3301      	adds	r3, #1
     480:	18f6      	adds	r6, r6, r3
			ringbuffer_get(&descr->rx, &buf[was_read++]);
     482:	4d1a      	ldr	r5, [pc, #104]	; (4ec <usart_os_read+0xa8>)
     484:	0021      	movs	r1, r4
     486:	9801      	ldr	r0, [sp, #4]
     488:	47a8      	blx	r5
     48a:	3401      	adds	r4, #1
		while (was_read < length) {
     48c:	42b4      	cmp	r4, r6
     48e:	d1f9      	bne.n	484 <usart_os_read+0x40>
	return (int32_t)length;
     490:	0038      	movs	r0, r7
}
     492:	b005      	add	sp, #20
     494:	bdf0      	pop	{r4, r5, r6, r7, pc}
		CRITICAL_SECTION_ENTER()
     496:	a803      	add	r0, sp, #12
     498:	4b15      	ldr	r3, [pc, #84]	; (4f0 <usart_os_read+0xac>)
     49a:	4798      	blx	r3
		descr->rx_size   = 0;
     49c:	2300      	movs	r3, #0
     49e:	8723      	strh	r3, [r4, #56]	; 0x38
		descr->rx_length = length;
     4a0:	8767      	strh	r7, [r4, #58]	; 0x3a
		descr->rx_buffer = buf;
     4a2:	6366      	str	r6, [r4, #52]	; 0x34
		while (ringbuffer_num(&descr->rx) > 0) {
     4a4:	4e10      	ldr	r6, [pc, #64]	; (4e8 <usart_os_read+0xa4>)
			ringbuffer_get(&descr->rx, &descr->rx_buffer[descr->rx_size++]);
     4a6:	4d11      	ldr	r5, [pc, #68]	; (4ec <usart_os_read+0xa8>)
		while (ringbuffer_num(&descr->rx) > 0) {
     4a8:	e007      	b.n	4ba <usart_os_read+0x76>
			ringbuffer_get(&descr->rx, &descr->rx_buffer[descr->rx_size++]);
     4aa:	8f21      	ldrh	r1, [r4, #56]	; 0x38
     4ac:	1c4b      	adds	r3, r1, #1
     4ae:	8723      	strh	r3, [r4, #56]	; 0x38
     4b0:	6b63      	ldr	r3, [r4, #52]	; 0x34
     4b2:	469c      	mov	ip, r3
     4b4:	4461      	add	r1, ip
     4b6:	9801      	ldr	r0, [sp, #4]
     4b8:	47a8      	blx	r5
		while (ringbuffer_num(&descr->rx) > 0) {
     4ba:	9801      	ldr	r0, [sp, #4]
     4bc:	47b0      	blx	r6
     4be:	2800      	cmp	r0, #0
     4c0:	d1f3      	bne.n	4aa <usart_os_read+0x66>
		CRITICAL_SECTION_LEAVE()
     4c2:	a803      	add	r0, sp, #12
     4c4:	4b0b      	ldr	r3, [pc, #44]	; (4f4 <usart_os_read+0xb0>)
     4c6:	4798      	blx	r3
		if (sem_down(&descr->rx_sem, timeout) != 0) {
     4c8:	0020      	movs	r0, r4
     4ca:	3044      	adds	r0, #68	; 0x44
     4cc:	2101      	movs	r1, #1
     4ce:	4249      	negs	r1, r1
     4d0:	4b09      	ldr	r3, [pc, #36]	; (4f8 <usart_os_read+0xb4>)
     4d2:	4798      	blx	r3
     4d4:	2800      	cmp	r0, #0
     4d6:	d0db      	beq.n	490 <usart_os_read+0x4c>
			return ERR_TIMEOUT;
     4d8:	2008      	movs	r0, #8
     4da:	4240      	negs	r0, r0
     4dc:	e7d9      	b.n	492 <usart_os_read+0x4e>
     4de:	46c0      	nop			; (mov r8, r8)
     4e0:	00002d18 	.word	0x00002d18
     4e4:	00000631 	.word	0x00000631
     4e8:	00000715 	.word	0x00000715
     4ec:	0000068d 	.word	0x0000068d
     4f0:	000002ed 	.word	0x000002ed
     4f4:	000002fb 	.word	0x000002fb
     4f8:	00000e65 	.word	0x00000e65

000004fc <usart_os_init>:
{
     4fc:	b5f0      	push	{r4, r5, r6, r7, lr}
     4fe:	b083      	sub	sp, #12
     500:	0007      	movs	r7, r0
     502:	000d      	movs	r5, r1
     504:	0014      	movs	r4, r2
     506:	001e      	movs	r6, r3
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
     508:	2800      	cmp	r0, #0
     50a:	d04d      	beq.n	5a8 <usart_os_init+0xac>
     50c:	2900      	cmp	r1, #0
     50e:	d04d      	beq.n	5ac <usart_os_init+0xb0>
     510:	2a00      	cmp	r2, #0
     512:	d04d      	beq.n	5b0 <usart_os_init+0xb4>
     514:	0018      	movs	r0, r3
     516:	1e43      	subs	r3, r0, #1
     518:	4198      	sbcs	r0, r3
     51a:	2240      	movs	r2, #64	; 0x40
     51c:	492c      	ldr	r1, [pc, #176]	; (5d0 <usart_os_init+0xd4>)
     51e:	4b2d      	ldr	r3, [pc, #180]	; (5d4 <usart_os_init+0xd8>)
     520:	4798      	blx	r3
	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
     522:	0038      	movs	r0, r7
     524:	3024      	adds	r0, #36	; 0x24
     526:	0032      	movs	r2, r6
     528:	0021      	movs	r1, r4
     52a:	4b2b      	ldr	r3, [pc, #172]	; (5d8 <usart_os_init+0xdc>)
     52c:	4798      	blx	r3
     52e:	2800      	cmp	r0, #0
     530:	d14a      	bne.n	5c8 <usart_os_init+0xcc>
	rc = sem_init(&descr->rx_sem, 0);
     532:	003e      	movs	r6, r7
     534:	3644      	adds	r6, #68	; 0x44
     536:	2100      	movs	r1, #0
     538:	0030      	movs	r0, r6
     53a:	4b28      	ldr	r3, [pc, #160]	; (5dc <usart_os_init+0xe0>)
     53c:	4798      	blx	r3
     53e:	1e04      	subs	r4, r0, #0
	if (rc < 0) {
     540:	db2f      	blt.n	5a2 <usart_os_init+0xa6>
	rc = sem_init(&descr->tx_sem, 0);
     542:	2348      	movs	r3, #72	; 0x48
     544:	469c      	mov	ip, r3
     546:	44bc      	add	ip, r7
     548:	4663      	mov	r3, ip
     54a:	9300      	str	r3, [sp, #0]
     54c:	2100      	movs	r1, #0
     54e:	4660      	mov	r0, ip
     550:	4b22      	ldr	r3, [pc, #136]	; (5dc <usart_os_init+0xe0>)
     552:	4798      	blx	r3
     554:	1e04      	subs	r4, r0, #0
	if (rc < 0) {
     556:	db2d      	blt.n	5b4 <usart_os_init+0xb8>
	rc = _usart_async_init(&descr->device, hw);
     558:	2308      	movs	r3, #8
     55a:	469c      	mov	ip, r3
     55c:	44bc      	add	ip, r7
     55e:	4663      	mov	r3, ip
     560:	9301      	str	r3, [sp, #4]
     562:	0029      	movs	r1, r5
     564:	4660      	mov	r0, ip
     566:	4b1e      	ldr	r3, [pc, #120]	; (5e0 <usart_os_init+0xe4>)
     568:	4798      	blx	r3
     56a:	1e04      	subs	r4, r0, #0
	if (rc) {
     56c:	d126      	bne.n	5bc <usart_os_init+0xc0>
	descr->rx_buffer = NULL;
     56e:	2300      	movs	r3, #0
     570:	637b      	str	r3, [r7, #52]	; 0x34
	descr->rx_size   = 0;
     572:	873b      	strh	r3, [r7, #56]	; 0x38
	descr->rx_length = 0;
     574:	877b      	strh	r3, [r7, #58]	; 0x3a
	descr->io.read  = usart_os_read;
     576:	4b1b      	ldr	r3, [pc, #108]	; (5e4 <usart_os_init+0xe8>)
     578:	607b      	str	r3, [r7, #4]
	descr->io.write = usart_os_write;
     57a:	4b1b      	ldr	r3, [pc, #108]	; (5e8 <usart_os_init+0xec>)
     57c:	603b      	str	r3, [r7, #0]
	descr->device.usart_cb.tx_byte_sent = usart_os_process_byte_sent;
     57e:	4b1b      	ldr	r3, [pc, #108]	; (5ec <usart_os_init+0xf0>)
     580:	60bb      	str	r3, [r7, #8]
	descr->device.usart_cb.rx_done_cb   = usart_os_fill_rx_buffer;
     582:	4b1b      	ldr	r3, [pc, #108]	; (5f0 <usart_os_init+0xf4>)
     584:	60fb      	str	r3, [r7, #12]
	descr->device.usart_cb.tx_done_cb   = usart_os_transmission_complete;
     586:	4b1b      	ldr	r3, [pc, #108]	; (5f4 <usart_os_init+0xf8>)
     588:	613b      	str	r3, [r7, #16]
	descr->device.usart_cb.error_cb     = usart_os_error;
     58a:	4b1b      	ldr	r3, [pc, #108]	; (5f8 <usart_os_init+0xfc>)
     58c:	617b      	str	r3, [r7, #20]
	_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, true);
     58e:	2201      	movs	r2, #1
     590:	2101      	movs	r1, #1
     592:	9e01      	ldr	r6, [sp, #4]
     594:	0030      	movs	r0, r6
     596:	4d19      	ldr	r5, [pc, #100]	; (5fc <usart_os_init+0x100>)
     598:	47a8      	blx	r5
	_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, true);
     59a:	2201      	movs	r2, #1
     59c:	2103      	movs	r1, #3
     59e:	0030      	movs	r0, r6
     5a0:	47a8      	blx	r5
}
     5a2:	0020      	movs	r0, r4
     5a4:	b003      	add	sp, #12
     5a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
     5a8:	2000      	movs	r0, #0
     5aa:	e7b6      	b.n	51a <usart_os_init+0x1e>
     5ac:	2000      	movs	r0, #0
     5ae:	e7b4      	b.n	51a <usart_os_init+0x1e>
     5b0:	2000      	movs	r0, #0
     5b2:	e7b2      	b.n	51a <usart_os_init+0x1e>
		sem_deinit(&descr->tx_sem);
     5b4:	9800      	ldr	r0, [sp, #0]
     5b6:	4b12      	ldr	r3, [pc, #72]	; (600 <usart_os_init+0x104>)
     5b8:	4798      	blx	r3
		return rc;
     5ba:	e7f2      	b.n	5a2 <usart_os_init+0xa6>
		sem_deinit(&descr->tx_sem);
     5bc:	9800      	ldr	r0, [sp, #0]
     5be:	4d10      	ldr	r5, [pc, #64]	; (600 <usart_os_init+0x104>)
     5c0:	47a8      	blx	r5
		sem_deinit(&descr->rx_sem);
     5c2:	0030      	movs	r0, r6
     5c4:	47a8      	blx	r5
		return rc;
     5c6:	e7ec      	b.n	5a2 <usart_os_init+0xa6>
		return ERR_INVALID_ARG;
     5c8:	240d      	movs	r4, #13
     5ca:	4264      	negs	r4, r4
     5cc:	e7e9      	b.n	5a2 <usart_os_init+0xa6>
     5ce:	46c0      	nop			; (mov r8, r8)
     5d0:	00002d18 	.word	0x00002d18
     5d4:	00000631 	.word	0x00000631
     5d8:	00000639 	.word	0x00000639
     5dc:	00000de5 	.word	0x00000de5
     5e0:	00000845 	.word	0x00000845
     5e4:	00000445 	.word	0x00000445
     5e8:	00000409 	.word	0x00000409
     5ec:	000003cd 	.word	0x000003cd
     5f0:	00000391 	.word	0x00000391
     5f4:	00000381 	.word	0x00000381
     5f8:	00000371 	.word	0x00000371
     5fc:	000008ed 	.word	0x000008ed
     600:	00000e81 	.word	0x00000e81

00000604 <usart_os_enable>:
{
     604:	b510      	push	{r4, lr}
     606:	0004      	movs	r4, r0
	ASSERT(descr);
     608:	1e43      	subs	r3, r0, #1
     60a:	4198      	sbcs	r0, r3
     60c:	b2c0      	uxtb	r0, r0
     60e:	227b      	movs	r2, #123	; 0x7b
     610:	4904      	ldr	r1, [pc, #16]	; (624 <usart_os_enable+0x20>)
     612:	4b05      	ldr	r3, [pc, #20]	; (628 <usart_os_enable+0x24>)
     614:	4798      	blx	r3
	_usart_async_enable(&descr->device);
     616:	0020      	movs	r0, r4
     618:	3008      	adds	r0, #8
     61a:	4b04      	ldr	r3, [pc, #16]	; (62c <usart_os_enable+0x28>)
     61c:	4798      	blx	r3
}
     61e:	2000      	movs	r0, #0
     620:	bd10      	pop	{r4, pc}
     622:	46c0      	nop			; (mov r8, r8)
     624:	00002d18 	.word	0x00002d18
     628:	00000631 	.word	0x00000631
     62c:	000008c1 	.word	0x000008c1

00000630 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
     630:	2800      	cmp	r0, #0
     632:	d100      	bne.n	636 <assert+0x6>
		__asm("BKPT #0");
     634:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
     636:	4770      	bx	lr

00000638 <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
     638:	b570      	push	{r4, r5, r6, lr}
     63a:	0004      	movs	r4, r0
     63c:	000e      	movs	r6, r1
     63e:	0015      	movs	r5, r2
	ASSERT(rb && buf && size);
     640:	2800      	cmp	r0, #0
     642:	d00b      	beq.n	65c <ringbuffer_init+0x24>
     644:	2900      	cmp	r1, #0
     646:	d018      	beq.n	67a <ringbuffer_init+0x42>
     648:	2001      	movs	r0, #1
     64a:	2a00      	cmp	r2, #0
     64c:	d107      	bne.n	65e <ringbuffer_init+0x26>
     64e:	2228      	movs	r2, #40	; 0x28
     650:	490c      	ldr	r1, [pc, #48]	; (684 <ringbuffer_init+0x4c>)
     652:	2000      	movs	r0, #0
     654:	4b0c      	ldr	r3, [pc, #48]	; (688 <ringbuffer_init+0x50>)
     656:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
     658:	1e6b      	subs	r3, r5, #1
     65a:	e007      	b.n	66c <ringbuffer_init+0x34>
	ASSERT(rb && buf && size);
     65c:	2000      	movs	r0, #0
     65e:	2228      	movs	r2, #40	; 0x28
     660:	4908      	ldr	r1, [pc, #32]	; (684 <ringbuffer_init+0x4c>)
     662:	4b09      	ldr	r3, [pc, #36]	; (688 <ringbuffer_init+0x50>)
     664:	4798      	blx	r3
	if ((size & (size - 1)) != 0) {
     666:	1e6b      	subs	r3, r5, #1
     668:	422b      	tst	r3, r5
     66a:	d108      	bne.n	67e <ringbuffer_init+0x46>
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
     66c:	6063      	str	r3, [r4, #4]
	rb->read_index  = 0;
     66e:	2300      	movs	r3, #0
     670:	60a3      	str	r3, [r4, #8]
	rb->write_index = rb->read_index;
     672:	60e3      	str	r3, [r4, #12]
	rb->buf         = (uint8_t *)buf;
     674:	6026      	str	r6, [r4, #0]

	return ERR_NONE;
     676:	2000      	movs	r0, #0
}
     678:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
     67a:	2000      	movs	r0, #0
     67c:	e7ef      	b.n	65e <ringbuffer_init+0x26>
		return ERR_INVALID_ARG;
     67e:	200d      	movs	r0, #13
     680:	4240      	negs	r0, r0
     682:	e7f9      	b.n	678 <ringbuffer_init+0x40>
     684:	00002d34 	.word	0x00002d34
     688:	00000631 	.word	0x00000631

0000068c <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
     68c:	b570      	push	{r4, r5, r6, lr}
     68e:	0004      	movs	r4, r0
     690:	000d      	movs	r5, r1
	ASSERT(rb && data);
     692:	2800      	cmp	r0, #0
     694:	d015      	beq.n	6c2 <ringbuffer_get+0x36>
     696:	0008      	movs	r0, r1
     698:	1e43      	subs	r3, r0, #1
     69a:	4198      	sbcs	r0, r3
     69c:	b2c0      	uxtb	r0, r0
     69e:	2240      	movs	r2, #64	; 0x40
     6a0:	490a      	ldr	r1, [pc, #40]	; (6cc <ringbuffer_get+0x40>)
     6a2:	4b0b      	ldr	r3, [pc, #44]	; (6d0 <ringbuffer_get+0x44>)
     6a4:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
     6a6:	68a3      	ldr	r3, [r4, #8]
     6a8:	68e2      	ldr	r2, [r4, #12]
     6aa:	429a      	cmp	r2, r3
     6ac:	d00b      	beq.n	6c6 <ringbuffer_get+0x3a>
		*data = rb->buf[rb->read_index & rb->size];
     6ae:	6862      	ldr	r2, [r4, #4]
     6b0:	4013      	ands	r3, r2
     6b2:	6822      	ldr	r2, [r4, #0]
     6b4:	5cd3      	ldrb	r3, [r2, r3]
     6b6:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
     6b8:	68a3      	ldr	r3, [r4, #8]
     6ba:	3301      	adds	r3, #1
     6bc:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
     6be:	2000      	movs	r0, #0
	}

	return ERR_NOT_FOUND;
}
     6c0:	bd70      	pop	{r4, r5, r6, pc}
     6c2:	2000      	movs	r0, #0
     6c4:	e7eb      	b.n	69e <ringbuffer_get+0x12>
	return ERR_NOT_FOUND;
     6c6:	200a      	movs	r0, #10
     6c8:	4240      	negs	r0, r0
     6ca:	e7f9      	b.n	6c0 <ringbuffer_get+0x34>
     6cc:	00002d34 	.word	0x00002d34
     6d0:	00000631 	.word	0x00000631

000006d4 <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
     6d4:	b570      	push	{r4, r5, r6, lr}
     6d6:	0004      	movs	r4, r0
     6d8:	000d      	movs	r5, r1
	ASSERT(rb);
     6da:	1e43      	subs	r3, r0, #1
     6dc:	4198      	sbcs	r0, r3
     6de:	b2c0      	uxtb	r0, r0
     6e0:	2251      	movs	r2, #81	; 0x51
     6e2:	490a      	ldr	r1, [pc, #40]	; (70c <ringbuffer_put+0x38>)
     6e4:	4b0a      	ldr	r3, [pc, #40]	; (710 <ringbuffer_put+0x3c>)
     6e6:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
     6e8:	6863      	ldr	r3, [r4, #4]
     6ea:	68e2      	ldr	r2, [r4, #12]
     6ec:	4013      	ands	r3, r2
     6ee:	6822      	ldr	r2, [r4, #0]
     6f0:	54d5      	strb	r5, [r2, r3]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
     6f2:	68e3      	ldr	r3, [r4, #12]
     6f4:	6861      	ldr	r1, [r4, #4]
     6f6:	68a2      	ldr	r2, [r4, #8]
     6f8:	1a9a      	subs	r2, r3, r2
     6fa:	428a      	cmp	r2, r1
     6fc:	d901      	bls.n	702 <ringbuffer_put+0x2e>
		rb->read_index = rb->write_index - rb->size;
     6fe:	1a59      	subs	r1, r3, r1
     700:	60a1      	str	r1, [r4, #8]
	}

	rb->write_index++;
     702:	3301      	adds	r3, #1
     704:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
}
     706:	2000      	movs	r0, #0
     708:	bd70      	pop	{r4, r5, r6, pc}
     70a:	46c0      	nop			; (mov r8, r8)
     70c:	00002d34 	.word	0x00002d34
     710:	00000631 	.word	0x00000631

00000714 <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
     714:	b510      	push	{r4, lr}
     716:	0004      	movs	r4, r0
	ASSERT(rb);
     718:	1e43      	subs	r3, r0, #1
     71a:	4198      	sbcs	r0, r3
     71c:	b2c0      	uxtb	r0, r0
     71e:	2267      	movs	r2, #103	; 0x67
     720:	4903      	ldr	r1, [pc, #12]	; (730 <ringbuffer_num+0x1c>)
     722:	4b04      	ldr	r3, [pc, #16]	; (734 <ringbuffer_num+0x20>)
     724:	4798      	blx	r3

	return rb->write_index - rb->read_index;
     726:	68e0      	ldr	r0, [r4, #12]
     728:	68a3      	ldr	r3, [r4, #8]
     72a:	1ac0      	subs	r0, r0, r3
}
     72c:	bd10      	pop	{r4, pc}
     72e:	46c0      	nop			; (mov r8, r8)
     730:	00002d34 	.word	0x00002d34
     734:	00000631 	.word	0x00000631

00000738 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
     738:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
     73a:	4b06      	ldr	r3, [pc, #24]	; (754 <_init_chip+0x1c>)
     73c:	685a      	ldr	r2, [r3, #4]
     73e:	605a      	str	r2, [r3, #4]
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_pm_init();
     740:	4b05      	ldr	r3, [pc, #20]	; (758 <_init_chip+0x20>)
     742:	4798      	blx	r3
	_sysctrl_init_sources();
     744:	4b05      	ldr	r3, [pc, #20]	; (75c <_init_chip+0x24>)
     746:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_sysctrl_init_referenced_generators();
     748:	4b05      	ldr	r3, [pc, #20]	; (760 <_init_chip+0x28>)
     74a:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
     74c:	20ff      	movs	r0, #255	; 0xff
     74e:	4b05      	ldr	r3, [pc, #20]	; (764 <_init_chip+0x2c>)
     750:	4798      	blx	r3
#if CONF_DMAC_ENABLE
	_pm_enable_bus_clock(PM_BUS_AHB, DMAC);
	_pm_enable_bus_clock(PM_BUS_APBB, DMAC);
	_dma_init();
#endif
}
     752:	bd10      	pop	{r4, pc}
     754:	41004000 	.word	0x41004000
     758:	00000789 	.word	0x00000789
     75c:	000009cd 	.word	0x000009cd
     760:	00000a15 	.word	0x00000a15
     764:	00000769 	.word	0x00000769

00000768 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
     768:	07c3      	lsls	r3, r0, #31
     76a:	d50a      	bpl.n	782 <_gclk_init_generators_by_fref+0x1a>
}

static inline void hri_gclk_write_GENDIV_reg(const void *const hw, hri_gclk_gendiv_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENDIV.reg = data;
     76c:	4b05      	ldr	r3, [pc, #20]	; (784 <_gclk_init_generators_by_fref+0x1c>)
     76e:	2280      	movs	r2, #128	; 0x80
     770:	0052      	lsls	r2, r2, #1
     772:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
     774:	2283      	movs	r2, #131	; 0x83
     776:	0252      	lsls	r2, r2, #9
     778:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
     77a:	001a      	movs	r2, r3
     77c:	7853      	ldrb	r3, [r2, #1]
     77e:	09db      	lsrs	r3, r3, #7
     780:	d1fc      	bne.n	77c <_gclk_init_generators_by_fref+0x14>
		        | (CONF_GCLK_GEN_8_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_8_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_8_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_8_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_8_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_8_SRC | GCLK_GENCTRL_ID(8));
	}
#endif
}
     782:	4770      	bx	lr
     784:	40000c00 	.word	0x40000c00

00000788 <_pm_init>:
}

static inline void hri_pm_set_CPUSEL_CPUDIV_bf(const void *const hw, hri_pm_cpusel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->CPUSEL.reg |= PM_CPUSEL_CPUDIV(mask);
     788:	4b06      	ldr	r3, [pc, #24]	; (7a4 <_pm_init+0x1c>)
     78a:	7a1a      	ldrb	r2, [r3, #8]
     78c:	b2d2      	uxtb	r2, r2
     78e:	721a      	strb	r2, [r3, #8]
}

static inline void hri_pm_set_APBASEL_APBADIV_bf(const void *const hw, hri_pm_apbasel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBASEL.reg |= PM_APBASEL_APBADIV(mask);
     790:	7a5a      	ldrb	r2, [r3, #9]
     792:	b2d2      	uxtb	r2, r2
     794:	725a      	strb	r2, [r3, #9]
}

static inline void hri_pm_set_APBBSEL_APBBDIV_bf(const void *const hw, hri_pm_apbbsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBBSEL.reg |= PM_APBBSEL_APBBDIV(mask);
     796:	7a9a      	ldrb	r2, [r3, #10]
     798:	b2d2      	uxtb	r2, r2
     79a:	729a      	strb	r2, [r3, #10]
}

static inline void hri_pm_set_APBCSEL_APBCDIV_bf(const void *const hw, hri_pm_apbcsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBCSEL.reg |= PM_APBCSEL_APBCDIV(mask);
     79c:	7ada      	ldrb	r2, [r3, #11]
     79e:	b2d2      	uxtb	r2, r2
     7a0:	72da      	strb	r2, [r3, #11]
{
	hri_pm_set_CPUSEL_CPUDIV_bf(PM, CONF_CPU_DIV);
	hri_pm_set_APBASEL_APBADIV_bf(PM, CONF_APBA_DIV);
	hri_pm_set_APBBSEL_APBBDIV_bf(PM, CONF_APBB_DIV);
	hri_pm_set_APBCSEL_APBCDIV_bf(PM, CONF_APBC_DIV);
}
     7a2:	4770      	bx	lr
     7a4:	40000400 	.word	0x40000400

000007a8 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
     7a8:	b510      	push	{r4, lr}
     7aa:	0004      	movs	r4, r0
	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
     7ac:	4b1f      	ldr	r3, [pc, #124]	; (82c <_usart_init+0x84>)
     7ae:	18c3      	adds	r3, r0, r3
     7b0:	0a9b      	lsrs	r3, r3, #10
		if (_usarts[i].number == sercom_offset) {
     7b2:	b2db      	uxtb	r3, r3
     7b4:	2b03      	cmp	r3, #3
     7b6:	d004      	beq.n	7c2 <_usart_init+0x1a>
	ASSERT(false);
     7b8:	4a1d      	ldr	r2, [pc, #116]	; (830 <_usart_init+0x88>)
     7ba:	491e      	ldr	r1, [pc, #120]	; (834 <_usart_init+0x8c>)
     7bc:	2000      	movs	r0, #0
     7be:	4b1e      	ldr	r3, [pc, #120]	; (838 <_usart_init+0x90>)
     7c0:	4798      	blx	r3
	};
}

static inline bool hri_sercomusart_is_syncing(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
     7c2:	69e3      	ldr	r3, [r4, #28]
	uint8_t i = _get_sercom_index(hw);

	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
     7c4:	07db      	lsls	r3, r3, #31
     7c6:	d418      	bmi.n	7fa <_usart_init+0x52>
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     7c8:	2203      	movs	r2, #3
     7ca:	69e3      	ldr	r3, [r4, #28]
     7cc:	421a      	tst	r2, r3
     7ce:	d1fc      	bne.n	7ca <_usart_init+0x22>
static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
     7d0:	6823      	ldr	r3, [r4, #0]
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
     7d2:	079b      	lsls	r3, r3, #30
     7d4:	d50b      	bpl.n	7ee <_usart_init+0x46>
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
     7d6:	6823      	ldr	r3, [r4, #0]
     7d8:	2202      	movs	r2, #2
     7da:	4393      	bics	r3, r2
     7dc:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     7de:	3201      	adds	r2, #1
     7e0:	69e3      	ldr	r3, [r4, #28]
     7e2:	421a      	tst	r2, r3
     7e4:	d1fc      	bne.n	7e0 <_usart_init+0x38>
     7e6:	2202      	movs	r2, #2
     7e8:	69e3      	ldr	r3, [r4, #28]
     7ea:	421a      	tst	r2, r3
     7ec:	d1fc      	bne.n	7e8 <_usart_init+0x40>
}

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
     7ee:	2305      	movs	r3, #5
     7f0:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     7f2:	2203      	movs	r2, #3
     7f4:	69e3      	ldr	r3, [r4, #28]
     7f6:	421a      	tst	r2, r3
     7f8:	d1fc      	bne.n	7f4 <_usart_init+0x4c>
     7fa:	2201      	movs	r2, #1
     7fc:	69e3      	ldr	r3, [r4, #28]
     7fe:	421a      	tst	r2, r3
     800:	d1fc      	bne.n	7fc <_usart_init+0x54>
	((Sercom *)hw)->USART.CTRLA.reg = data;
     802:	4b0e      	ldr	r3, [pc, #56]	; (83c <_usart_init+0x94>)
     804:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     806:	2203      	movs	r2, #3
     808:	69e3      	ldr	r3, [r4, #28]
     80a:	421a      	tst	r2, r3
     80c:	d1fc      	bne.n	808 <_usart_init+0x60>
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
     80e:	23c0      	movs	r3, #192	; 0xc0
     810:	029b      	lsls	r3, r3, #10
     812:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     814:	2207      	movs	r2, #7
     816:	69e3      	ldr	r3, [r4, #28]
     818:	421a      	tst	r2, r3
     81a:	d1fc      	bne.n	816 <_usart_init+0x6e>
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
     81c:	4b08      	ldr	r3, [pc, #32]	; (840 <_usart_init+0x98>)
     81e:	81a3      	strh	r3, [r4, #12]
}

static inline void hri_sercomusart_write_RXPL_reg(const void *const hw, hri_sercomusart_rxpl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.RXPL.reg = data;
     820:	2300      	movs	r3, #0
     822:	73a3      	strb	r3, [r4, #14]
}

static inline void hri_sercomusart_write_DBGCTRL_reg(const void *const hw, hri_sercomusart_dbgctrl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
     824:	2230      	movs	r2, #48	; 0x30
     826:	54a3      	strb	r3, [r4, r2]

	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);

	return ERR_NONE;
}
     828:	2000      	movs	r0, #0
     82a:	bd10      	pop	{r4, pc}
     82c:	bdfff800 	.word	0xbdfff800
     830:	0000025e 	.word	0x0000025e
     834:	00002d58 	.word	0x00002d58
     838:	00000631 	.word	0x00000631
     83c:	40100004 	.word	0x40100004
     840:	ffffd8ad 	.word	0xffffd8ad

00000844 <_usart_async_init>:
{
     844:	b570      	push	{r4, r5, r6, lr}
     846:	0005      	movs	r5, r0
     848:	000c      	movs	r4, r1
	ASSERT(device);
     84a:	1e43      	subs	r3, r0, #1
     84c:	4198      	sbcs	r0, r3
     84e:	b2c0      	uxtb	r0, r0
     850:	22c4      	movs	r2, #196	; 0xc4
     852:	4914      	ldr	r1, [pc, #80]	; (8a4 <_usart_async_init+0x60>)
     854:	4b14      	ldr	r3, [pc, #80]	; (8a8 <_usart_async_init+0x64>)
     856:	4798      	blx	r3
	init_status = _usart_init(hw);
     858:	0020      	movs	r0, r4
     85a:	4b14      	ldr	r3, [pc, #80]	; (8ac <_usart_async_init+0x68>)
     85c:	4798      	blx	r3
	if (init_status) {
     85e:	2800      	cmp	r0, #0
     860:	d000      	beq.n	864 <_usart_async_init+0x20>
}
     862:	bd70      	pop	{r4, r5, r6, pc}
	device->hw = hw;
     864:	61ac      	str	r4, [r5, #24]
	if (hw == SERCOM3) {
     866:	4b12      	ldr	r3, [pc, #72]	; (8b0 <_usart_async_init+0x6c>)
     868:	429c      	cmp	r4, r3
     86a:	d017      	beq.n	89c <_usart_async_init+0x58>
	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
     86c:	4b11      	ldr	r3, [pc, #68]	; (8b4 <_usart_async_init+0x70>)
     86e:	469c      	mov	ip, r3
     870:	4464      	add	r4, ip
     872:	0aa4      	lsrs	r4, r4, #10
/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
	return SERCOM0_IRQn + _sercom_get_hardware_index(hw);
     874:	3409      	adds	r4, #9
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
     876:	b2e3      	uxtb	r3, r4
     878:	0622      	lsls	r2, r4, #24
     87a:	d4f2      	bmi.n	862 <_usart_async_init+0x1e>
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     87c:	221f      	movs	r2, #31
     87e:	401a      	ands	r2, r3
     880:	2301      	movs	r3, #1
     882:	4093      	lsls	r3, r2
     884:	4a0c      	ldr	r2, [pc, #48]	; (8b8 <_usart_async_init+0x74>)
     886:	2180      	movs	r1, #128	; 0x80
     888:	5053      	str	r3, [r2, r1]
  __ASM volatile ("dsb 0xF":::"memory");
     88a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     88e:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     892:	3101      	adds	r1, #1
     894:	31ff      	adds	r1, #255	; 0xff
     896:	5053      	str	r3, [r2, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     898:	6013      	str	r3, [r2, #0]
     89a:	e7e2      	b.n	862 <_usart_async_init+0x1e>
		_sercom3_dev = (struct _usart_async_device *)dev;
     89c:	4b07      	ldr	r3, [pc, #28]	; (8bc <_usart_async_init+0x78>)
     89e:	601d      	str	r5, [r3, #0]
	return SERCOM0_IRQn + _sercom_get_hardware_index(hw);
     8a0:	230c      	movs	r3, #12
     8a2:	e7eb      	b.n	87c <_usart_async_init+0x38>
     8a4:	00002d58 	.word	0x00002d58
     8a8:	00000631 	.word	0x00000631
     8ac:	000007a9 	.word	0x000007a9
     8b0:	42001400 	.word	0x42001400
     8b4:	bdfff800 	.word	0xbdfff800
     8b8:	e000e100 	.word	0xe000e100
     8bc:	20000024 	.word	0x20000024

000008c0 <_usart_async_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
     8c0:	6982      	ldr	r2, [r0, #24]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
     8c2:	6813      	ldr	r3, [r2, #0]
     8c4:	2102      	movs	r1, #2
     8c6:	430b      	orrs	r3, r1
     8c8:	6013      	str	r3, [r2, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
     8ca:	3101      	adds	r1, #1
     8cc:	69d3      	ldr	r3, [r2, #28]
     8ce:	4219      	tst	r1, r3
     8d0:	d1fc      	bne.n	8cc <_usart_async_enable+0xc>
}
     8d2:	4770      	bx	lr

000008d4 <_usart_async_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
     8d4:	6983      	ldr	r3, [r0, #24]
     8d6:	b289      	uxth	r1, r1
	((Sercom *)hw)->USART.DATA.reg = data;
     8d8:	8519      	strh	r1, [r3, #40]	; 0x28
}
     8da:	4770      	bx	lr

000008dc <_usart_async_enable_byte_sent_irq>:
	hri_sercomusart_set_INTEN_DRE_bit(device->hw);
     8dc:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
     8de:	2201      	movs	r2, #1
     8e0:	759a      	strb	r2, [r3, #22]
}
     8e2:	4770      	bx	lr

000008e4 <_usart_async_enable_tx_done_irq>:
	hri_sercomusart_set_INTEN_TXC_bit(device->hw);
     8e4:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
     8e6:	2202      	movs	r2, #2
     8e8:	759a      	strb	r2, [r3, #22]
}
     8ea:	4770      	bx	lr

000008ec <_usart_async_set_irq_state>:
{
     8ec:	b570      	push	{r4, r5, r6, lr}
     8ee:	0004      	movs	r4, r0
     8f0:	000d      	movs	r5, r1
     8f2:	0016      	movs	r6, r2
	ASSERT(device);
     8f4:	1e43      	subs	r3, r0, #1
     8f6:	4198      	sbcs	r0, r3
     8f8:	b2c0      	uxtb	r0, r0
     8fa:	4a16      	ldr	r2, [pc, #88]	; (954 <_usart_async_set_irq_state+0x68>)
     8fc:	4916      	ldr	r1, [pc, #88]	; (958 <_usart_async_set_irq_state+0x6c>)
     8fe:	4b17      	ldr	r3, [pc, #92]	; (95c <_usart_async_set_irq_state+0x70>)
     900:	4798      	blx	r3
	if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
     902:	2302      	movs	r3, #2
     904:	002a      	movs	r2, r5
     906:	439a      	bics	r2, r3
     908:	d10e      	bne.n	928 <_usart_async_set_irq_state+0x3c>
		hri_sercomusart_write_INTEN_DRE_bit(device->hw, state);
     90a:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
     90c:	2e00      	cmp	r6, #0
     90e:	d105      	bne.n	91c <_usart_async_set_irq_state+0x30>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
     910:	2201      	movs	r2, #1
     912:	751a      	strb	r2, [r3, #20]
		hri_sercomusart_write_INTEN_TXC_bit(device->hw, state);
     914:	69a3      	ldr	r3, [r4, #24]
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
     916:	3201      	adds	r2, #1
     918:	751a      	strb	r2, [r3, #20]
}
     91a:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
     91c:	2201      	movs	r2, #1
     91e:	759a      	strb	r2, [r3, #22]
		hri_sercomusart_write_INTEN_TXC_bit(device->hw, state);
     920:	69a3      	ldr	r3, [r4, #24]
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
     922:	3201      	adds	r2, #1
     924:	759a      	strb	r2, [r3, #22]
     926:	e7f8      	b.n	91a <_usart_async_set_irq_state+0x2e>
	} else if (USART_ASYNC_RX_DONE == type) {
     928:	2d01      	cmp	r5, #1
     92a:	d007      	beq.n	93c <_usart_async_set_irq_state+0x50>
	} else if (USART_ASYNC_ERROR == type) {
     92c:	2d03      	cmp	r5, #3
     92e:	d1f4      	bne.n	91a <_usart_async_set_irq_state+0x2e>
		hri_sercomusart_write_INTEN_ERROR_bit(device->hw, state);
     930:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
     932:	2e00      	cmp	r6, #0
     934:	d00b      	beq.n	94e <_usart_async_set_irq_state+0x62>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_ERROR;
     936:	2280      	movs	r2, #128	; 0x80
     938:	759a      	strb	r2, [r3, #22]
}
     93a:	e7ee      	b.n	91a <_usart_async_set_irq_state+0x2e>
		hri_sercomusart_write_INTEN_RXC_bit(device->hw, state);
     93c:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
     93e:	2e00      	cmp	r6, #0
     940:	d102      	bne.n	948 <_usart_async_set_irq_state+0x5c>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_RXC;
     942:	2204      	movs	r2, #4
     944:	751a      	strb	r2, [r3, #20]
     946:	e7e8      	b.n	91a <_usart_async_set_irq_state+0x2e>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_RXC;
     948:	2204      	movs	r2, #4
     94a:	759a      	strb	r2, [r3, #22]
     94c:	e7e5      	b.n	91a <_usart_async_set_irq_state+0x2e>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_ERROR;
     94e:	2280      	movs	r2, #128	; 0x80
     950:	751a      	strb	r2, [r3, #20]
     952:	e7e2      	b.n	91a <_usart_async_set_irq_state+0x2e>
     954:	0000021e 	.word	0x0000021e
     958:	00002d58 	.word	0x00002d58
     95c:	00000631 	.word	0x00000631

00000960 <SERCOM3_Handler>:

	return NULL;
}

void SERCOM3_Handler(void)
{
     960:	b510      	push	{r4, lr}
	_sercom_usart_interrupt_handler(_sercom3_dev);
     962:	4b19      	ldr	r3, [pc, #100]	; (9c8 <SERCOM3_Handler+0x68>)
     964:	6818      	ldr	r0, [r3, #0]
	void *hw = device->hw;
     966:	6984      	ldr	r4, [r0, #24]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
     968:	7e23      	ldrb	r3, [r4, #24]
	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
     96a:	07db      	lsls	r3, r3, #31
     96c:	d502      	bpl.n	974 <SERCOM3_Handler+0x14>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_DRE) >> SERCOM_USART_INTENSET_DRE_Pos;
     96e:	7da3      	ldrb	r3, [r4, #22]
     970:	07db      	lsls	r3, r3, #31
     972:	d40f      	bmi.n	994 <SERCOM3_Handler+0x34>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
     974:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_TXC_bit(hw) && hri_sercomusart_get_INTEN_TXC_bit(hw)) {
     976:	079b      	lsls	r3, r3, #30
     978:	d502      	bpl.n	980 <SERCOM3_Handler+0x20>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_TXC) >> SERCOM_USART_INTENSET_TXC_Pos;
     97a:	7da3      	ldrb	r3, [r4, #22]
     97c:	079b      	lsls	r3, r3, #30
     97e:	d40e      	bmi.n	99e <SERCOM3_Handler+0x3e>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
     980:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_RXC_bit(hw)) {
     982:	075b      	lsls	r3, r3, #29
     984:	d515      	bpl.n	9b2 <SERCOM3_Handler+0x52>
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_status_reg_t hri_sercomusart_read_STATUS_reg(const void *const hw)
{
	return ((Sercom *)hw)->USART.STATUS.reg;
     986:	8b62      	ldrh	r2, [r4, #26]
		if (hri_sercomusart_read_STATUS_reg(hw)
     988:	2337      	movs	r3, #55	; 0x37
     98a:	421a      	tst	r2, r3
     98c:	d00c      	beq.n	9a8 <SERCOM3_Handler+0x48>
	((Sercom *)hw)->USART.STATUS.reg = mask;
     98e:	3308      	adds	r3, #8
     990:	8363      	strh	r3, [r4, #26]
}
     992:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
     994:	2301      	movs	r3, #1
     996:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_byte_sent(device);
     998:	6803      	ldr	r3, [r0, #0]
     99a:	4798      	blx	r3
     99c:	e7f9      	b.n	992 <SERCOM3_Handler+0x32>
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
     99e:	2302      	movs	r3, #2
     9a0:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_done_cb(device);
     9a2:	6883      	ldr	r3, [r0, #8]
     9a4:	4798      	blx	r3
     9a6:	e7f4      	b.n	992 <SERCOM3_Handler+0x32>
	return ((Sercom *)hw)->USART.DATA.reg;
     9a8:	8d21      	ldrh	r1, [r4, #40]	; 0x28
		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
     9aa:	b2c9      	uxtb	r1, r1
     9ac:	6843      	ldr	r3, [r0, #4]
     9ae:	4798      	blx	r3
     9b0:	e7ef      	b.n	992 <SERCOM3_Handler+0x32>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_ERROR) >> SERCOM_USART_INTFLAG_ERROR_Pos;
     9b2:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_ERROR_bit(hw)) {
     9b4:	09db      	lsrs	r3, r3, #7
     9b6:	d0ec      	beq.n	992 <SERCOM3_Handler+0x32>
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
     9b8:	2380      	movs	r3, #128	; 0x80
     9ba:	7623      	strb	r3, [r4, #24]
		device->usart_cb.error_cb(device);
     9bc:	68c3      	ldr	r3, [r0, #12]
     9be:	4798      	blx	r3
	return ((Sercom *)hw)->USART.STATUS.reg;
     9c0:	8b63      	ldrh	r3, [r4, #26]
     9c2:	b29b      	uxth	r3, r3
	((Sercom *)hw)->USART.STATUS.reg = mask;
     9c4:	8363      	strh	r3, [r4, #26]
}
     9c6:	e7e4      	b.n	992 <SERCOM3_Handler+0x32>
     9c8:	20000024 	.word	0x20000024

000009cc <_sysctrl_init_sources>:
}

static inline hri_sysctrl_osc8m_reg_t hri_sysctrl_read_OSC8M_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC8M.reg;
     9cc:	4b0e      	ldr	r3, [pc, #56]	; (a08 <_sysctrl_init_sources+0x3c>)
     9ce:	6a1a      	ldr	r2, [r3, #32]
}

static inline hri_sysctrl_osc8m_reg_t hri_sysctrl_read_OSC8M_FRANGE_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC8M.reg;
     9d0:	6a19      	ldr	r1, [r3, #32]
	hri_sysctrl_write_OSC8M_reg(hw,
	                            SYSCTRL_OSC8M_FRANGE(hri_sysctrl_read_OSC8M_FRANGE_bf(hw)) |
#if CONF_OSC8M_OVERWRITE_CALIBRATION == 1
	                                SYSCTRL_OSC8M_CALIB(CONF_OSC8M_CALIB) |
#else
	                                SYSCTRL_OSC8M_CALIB(calib) |
     9d2:	480e      	ldr	r0, [pc, #56]	; (a0c <_sysctrl_init_sources+0x40>)
     9d4:	4002      	ands	r2, r0
	                            SYSCTRL_OSC8M_FRANGE(hri_sysctrl_read_OSC8M_FRANGE_bf(hw)) |
     9d6:	0f89      	lsrs	r1, r1, #30
     9d8:	0789      	lsls	r1, r1, #30
	hri_sysctrl_write_OSC8M_reg(hw,
     9da:	480d      	ldr	r0, [pc, #52]	; (a10 <_sysctrl_init_sources+0x44>)
     9dc:	4301      	orrs	r1, r0
     9de:	430a      	orrs	r2, r1
}

static inline void hri_sysctrl_write_OSC8M_reg(const void *const hw, hri_sysctrl_osc8m_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC8M.reg = data;
     9e0:	621a      	str	r2, [r3, #32]
	((Sysctrl *)hw)->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
     9e2:	699a      	ldr	r2, [r3, #24]
     9e4:	2102      	movs	r1, #2
     9e6:	430a      	orrs	r2, r1
     9e8:	619a      	str	r2, [r3, #24]
	tmp = ((Sysctrl *)hw)->OSCULP32K.reg;
     9ea:	7f1a      	ldrb	r2, [r3, #28]
	tmp = (tmp & SYSCTRL_OSCULP32K_CALIB_Msk) >> SYSCTRL_OSCULP32K_CALIB_Pos;
     9ec:	311d      	adds	r1, #29
     9ee:	400a      	ands	r2, r1
	((Sysctrl *)hw)->OSCULP32K.reg = data;
     9f0:	771a      	strb	r2, [r3, #28]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_OSC8MRDY) >> SYSCTRL_PCLKSR_OSC8MRDY_Pos;
     9f2:	0019      	movs	r1, r3
#endif
#endif

#if CONF_OSC8M_CONFIG == 1
#if CONF_OSC8M_ENABLE == 1
	while (!hri_sysctrl_get_PCLKSR_OSC8MRDY_bit(hw))
     9f4:	2208      	movs	r2, #8
     9f6:	68cb      	ldr	r3, [r1, #12]
     9f8:	421a      	tst	r2, r3
     9fa:	d0fc      	beq.n	9f6 <_sysctrl_init_sources+0x2a>
	((Sysctrl *)hw)->OSC8M.reg |= SYSCTRL_OSC8M_ONDEMAND;
     9fc:	4a02      	ldr	r2, [pc, #8]	; (a08 <_sysctrl_init_sources+0x3c>)
     9fe:	6a13      	ldr	r3, [r2, #32]
     a00:	2180      	movs	r1, #128	; 0x80
     a02:	430b      	orrs	r3, r1
     a04:	6213      	str	r3, [r2, #32]
	hri_sysctrl_set_OSC8M_ONDEMAND_bit(hw);
#endif
#endif

	(void)calib, (void)hw;
}
     a06:	4770      	bx	lr
     a08:	40000800 	.word	0x40000800
     a0c:	0fff0000 	.word	0x0fff0000
     a10:	00000302 	.word	0x00000302

00000a14 <_sysctrl_init_referenced_generators>:
	((Sysctrl *)hw)->OSC32K.reg &= ~SYSCTRL_OSC32K_ENABLE;
     a14:	4a02      	ldr	r2, [pc, #8]	; (a20 <_sysctrl_init_referenced_generators+0xc>)
     a16:	6993      	ldr	r3, [r2, #24]
     a18:	2102      	movs	r1, #2
     a1a:	438b      	bics	r3, r1
     a1c:	6193      	str	r3, [r2, #24]
	/* Disable after all possible configurations needs sync written. */
	hri_sysctrl_clear_OSC32K_ENABLE_bit(hw);
#endif

	(void)hw;
}
     a1e:	4770      	bx	lr
     a20:	40000800 	.word	0x40000800

00000a24 <task_led>:

/**
 * OS task that blinks LED
 */
static void task_led(void *p)
{
     a24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = mask;
     a26:	25c0      	movs	r5, #192	; 0xc0
     a28:	05ed      	lsls	r5, r5, #23
     a2a:	279c      	movs	r7, #156	; 0x9c
     a2c:	2680      	movs	r6, #128	; 0x80
     a2e:	05f6      	lsls	r6, r6, #23
	(void)p;
	for (;;) {
		gpio_toggle_pin_level(LED0);
		os_sleep(500);
     a30:	4c02      	ldr	r4, [pc, #8]	; (a3c <task_led+0x18>)
     a32:	51ee      	str	r6, [r5, r7]
     a34:	20fa      	movs	r0, #250	; 0xfa
     a36:	0040      	lsls	r0, r0, #1
     a38:	47a0      	blx	r4
     a3a:	e7fa      	b.n	a32 <task_led+0xe>
     a3c:	00002169 	.word	0x00002169

00000a40 <str_write>:
{
     a40:	b510      	push	{r4, lr}
     a42:	0004      	movs	r4, r0
	io_write(&EDBG_COM.io, (const uint8_t *)s, strlen(s));
     a44:	4b03      	ldr	r3, [pc, #12]	; (a54 <str_write+0x14>)
     a46:	4798      	blx	r3
     a48:	b282      	uxth	r2, r0
     a4a:	0021      	movs	r1, r4
     a4c:	4802      	ldr	r0, [pc, #8]	; (a58 <str_write+0x18>)
     a4e:	4b03      	ldr	r3, [pc, #12]	; (a5c <str_write+0x1c>)
     a50:	4798      	blx	r3
}
     a52:	bd10      	pop	{r4, pc}
     a54:	00002cf7 	.word	0x00002cf7
     a58:	20000b64 	.word	0x20000b64
     a5c:	00000309 	.word	0x00000309

00000a60 <disp_mutex_give>:
{
     a60:	b510      	push	{r4, lr}
	xSemaphoreGive(disp_mutex);
     a62:	4b04      	ldr	r3, [pc, #16]	; (a74 <disp_mutex_give+0x14>)
     a64:	6818      	ldr	r0, [r3, #0]
     a66:	2300      	movs	r3, #0
     a68:	2200      	movs	r2, #0
     a6a:	2100      	movs	r1, #0
     a6c:	4c02      	ldr	r4, [pc, #8]	; (a78 <disp_mutex_give+0x18>)
     a6e:	47a0      	blx	r4
}
     a70:	bd10      	pop	{r4, pc}
     a72:	46c0      	nop			; (mov r8, r8)
     a74:	20000028 	.word	0x20000028
     a78:	000014c1 	.word	0x000014c1

00000a7c <task_console>:

/**
 * OS task that monitor console inputs and do actions
 */
static void task_console(void *p)
{
     a7c:	b5f0      	push	{r4, r5, r6, r7, lr}
     a7e:	b083      	sub	sp, #12
	(void)p;
	for (;;) {
		char *str   = "";
		char  ch[2] = {0, 0};
     a80:	ae01      	add	r6, sp, #4
     a82:	2700      	movs	r7, #0
     a84:	e017      	b.n	ab6 <task_console+0x3a>
		ch[0]       = char_read();
		switch (ch[0]) {
     a86:	2b4d      	cmp	r3, #77	; 0x4d
     a88:	d13d      	bne.n	b06 <task_console+0x8a>
}

static void task_monitor_pause(bool pause)
{
	if (pause) {
		vTaskSuspend(xCreatedMonitorTask);
     a8a:	4b23      	ldr	r3, [pc, #140]	; (b18 <task_console+0x9c>)
     a8c:	6898      	ldr	r0, [r3, #8]
     a8e:	4b23      	ldr	r3, [pc, #140]	; (b1c <task_console+0xa0>)
     a90:	4798      	blx	r3
			str_write("- Monitor task suspended.\r\n");
     a92:	4823      	ldr	r0, [pc, #140]	; (b20 <task_console+0xa4>)
     a94:	4b23      	ldr	r3, [pc, #140]	; (b24 <task_console+0xa8>)
     a96:	4798      	blx	r3
		char *str   = "";
     a98:	4c23      	ldr	r4, [pc, #140]	; (b28 <task_console+0xac>)
			break;
     a9a:	e004      	b.n	aa6 <task_console+0x2a>
		vTaskResume(xCreatedLedTask);
     a9c:	4b1e      	ldr	r3, [pc, #120]	; (b18 <task_console+0x9c>)
     a9e:	6858      	ldr	r0, [r3, #4]
     aa0:	4b22      	ldr	r3, [pc, #136]	; (b2c <task_console+0xb0>)
     aa2:	4798      	blx	r3
			str = ("- LED blink task active.\r\n");
     aa4:	4c22      	ldr	r4, [pc, #136]	; (b30 <task_console+0xb4>)
	return xSemaphoreTake(disp_mutex, ~0);
     aa6:	4b1c      	ldr	r3, [pc, #112]	; (b18 <task_console+0x9c>)
     aa8:	6818      	ldr	r0, [r3, #0]
     aaa:	2101      	movs	r1, #1
     aac:	4249      	negs	r1, r1
     aae:	4b21      	ldr	r3, [pc, #132]	; (b34 <task_console+0xb8>)
     ab0:	4798      	blx	r3
		if (disp_mutex_take()) {
     ab2:	2800      	cmp	r0, #0
     ab4:	d129      	bne.n	b0a <task_console+0x8e>
		char  ch[2] = {0, 0};
     ab6:	7037      	strb	r7, [r6, #0]
     ab8:	7077      	strb	r7, [r6, #1]
	while (ERR_TIMEOUT == io_read(&EDBG_COM.io, &tmp, 1)) {
     aba:	4d1f      	ldr	r5, [pc, #124]	; (b38 <task_console+0xbc>)
     abc:	4c1f      	ldr	r4, [pc, #124]	; (b3c <task_console+0xc0>)
     abe:	2201      	movs	r2, #1
     ac0:	466b      	mov	r3, sp
     ac2:	1cd9      	adds	r1, r3, #3
     ac4:	0028      	movs	r0, r5
     ac6:	47a0      	blx	r4
     ac8:	3008      	adds	r0, #8
     aca:	d0f8      	beq.n	abe <task_console+0x42>
	return (char)tmp;
     acc:	466b      	mov	r3, sp
     ace:	3303      	adds	r3, #3
     ad0:	781b      	ldrb	r3, [r3, #0]
		ch[0]       = char_read();
     ad2:	7033      	strb	r3, [r6, #0]
		switch (ch[0]) {
     ad4:	2b61      	cmp	r3, #97	; 0x61
     ad6:	d0e1      	beq.n	a9c <task_console+0x20>
     ad8:	d9d5      	bls.n	a86 <task_console+0xa>
     ada:	2b6d      	cmp	r3, #109	; 0x6d
     adc:	d00d      	beq.n	afa <task_console+0x7e>
     ade:	2b73      	cmp	r3, #115	; 0x73
     ae0:	d111      	bne.n	b06 <task_console+0x8a>
		vTaskSuspend(xCreatedLedTask);
     ae2:	4b0d      	ldr	r3, [pc, #52]	; (b18 <task_console+0x9c>)
     ae4:	6858      	ldr	r0, [r3, #4]
     ae6:	4b0d      	ldr	r3, [pc, #52]	; (b1c <task_console+0xa0>)
     ae8:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     aea:	2180      	movs	r1, #128	; 0x80
     aec:	05c9      	lsls	r1, r1, #23
     aee:	2398      	movs	r3, #152	; 0x98
     af0:	22c0      	movs	r2, #192	; 0xc0
     af2:	05d2      	lsls	r2, r2, #23
     af4:	50d1      	str	r1, [r2, r3]
			str = ("- LED OFF and blink task suspended.\r\n");
     af6:	4c12      	ldr	r4, [pc, #72]	; (b40 <task_console+0xc4>)
     af8:	e7d5      	b.n	aa6 <task_console+0x2a>
	} else {
		vTaskResume(xCreatedMonitorTask);
     afa:	4b07      	ldr	r3, [pc, #28]	; (b18 <task_console+0x9c>)
     afc:	6898      	ldr	r0, [r3, #8]
     afe:	4b0b      	ldr	r3, [pc, #44]	; (b2c <task_console+0xb0>)
     b00:	4798      	blx	r3
			str = ("- Monitor task active.\r\n");
     b02:	4c10      	ldr	r4, [pc, #64]	; (b44 <task_console+0xc8>)
     b04:	e7cf      	b.n	aa6 <task_console+0x2a>
			str = ch;
     b06:	0034      	movs	r4, r6
     b08:	e7cd      	b.n	aa6 <task_console+0x2a>
			str_write(str);
     b0a:	0020      	movs	r0, r4
     b0c:	4b05      	ldr	r3, [pc, #20]	; (b24 <task_console+0xa8>)
     b0e:	4798      	blx	r3
			disp_mutex_give();
     b10:	4b0d      	ldr	r3, [pc, #52]	; (b48 <task_console+0xcc>)
     b12:	4798      	blx	r3
	for (;;) {
     b14:	e7cf      	b.n	ab6 <task_console+0x3a>
     b16:	46c0      	nop			; (mov r8, r8)
     b18:	20000028 	.word	0x20000028
     b1c:	00002235 	.word	0x00002235
     b20:	00002dfc 	.word	0x00002dfc
     b24:	00000a41 	.word	0x00000a41
     b28:	00002df8 	.word	0x00002df8
     b2c:	00001e5d 	.word	0x00001e5d
     b30:	00002d9c 	.word	0x00002d9c
     b34:	0000194d 	.word	0x0000194d
     b38:	20000b64 	.word	0x20000b64
     b3c:	0000033d 	.word	0x0000033d
     b40:	00002db8 	.word	0x00002db8
     b44:	00002de0 	.word	0x00002de0
     b48:	00000a61 	.word	0x00000a61

00000b4c <main>:
{
	vTaskStartScheduler();
}

int main(void)
{
     b4c:	b510      	push	{r4, lr}
     b4e:	b082      	sub	sp, #8
	atmel_start_init();
     b50:	4b1b      	ldr	r3, [pc, #108]	; (bc0 <main+0x74>)
     b52:	4798      	blx	r3
	disp_mutex = xSemaphoreCreateMutex();
     b54:	2001      	movs	r0, #1
     b56:	4b1b      	ldr	r3, [pc, #108]	; (bc4 <main+0x78>)
     b58:	4798      	blx	r3
     b5a:	4b1b      	ldr	r3, [pc, #108]	; (bc8 <main+0x7c>)
     b5c:	6018      	str	r0, [r3, #0]
	if (disp_mutex == NULL) {
     b5e:	2800      	cmp	r0, #0
     b60:	d00d      	beq.n	b7e <main+0x32>
	if (xTaskCreate(
     b62:	4b19      	ldr	r3, [pc, #100]	; (bc8 <main+0x7c>)
     b64:	3308      	adds	r3, #8
     b66:	9301      	str	r3, [sp, #4]
     b68:	2302      	movs	r3, #2
     b6a:	9300      	str	r3, [sp, #0]
     b6c:	2300      	movs	r3, #0
     b6e:	224b      	movs	r2, #75	; 0x4b
     b70:	4916      	ldr	r1, [pc, #88]	; (bcc <main+0x80>)
     b72:	4817      	ldr	r0, [pc, #92]	; (bd0 <main+0x84>)
     b74:	4c17      	ldr	r4, [pc, #92]	; (bd4 <main+0x88>)
     b76:	47a0      	blx	r4
     b78:	2801      	cmp	r0, #1
     b7a:	d001      	beq.n	b80 <main+0x34>
     b7c:	e7fe      	b.n	b7c <main+0x30>
     b7e:	e7fe      	b.n	b7e <main+0x32>
	if (xTaskCreate(task_led, "Led", TASK_LED_STACK_SIZE, NULL, TASK_LED_STACK_PRIORITY, &xCreatedLedTask) != pdPASS) {
     b80:	4b11      	ldr	r3, [pc, #68]	; (bc8 <main+0x7c>)
     b82:	3304      	adds	r3, #4
     b84:	9301      	str	r3, [sp, #4]
     b86:	2301      	movs	r3, #1
     b88:	9300      	str	r3, [sp, #0]
     b8a:	2300      	movs	r3, #0
     b8c:	221b      	movs	r2, #27
     b8e:	4912      	ldr	r1, [pc, #72]	; (bd8 <main+0x8c>)
     b90:	4812      	ldr	r0, [pc, #72]	; (bdc <main+0x90>)
     b92:	4c10      	ldr	r4, [pc, #64]	; (bd4 <main+0x88>)
     b94:	47a0      	blx	r4
     b96:	2801      	cmp	r0, #1
     b98:	d000      	beq.n	b9c <main+0x50>
     b9a:	e7fe      	b.n	b9a <main+0x4e>
	if (xTaskCreate(task_console, "Console", TASK_CLI_STACK_SIZE, NULL, TASK_CLI_PRIORITY, &xCreatedConsoleTask)
     b9c:	4b0a      	ldr	r3, [pc, #40]	; (bc8 <main+0x7c>)
     b9e:	330c      	adds	r3, #12
     ba0:	9301      	str	r3, [sp, #4]
     ba2:	2300      	movs	r3, #0
     ba4:	9300      	str	r3, [sp, #0]
     ba6:	2240      	movs	r2, #64	; 0x40
     ba8:	490d      	ldr	r1, [pc, #52]	; (be0 <main+0x94>)
     baa:	480e      	ldr	r0, [pc, #56]	; (be4 <main+0x98>)
     bac:	4c09      	ldr	r4, [pc, #36]	; (bd4 <main+0x88>)
     bae:	47a0      	blx	r4
     bb0:	2801      	cmp	r0, #1
     bb2:	d000      	beq.n	bb6 <main+0x6a>
     bb4:	e7fe      	b.n	bb4 <main+0x68>
	vTaskStartScheduler();
     bb6:	4b0c      	ldr	r3, [pc, #48]	; (be8 <main+0x9c>)
     bb8:	4798      	blx	r3
	task_console_create();
#endif
	tasks_run();

	return 0;
}
     bba:	2000      	movs	r0, #0
     bbc:	b002      	add	sp, #8
     bbe:	bd10      	pop	{r4, pc}
     bc0:	00000115 	.word	0x00000115
     bc4:	0000164d 	.word	0x0000164d
     bc8:	20000028 	.word	0x20000028
     bcc:	00002e18 	.word	0x00002e18
     bd0:	00000d3d 	.word	0x00000d3d
     bd4:	00001c35 	.word	0x00001c35
     bd8:	00002e20 	.word	0x00002e20
     bdc:	00000a25 	.word	0x00000a25
     be0:	00002e24 	.word	0x00002e24
     be4:	00000a7d 	.word	0x00000a7d
     be8:	00001edd 	.word	0x00001edd

00000bec <sprintu>:
#if _SPRINTF_OVERRIDE
/* Override sprintf implement to optimize */

static const unsigned m_val[] = {1000000000u, 100000000u, 10000000u, 1000000u, 100000u, 10000u, 1000u, 100u, 10u, 1u};
int                   sprintu(char *s, unsigned u)
{
     bec:	b5f0      	push	{r4, r5, r6, r7, lr}
     bee:	b085      	sub	sp, #20
     bf0:	2400      	movs	r4, #0
	char tmp_buf[12];
	int  i, n = 0;
	int  m;

	if (u == 0) {
     bf2:	2900      	cmp	r1, #0
     bf4:	d002      	beq.n	bfc <sprintu+0x10>
		return 1;
	}

	for (i = 0; i < 10; i++) {
		for (m = 0; m < 10; m++) {
			if (u >= m_val[i]) {
     bf6:	4f1b      	ldr	r7, [pc, #108]	; (c64 <sprintu+0x78>)
				u -= m_val[i];
			} else {
				break;
			}
		}
		tmp_buf[i] = m + '0';
     bf8:	ad01      	add	r5, sp, #4
     bfa:	e008      	b.n	c0e <sprintu+0x22>
		*s = '0';
     bfc:	2330      	movs	r3, #48	; 0x30
     bfe:	7003      	strb	r3, [r0, #0]
		return 1;
     c00:	3b2f      	subs	r3, #47	; 0x2f
     c02:	e02b      	b.n	c5c <sprintu+0x70>
		tmp_buf[i] = m + '0';
     c04:	3330      	adds	r3, #48	; 0x30
     c06:	5573      	strb	r3, [r6, r5]
	for (i = 0; i < 10; i++) {
     c08:	3401      	adds	r4, #1
     c0a:	2c0a      	cmp	r4, #10
     c0c:	d00e      	beq.n	c2c <sprintu+0x40>
     c0e:	0026      	movs	r6, r4
			if (u >= m_val[i]) {
     c10:	00a3      	lsls	r3, r4, #2
     c12:	59da      	ldr	r2, [r3, r7]
     c14:	2300      	movs	r3, #0
     c16:	4291      	cmp	r1, r2
     c18:	d3f4      	bcc.n	c04 <sprintu+0x18>
				u -= m_val[i];
     c1a:	1a89      	subs	r1, r1, r2
		for (m = 0; m < 10; m++) {
     c1c:	2301      	movs	r3, #1
			if (u >= m_val[i]) {
     c1e:	428a      	cmp	r2, r1
     c20:	d8f0      	bhi.n	c04 <sprintu+0x18>
				u -= m_val[i];
     c22:	1a89      	subs	r1, r1, r2
		for (m = 0; m < 10; m++) {
     c24:	3301      	adds	r3, #1
     c26:	2b0a      	cmp	r3, #10
     c28:	d1f9      	bne.n	c1e <sprintu+0x32>
     c2a:	e7eb      	b.n	c04 <sprintu+0x18>
	}
	for (i = 0; i < 10; i++) {
		if (tmp_buf[i] != '0') {
     c2c:	ab01      	add	r3, sp, #4
     c2e:	781b      	ldrb	r3, [r3, #0]
     c30:	2b30      	cmp	r3, #48	; 0x30
     c32:	d109      	bne.n	c48 <sprintu+0x5c>
     c34:	2201      	movs	r2, #1
     c36:	a901      	add	r1, sp, #4
     c38:	5c53      	ldrb	r3, [r2, r1]
     c3a:	2b30      	cmp	r3, #48	; 0x30
     c3c:	d105      	bne.n	c4a <sprintu+0x5e>
	for (i = 0; i < 10; i++) {
     c3e:	3201      	adds	r2, #1
     c40:	2a0a      	cmp	r2, #10
     c42:	d1f9      	bne.n	c38 <sprintu+0x4c>
     c44:	2300      	movs	r3, #0
     c46:	e009      	b.n	c5c <sprintu+0x70>
		if (tmp_buf[i] != '0') {
     c48:	2200      	movs	r2, #0
     c4a:	2300      	movs	r3, #0
			break;
		}
	}
	for (; i < 10; i++) {
		*s++ = tmp_buf[i];
     c4c:	a901      	add	r1, sp, #4
     c4e:	188c      	adds	r4, r1, r2
     c50:	5ce1      	ldrb	r1, [r4, r3]
     c52:	54c1      	strb	r1, [r0, r3]
		n++;
     c54:	3301      	adds	r3, #1
	for (; i < 10; i++) {
     c56:	1899      	adds	r1, r3, r2
     c58:	2909      	cmp	r1, #9
     c5a:	ddf9      	ble.n	c50 <sprintu+0x64>
	}
	return n;
}
     c5c:	0018      	movs	r0, r3
     c5e:	b005      	add	sp, #20
     c60:	bdf0      	pop	{r4, r5, r6, r7, pc}
     c62:	46c0      	nop			; (mov r8, r8)
     c64:	00002d74 	.word	0x00002d74

00000c68 <sprintf>:

int sprintf(char *s, const char *fmt, ...)
{
     c68:	b40e      	push	{r1, r2, r3}
     c6a:	b5f0      	push	{r4, r5, r6, r7, lr}
     c6c:	b082      	sub	sp, #8
     c6e:	0004      	movs	r4, r0
     c70:	ab07      	add	r3, sp, #28
     c72:	cb20      	ldmia	r3!, {r5}
	int     n = 0;
	va_list ap;
	va_start(ap, fmt);
     c74:	9301      	str	r3, [sp, #4]
	int     n = 0;
     c76:	2600      	movs	r6, #0
	while (*fmt) {
     c78:	782b      	ldrb	r3, [r5, #0]
     c7a:	2b00      	cmp	r3, #0
     c7c:	d054      	beq.n	d28 <sprintf+0xc0>
		if (*fmt != '%') {
     c7e:	2b25      	cmp	r3, #37	; 0x25
     c80:	d004      	beq.n	c8c <sprintf+0x24>
			*s = *fmt;
     c82:	7023      	strb	r3, [r4, #0]
			s++;
     c84:	3401      	adds	r4, #1
			fmt++;
     c86:	3501      	adds	r5, #1
			n++;
     c88:	3601      	adds	r6, #1
     c8a:	e7f5      	b.n	c78 <sprintf+0x10>
		} else {
			fmt++;
			switch (*fmt) {
     c8c:	786b      	ldrb	r3, [r5, #1]
     c8e:	2b64      	cmp	r3, #100	; 0x64
     c90:	d01a      	beq.n	cc8 <sprintf+0x60>
     c92:	d90e      	bls.n	cb2 <sprintf+0x4a>
     c94:	2b73      	cmp	r3, #115	; 0x73
     c96:	d02e      	beq.n	cf6 <sprintf+0x8e>
     c98:	2b75      	cmp	r3, #117	; 0x75
     c9a:	d140      	bne.n	d1e <sprintf+0xb6>
				n += nc;
				fmt++;
				break;
			}
			case 'u': {
				unsigned valu = va_arg(ap, unsigned);
     c9c:	9b01      	ldr	r3, [sp, #4]
     c9e:	1d1a      	adds	r2, r3, #4
     ca0:	9201      	str	r2, [sp, #4]
				int      nc   = sprintu(s, valu);
     ca2:	6819      	ldr	r1, [r3, #0]
     ca4:	0020      	movs	r0, r4
     ca6:	4b24      	ldr	r3, [pc, #144]	; (d38 <sprintf+0xd0>)
     ca8:	4798      	blx	r3
				n += nc;
     caa:	1836      	adds	r6, r6, r0
				s += nc;
     cac:	1824      	adds	r4, r4, r0
				fmt++;
     cae:	3502      	adds	r5, #2
				break;
     cb0:	e7e2      	b.n	c78 <sprintf+0x10>
			switch (*fmt) {
     cb2:	2b63      	cmp	r3, #99	; 0x63
     cb4:	d133      	bne.n	d1e <sprintf+0xb6>
				char valch = va_arg(ap, int);
     cb6:	9b01      	ldr	r3, [sp, #4]
     cb8:	1d1a      	adds	r2, r3, #4
     cba:	9201      	str	r2, [sp, #4]
     cbc:	681b      	ldr	r3, [r3, #0]
     cbe:	7023      	strb	r3, [r4, #0]
				s++;
     cc0:	3401      	adds	r4, #1
				fmt++;
     cc2:	3502      	adds	r5, #2
				n++;
     cc4:	3601      	adds	r6, #1
				break;
     cc6:	e7d7      	b.n	c78 <sprintf+0x10>
				int vali = va_arg(ap, int);
     cc8:	9b01      	ldr	r3, [sp, #4]
     cca:	1d1a      	adds	r2, r3, #4
     ccc:	9201      	str	r2, [sp, #4]
     cce:	6819      	ldr	r1, [r3, #0]
				if (vali < 0) {
     cd0:	2900      	cmp	r1, #0
     cd2:	db06      	blt.n	ce2 <sprintf+0x7a>
					nc = sprintu(s, vali);
     cd4:	0020      	movs	r0, r4
     cd6:	4b18      	ldr	r3, [pc, #96]	; (d38 <sprintf+0xd0>)
     cd8:	4798      	blx	r3
				s += nc;
     cda:	1824      	adds	r4, r4, r0
				n += nc;
     cdc:	1836      	adds	r6, r6, r0
				fmt++;
     cde:	3502      	adds	r5, #2
				break;
     ce0:	e7ca      	b.n	c78 <sprintf+0x10>
					*s++ = '-';
     ce2:	1c67      	adds	r7, r4, #1
     ce4:	232d      	movs	r3, #45	; 0x2d
     ce6:	7023      	strb	r3, [r4, #0]
					n++;
     ce8:	3601      	adds	r6, #1
					nc = sprintu(s, -vali);
     cea:	4249      	negs	r1, r1
     cec:	0038      	movs	r0, r7
     cee:	4b12      	ldr	r3, [pc, #72]	; (d38 <sprintf+0xd0>)
     cf0:	4798      	blx	r3
					*s++ = '-';
     cf2:	003c      	movs	r4, r7
     cf4:	e7f1      	b.n	cda <sprintf+0x72>
			}
			case 's': {
				char *vals = va_arg(ap, char *);
     cf6:	9b01      	ldr	r3, [sp, #4]
     cf8:	1d1a      	adds	r2, r3, #4
     cfa:	9201      	str	r2, [sp, #4]
     cfc:	6819      	ldr	r1, [r3, #0]
				while (*vals) {
     cfe:	780b      	ldrb	r3, [r1, #0]
     d00:	2b00      	cmp	r3, #0
     d02:	d00a      	beq.n	d1a <sprintf+0xb2>
     d04:	0032      	movs	r2, r6
     d06:	1b8e      	subs	r6, r1, r6
					*s = *vals;
     d08:	7023      	strb	r3, [r4, #0]
					s++;
     d0a:	3401      	adds	r4, #1
					vals++;
					n++;
     d0c:	3201      	adds	r2, #1
				while (*vals) {
     d0e:	5cb3      	ldrb	r3, [r6, r2]
     d10:	2b00      	cmp	r3, #0
     d12:	d1f9      	bne.n	d08 <sprintf+0xa0>
				}
				fmt++;
     d14:	3502      	adds	r5, #2
				break;
     d16:	0016      	movs	r6, r2
     d18:	e7ae      	b.n	c78 <sprintf+0x10>
				while (*vals) {
     d1a:	0032      	movs	r2, r6
     d1c:	e7fa      	b.n	d14 <sprintf+0xac>
			}
			default:
				*s = *fmt;
     d1e:	7023      	strb	r3, [r4, #0]
				s++;
     d20:	3401      	adds	r4, #1
				fmt++;
     d22:	3502      	adds	r5, #2
				n++;
     d24:	3601      	adds	r6, #1
     d26:	e7a7      	b.n	c78 <sprintf+0x10>
			}
		}
	}
	va_end(ap);
	*s = 0;
     d28:	7023      	strb	r3, [r4, #0]
	return n;
}
     d2a:	0030      	movs	r0, r6
     d2c:	b002      	add	sp, #8
     d2e:	bcf0      	pop	{r4, r5, r6, r7}
     d30:	bc08      	pop	{r3}
     d32:	b003      	add	sp, #12
     d34:	4718      	bx	r3
     d36:	46c0      	nop			; (mov r8, r8)
     d38:	00000bed 	.word	0x00000bed

00000d3c <task_monitor>:
{
     d3c:	b5f0      	push	{r4, r5, r6, r7, lr}
     d3e:	b083      	sub	sp, #12
	return xSemaphoreTake(disp_mutex, ~0);
     d40:	4e18      	ldr	r6, [pc, #96]	; (da4 <task_monitor+0x68>)
	sprintf(szList, "%c%s%c%s", 0x1B, "[1;1H", 0x1B, "[2J");
     d42:	0035      	movs	r5, r6
     d44:	3510      	adds	r5, #16
     d46:	e002      	b.n	d4e <task_monitor+0x12>
		os_sleep(5000);
     d48:	4817      	ldr	r0, [pc, #92]	; (da8 <task_monitor+0x6c>)
     d4a:	4b18      	ldr	r3, [pc, #96]	; (dac <task_monitor+0x70>)
     d4c:	4798      	blx	r3
	return xSemaphoreTake(disp_mutex, ~0);
     d4e:	2101      	movs	r1, #1
     d50:	4249      	negs	r1, r1
     d52:	6830      	ldr	r0, [r6, #0]
     d54:	4b16      	ldr	r3, [pc, #88]	; (db0 <task_monitor+0x74>)
     d56:	4798      	blx	r3
		if (disp_mutex_take()) {
     d58:	2800      	cmp	r0, #0
     d5a:	d0f5      	beq.n	d48 <task_monitor+0xc>
	sprintf(szList, "%c%s%c%s", 0x1B, "[1;1H", 0x1B, "[2J");
     d5c:	4b15      	ldr	r3, [pc, #84]	; (db4 <task_monitor+0x78>)
     d5e:	9301      	str	r3, [sp, #4]
     d60:	231b      	movs	r3, #27
     d62:	9300      	str	r3, [sp, #0]
     d64:	4b14      	ldr	r3, [pc, #80]	; (db8 <task_monitor+0x7c>)
     d66:	221b      	movs	r2, #27
     d68:	4914      	ldr	r1, [pc, #80]	; (dbc <task_monitor+0x80>)
     d6a:	0028      	movs	r0, r5
     d6c:	4f14      	ldr	r7, [pc, #80]	; (dc0 <task_monitor+0x84>)
     d6e:	47b8      	blx	r7
	str_write(szList);
     d70:	0028      	movs	r0, r5
     d72:	4c14      	ldr	r4, [pc, #80]	; (dc4 <task_monitor+0x88>)
     d74:	47a0      	blx	r4
	sprintf(szList, "--- Number of tasks: %u\r\n", (unsigned int)uxTaskGetNumberOfTasks());
     d76:	4b14      	ldr	r3, [pc, #80]	; (dc8 <task_monitor+0x8c>)
     d78:	4798      	blx	r3
     d7a:	0002      	movs	r2, r0
     d7c:	4913      	ldr	r1, [pc, #76]	; (dcc <task_monitor+0x90>)
     d7e:	0028      	movs	r0, r5
     d80:	47b8      	blx	r7
	str_write(szList);
     d82:	0028      	movs	r0, r5
     d84:	47a0      	blx	r4
	str_write("> Tasks\tState\tPri\tStack\tNum\r\n");
     d86:	4812      	ldr	r0, [pc, #72]	; (dd0 <task_monitor+0x94>)
     d88:	47a0      	blx	r4
	str_write("***********************************\r\n");
     d8a:	4812      	ldr	r0, [pc, #72]	; (dd4 <task_monitor+0x98>)
     d8c:	47a0      	blx	r4
	vTaskList(szList);
     d8e:	0028      	movs	r0, r5
     d90:	4b11      	ldr	r3, [pc, #68]	; (dd8 <task_monitor+0x9c>)
     d92:	4798      	blx	r3
	str_write(szList);
     d94:	0028      	movs	r0, r5
     d96:	47a0      	blx	r4
	str_write("--- Press a key:\r\n"
     d98:	4810      	ldr	r0, [pc, #64]	; (ddc <task_monitor+0xa0>)
     d9a:	47a0      	blx	r4
			disp_mutex_give();
     d9c:	4b10      	ldr	r3, [pc, #64]	; (de0 <task_monitor+0xa4>)
     d9e:	4798      	blx	r3
     da0:	e7d2      	b.n	d48 <task_monitor+0xc>
     da2:	46c0      	nop			; (mov r8, r8)
     da4:	20000028 	.word	0x20000028
     da8:	00001388 	.word	0x00001388
     dac:	00002169 	.word	0x00002169
     db0:	0000194d 	.word	0x0000194d
     db4:	00002e40 	.word	0x00002e40
     db8:	00002e2c 	.word	0x00002e2c
     dbc:	00002e34 	.word	0x00002e34
     dc0:	00000c69 	.word	0x00000c69
     dc4:	00000a41 	.word	0x00000a41
     dc8:	00001f61 	.word	0x00001f61
     dcc:	00002e44 	.word	0x00002e44
     dd0:	00002e60 	.word	0x00002e60
     dd4:	00002e80 	.word	0x00002e80
     dd8:	000027c9 	.word	0x000027c9
     ddc:	00002ea8 	.word	0x00002ea8
     de0:	00000a61 	.word	0x00000a61

00000de4 <sem_init>:

/**
 * \brief Semaphore initialization
 */
int32_t sem_init(sem_t *sem, uint32_t count)
{
     de4:	b570      	push	{r4, r5, r6, lr}
     de6:	0005      	movs	r5, r0
     de8:	000c      	movs	r4, r1
	ASSERT(count <= SEMAPHORE_MAX_COUNT);
     dea:	2000      	movs	r0, #0
     dec:	2301      	movs	r3, #1
     dee:	428b      	cmp	r3, r1
     df0:	4140      	adcs	r0, r0
     df2:	b2c0      	uxtb	r0, r0
     df4:	222b      	movs	r2, #43	; 0x2b
     df6:	4907      	ldr	r1, [pc, #28]	; (e14 <sem_init+0x30>)
     df8:	4b07      	ldr	r3, [pc, #28]	; (e18 <sem_init+0x34>)
     dfa:	4798      	blx	r3

	*sem = xSemaphoreCreateCounting((uint32_t)SEMAPHORE_MAX_COUNT, count);
     dfc:	0021      	movs	r1, r4
     dfe:	2001      	movs	r0, #1
     e00:	4b06      	ldr	r3, [pc, #24]	; (e1c <sem_init+0x38>)
     e02:	4798      	blx	r3
     e04:	6028      	str	r0, [r5, #0]

	return *sem ? ERR_NONE : ERR_NOT_INITIALIZED;
     e06:	2300      	movs	r3, #0
     e08:	2800      	cmp	r0, #0
     e0a:	d001      	beq.n	e10 <sem_init+0x2c>
}
     e0c:	0018      	movs	r0, r3
     e0e:	bd70      	pop	{r4, r5, r6, pc}
	return *sem ? ERR_NONE : ERR_NOT_INITIALIZED;
     e10:	3b14      	subs	r3, #20
     e12:	e7fb      	b.n	e0c <sem_init+0x28>
     e14:	00002f10 	.word	0x00002f10
     e18:	00000631 	.word	0x00000631
     e1c:	00001499 	.word	0x00001499

00000e20 <sem_up>:

/**
 * \brief Semaphore up
 */
int32_t sem_up(sem_t *sem)
{
     e20:	b510      	push	{r4, lr}
 * \brief Check if it's in ISR handling
 * \return \c true if it's in ISR
 */
static inline bool _is_in_isr(void)
{
	return (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk);
     e22:	4b0d      	ldr	r3, [pc, #52]	; (e58 <sem_up+0x38>)
     e24:	685b      	ldr	r3, [r3, #4]
     e26:	05db      	lsls	r3, r3, #23
	return is_in_isr() ? (xSemaphoreGiveFromISR(*sem, pdFALSE) ? 0 : ERR_ABORTED)
	                   : (xSemaphoreGive(*sem) ? ERR_NONE : ERR_ABORTED);
     e28:	d00a      	beq.n	e40 <sem_up+0x20>
	return is_in_isr() ? (xSemaphoreGiveFromISR(*sem, pdFALSE) ? 0 : ERR_ABORTED)
     e2a:	6800      	ldr	r0, [r0, #0]
     e2c:	2100      	movs	r1, #0
     e2e:	4b0b      	ldr	r3, [pc, #44]	; (e5c <sem_up+0x3c>)
     e30:	4798      	blx	r3
	                   : (xSemaphoreGive(*sem) ? ERR_NONE : ERR_ABORTED);
     e32:	2300      	movs	r3, #0
     e34:	2800      	cmp	r0, #0
     e36:	d001      	beq.n	e3c <sem_up+0x1c>
}
     e38:	0018      	movs	r0, r3
     e3a:	bd10      	pop	{r4, pc}
	                   : (xSemaphoreGive(*sem) ? ERR_NONE : ERR_ABORTED);
     e3c:	3b03      	subs	r3, #3
     e3e:	e7fb      	b.n	e38 <sem_up+0x18>
     e40:	6800      	ldr	r0, [r0, #0]
     e42:	2300      	movs	r3, #0
     e44:	2200      	movs	r2, #0
     e46:	2100      	movs	r1, #0
     e48:	4c05      	ldr	r4, [pc, #20]	; (e60 <sem_up+0x40>)
     e4a:	47a0      	blx	r4
     e4c:	2300      	movs	r3, #0
     e4e:	2800      	cmp	r0, #0
     e50:	d1f2      	bne.n	e38 <sem_up+0x18>
     e52:	3b03      	subs	r3, #3
     e54:	e7f0      	b.n	e38 <sem_up+0x18>
     e56:	46c0      	nop			; (mov r8, r8)
     e58:	e000ed00 	.word	0xe000ed00
     e5c:	00001749 	.word	0x00001749
     e60:	000014c1 	.word	0x000014c1

00000e64 <sem_down>:

/**
 * \brief Semaphore down, may suspend the caller thread
 */
int32_t sem_down(sem_t *sem, uint32_t timeout)
{
     e64:	b510      	push	{r4, lr}
	return xSemaphoreTake(*sem, timeout) ? ERR_NONE : ERR_TIMEOUT;
     e66:	6800      	ldr	r0, [r0, #0]
     e68:	4b04      	ldr	r3, [pc, #16]	; (e7c <sem_down+0x18>)
     e6a:	4798      	blx	r3
     e6c:	2300      	movs	r3, #0
     e6e:	2800      	cmp	r0, #0
     e70:	d001      	beq.n	e76 <sem_down+0x12>
}
     e72:	0018      	movs	r0, r3
     e74:	bd10      	pop	{r4, pc}
	return xSemaphoreTake(*sem, timeout) ? ERR_NONE : ERR_TIMEOUT;
     e76:	3b08      	subs	r3, #8
     e78:	e7fb      	b.n	e72 <sem_down+0xe>
     e7a:	46c0      	nop			; (mov r8, r8)
     e7c:	0000194d 	.word	0x0000194d

00000e80 <sem_deinit>:

/**
 * \brief Semaphore deinitialization
 */
int32_t sem_deinit(sem_t *sem)
{
     e80:	b510      	push	{r4, lr}
     e82:	0004      	movs	r4, r0
	if (*sem != NULL) {
     e84:	6800      	ldr	r0, [r0, #0]
     e86:	2800      	cmp	r0, #0
     e88:	d003      	beq.n	e92 <sem_deinit+0x12>
		vSemaphoreDelete(*sem);
     e8a:	4b03      	ldr	r3, [pc, #12]	; (e98 <sem_deinit+0x18>)
     e8c:	4798      	blx	r3
		*sem = NULL;
     e8e:	2300      	movs	r3, #0
     e90:	6023      	str	r3, [r4, #0]
	}

	return ERR_NONE;
}
     e92:	2000      	movs	r0, #0
     e94:	bd10      	pop	{r4, pc}
     e96:	46c0      	nop			; (mov r8, r8)
     e98:	00001ae5 	.word	0x00001ae5

00000e9c <vListInitialise>:
void vListInitialise(List_t *const pxList)
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
     e9c:	0003      	movs	r3, r0
     e9e:	3308      	adds	r3, #8
     ea0:	6043      	str	r3, [r0, #4]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     ea2:	2201      	movs	r2, #1
     ea4:	4252      	negs	r2, r2
     ea6:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
     ea8:	60c3      	str	r3, [r0, #12]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
     eaa:	6103      	str	r3, [r0, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
     eac:	2300      	movs	r3, #0
     eae:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList);
	listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList);
}
     eb0:	4770      	bx	lr

00000eb2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     eb2:	2300      	movs	r3, #0
     eb4:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
}
     eb6:	4770      	bx	lr

00000eb8 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
     eb8:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
     eba:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     ebc:	689a      	ldr	r2, [r3, #8]
     ebe:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     ec0:	689a      	ldr	r2, [r3, #8]
     ec2:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
     ec4:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;
     ec6:	6108      	str	r0, [r1, #16]

	(pxList->uxNumberOfItems)++;
     ec8:	6803      	ldr	r3, [r0, #0]
     eca:	3301      	adds	r3, #1
     ecc:	6003      	str	r3, [r0, #0]
}
     ece:	4770      	bx	lr

00000ed0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
     ed0:	b530      	push	{r4, r5, lr}
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     ed2:	680c      	ldr	r4, [r1, #0]
		    4) Using a queue or semaphore before it has been initialised or
		       before the scheduler has been started (are interrupts firing
		       before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
     ed4:	0002      	movs	r2, r0
     ed6:	3208      	adds	r2, #8
	if (xValueOfInsertion == portMAX_DELAY) {
     ed8:	1c63      	adds	r3, r4, #1
     eda:	d102      	bne.n	ee2 <vListInsert+0x12>
		pxIterator = pxList->xListEnd.pxPrevious;
     edc:	6902      	ldr	r2, [r0, #16]
     ede:	e004      	b.n	eea <vListInsert+0x1a>
		     pxIterator
		     = pxIterator
     ee0:	001a      	movs	r2, r3
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
     ee2:	6853      	ldr	r3, [r2, #4]
     ee4:	681d      	ldr	r5, [r3, #0]
     ee6:	42ac      	cmp	r4, r5
     ee8:	d2fa      	bcs.n	ee0 <vListInsert+0x10>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
     eea:	6853      	ldr	r3, [r2, #4]
     eec:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     eee:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious         = pxIterator;
     ef0:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext                = pxNewListItem;
     ef2:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;
     ef4:	6108      	str	r0, [r1, #16]

	(pxList->uxNumberOfItems)++;
     ef6:	6803      	ldr	r3, [r0, #0]
     ef8:	3301      	adds	r3, #1
     efa:	6003      	str	r3, [r0, #0]
}
     efc:	bd30      	pop	{r4, r5, pc}

00000efe <uxListRemove>:

UBaseType_t uxListRemove(ListItem_t *const pxItemToRemove)
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
     efe:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     f00:	6842      	ldr	r2, [r0, #4]
     f02:	6881      	ldr	r1, [r0, #8]
     f04:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     f06:	6882      	ldr	r2, [r0, #8]
     f08:	6841      	ldr	r1, [r0, #4]
     f0a:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
     f0c:	685a      	ldr	r2, [r3, #4]
     f0e:	4290      	cmp	r0, r2
     f10:	d006      	beq.n	f20 <uxListRemove+0x22>
		pxList->pxIndex = pxItemToRemove->pxPrevious;
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     f12:	2200      	movs	r2, #0
     f14:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
     f16:	681a      	ldr	r2, [r3, #0]
     f18:	3a01      	subs	r2, #1
     f1a:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
     f1c:	6818      	ldr	r0, [r3, #0]
}
     f1e:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     f20:	6882      	ldr	r2, [r0, #8]
     f22:	605a      	str	r2, [r3, #4]
     f24:	e7f5      	b.n	f12 <uxListRemove+0x14>
	...

00000f28 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError(void)
{
     f28:	b082      	sub	sp, #8
	volatile uint32_t ulDummy = 0UL;
     f2a:	2300      	movs	r3, #0
     f2c:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT(uxCriticalNesting == ~0UL);
     f2e:	4b06      	ldr	r3, [pc, #24]	; (f48 <prvTaskExitError+0x20>)
     f30:	681b      	ldr	r3, [r3, #0]
     f32:	3301      	adds	r3, #1
     f34:	d001      	beq.n	f3a <prvTaskExitError+0x12>
     f36:	b672      	cpsid	i
     f38:	e7fe      	b.n	f38 <prvTaskExitError+0x10>
	portDISABLE_INTERRUPTS();
     f3a:	b672      	cpsid	i
	while (ulDummy == 0) {
     f3c:	9b01      	ldr	r3, [sp, #4]
     f3e:	2b00      	cmp	r3, #0
     f40:	d0fc      	beq.n	f3c <prvTaskExitError+0x14>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
     f42:	b002      	add	sp, #8
     f44:	4770      	bx	lr
     f46:	46c0      	nop			; (mov r8, r8)
     f48:	20000000 	.word	0x20000000
     f4c:	00000000 	.word	0x00000000

00000f50 <vPortStartFirstTask>:
void vPortStartFirstTask(void)
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
     f50:	4a0b      	ldr	r2, [pc, #44]	; (f80 <pxCurrentTCBConst2>)
     f52:	6813      	ldr	r3, [r2, #0]
     f54:	6818      	ldr	r0, [r3, #0]
     f56:	3020      	adds	r0, #32
     f58:	f380 8809 	msr	PSP, r0
     f5c:	2002      	movs	r0, #2
     f5e:	f380 8814 	msr	CONTROL, r0
     f62:	f3bf 8f6f 	isb	sy
     f66:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
     f68:	46ae      	mov	lr, r5
     f6a:	bc08      	pop	{r3}
     f6c:	bc04      	pop	{r2}
     f6e:	b662      	cpsie	i
     f70:	4718      	bx	r3
     f72:	46c0      	nop			; (mov r8, r8)
     f74:	46c0      	nop			; (mov r8, r8)
     f76:	46c0      	nop			; (mov r8, r8)
     f78:	46c0      	nop			; (mov r8, r8)
     f7a:	46c0      	nop			; (mov r8, r8)
     f7c:	46c0      	nop			; (mov r8, r8)
     f7e:	46c0      	nop			; (mov r8, r8)

00000f80 <pxCurrentTCBConst2>:
     f80:	20000ac4 	.word	0x20000ac4

00000f84 <pxPortInitialiseStack>:
{
     f84:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
     f86:	1f03      	subs	r3, r0, #4
     f88:	2480      	movs	r4, #128	; 0x80
     f8a:	0464      	lsls	r4, r4, #17
     f8c:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = (StackType_t)pxCode; /* PC */
     f8e:	3b04      	subs	r3, #4
     f90:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
     f92:	3b04      	subs	r3, #4
     f94:	4902      	ldr	r1, [pc, #8]	; (fa0 <pxPortInitialiseStack+0x1c>)
     f96:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = (StackType_t)pvParameters;            /* R0 */
     f98:	3b14      	subs	r3, #20
     f9a:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;                                    /* R11..R4. */
     f9c:	3840      	subs	r0, #64	; 0x40
}
     f9e:	bd10      	pop	{r4, pc}
     fa0:	00000f29 	.word	0x00000f29

00000fa4 <SVCall_Handler>:
}
     fa4:	4770      	bx	lr
	...

00000fa8 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler(void)
{
     fa8:	b510      	push	{r4, lr}
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
     faa:	4b0f      	ldr	r3, [pc, #60]	; (fe8 <xPortStartScheduler+0x40>)
     fac:	6819      	ldr	r1, [r3, #0]
     fae:	22ff      	movs	r2, #255	; 0xff
     fb0:	0412      	lsls	r2, r2, #16
     fb2:	430a      	orrs	r2, r1
     fb4:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
     fb6:	6819      	ldr	r1, [r3, #0]
     fb8:	22ff      	movs	r2, #255	; 0xff
     fba:	0612      	lsls	r2, r2, #24
     fbc:	430a      	orrs	r2, r1
     fbe:	601a      	str	r2, [r3, #0]
 * frequency.
 */
void prvSetupTimerInterrupt(void)
{
	/* Stop and reset the SysTick. */
	*(portNVIC_SYSTICK_CTRL)          = 0UL;
     fc0:	4a0a      	ldr	r2, [pc, #40]	; (fec <xPortStartScheduler+0x44>)
     fc2:	2300      	movs	r3, #0
     fc4:	6013      	str	r3, [r2, #0]
	*(portNVIC_SYSTICK_CURRENT_VALUE) = 0UL;
     fc6:	490a      	ldr	r1, [pc, #40]	; (ff0 <xPortStartScheduler+0x48>)
     fc8:	600b      	str	r3, [r1, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = (configCPU_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
     fca:	480a      	ldr	r0, [pc, #40]	; (ff4 <xPortStartScheduler+0x4c>)
     fcc:	490a      	ldr	r1, [pc, #40]	; (ff8 <xPortStartScheduler+0x50>)
     fce:	6008      	str	r0, [r1, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
     fd0:	2107      	movs	r1, #7
     fd2:	6011      	str	r1, [r2, #0]
	uxCriticalNesting = 0;
     fd4:	4a09      	ldr	r2, [pc, #36]	; (ffc <xPortStartScheduler+0x54>)
     fd6:	6013      	str	r3, [r2, #0]
	vPortStartFirstTask();
     fd8:	4b09      	ldr	r3, [pc, #36]	; (1000 <xPortStartScheduler+0x58>)
     fda:	4798      	blx	r3
	vTaskSwitchContext();
     fdc:	4b09      	ldr	r3, [pc, #36]	; (1004 <xPortStartScheduler+0x5c>)
     fde:	4798      	blx	r3
	prvTaskExitError();
     fe0:	4b09      	ldr	r3, [pc, #36]	; (1008 <xPortStartScheduler+0x60>)
     fe2:	4798      	blx	r3
}
     fe4:	2000      	movs	r0, #0
     fe6:	bd10      	pop	{r4, pc}
     fe8:	e000ed20 	.word	0xe000ed20
     fec:	e000e010 	.word	0xe000e010
     ff0:	e000e018 	.word	0xe000e018
     ff4:	000003e7 	.word	0x000003e7
     ff8:	e000e014 	.word	0xe000e014
     ffc:	20000000 	.word	0x20000000
    1000:	00000f51 	.word	0x00000f51
    1004:	000021a9 	.word	0x000021a9
    1008:	00000f29 	.word	0x00000f29

0000100c <vPortYield>:
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
    100c:	2280      	movs	r2, #128	; 0x80
    100e:	0552      	lsls	r2, r2, #21
    1010:	4b03      	ldr	r3, [pc, #12]	; (1020 <vPortYield+0x14>)
    1012:	601a      	str	r2, [r3, #0]
	__asm volatile("dsb" ::: "memory");
    1014:	f3bf 8f4f 	dsb	sy
	__asm volatile("isb");
    1018:	f3bf 8f6f 	isb	sy
}
    101c:	4770      	bx	lr
    101e:	46c0      	nop			; (mov r8, r8)
    1020:	e000ed04 	.word	0xe000ed04

00001024 <vPortEnterCritical>:
	portDISABLE_INTERRUPTS();
    1024:	b672      	cpsid	i
	uxCriticalNesting++;
    1026:	4a04      	ldr	r2, [pc, #16]	; (1038 <vPortEnterCritical+0x14>)
    1028:	6813      	ldr	r3, [r2, #0]
    102a:	3301      	adds	r3, #1
    102c:	6013      	str	r3, [r2, #0]
	__asm volatile("dsb" ::: "memory");
    102e:	f3bf 8f4f 	dsb	sy
	__asm volatile("isb");
    1032:	f3bf 8f6f 	isb	sy
}
    1036:	4770      	bx	lr
    1038:	20000000 	.word	0x20000000

0000103c <vPortExitCritical>:
	configASSERT(uxCriticalNesting);
    103c:	4b06      	ldr	r3, [pc, #24]	; (1058 <vPortExitCritical+0x1c>)
    103e:	681b      	ldr	r3, [r3, #0]
    1040:	2b00      	cmp	r3, #0
    1042:	d101      	bne.n	1048 <vPortExitCritical+0xc>
    1044:	b672      	cpsid	i
    1046:	e7fe      	b.n	1046 <vPortExitCritical+0xa>
	uxCriticalNesting--;
    1048:	3b01      	subs	r3, #1
    104a:	4a03      	ldr	r2, [pc, #12]	; (1058 <vPortExitCritical+0x1c>)
    104c:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
    104e:	2b00      	cmp	r3, #0
    1050:	d100      	bne.n	1054 <vPortExitCritical+0x18>
		portENABLE_INTERRUPTS();
    1052:	b662      	cpsie	i
}
    1054:	4770      	bx	lr
    1056:	46c0      	nop			; (mov r8, r8)
    1058:	20000000 	.word	0x20000000

0000105c <ulSetInterruptMaskFromISR>:
	__asm volatile(" mrs r0, PRIMASK	\n"
    105c:	f3ef 8010 	mrs	r0, PRIMASK
    1060:	b672      	cpsid	i
    1062:	4770      	bx	lr

00001064 <vClearInterruptMaskFromISR>:
	__asm volatile(" msr PRIMASK, r0	\n"
    1064:	f380 8810 	msr	PRIMASK, r0
    1068:	4770      	bx	lr
    106a:	0000      	movs	r0, r0
    106c:	0000      	movs	r0, r0
	...

00001070 <PendSV_Handler>:
	__asm volatile(
    1070:	f3ef 8009 	mrs	r0, PSP
    1074:	4b0e      	ldr	r3, [pc, #56]	; (10b0 <pxCurrentTCBConst>)
    1076:	681a      	ldr	r2, [r3, #0]
    1078:	3820      	subs	r0, #32
    107a:	6010      	str	r0, [r2, #0]
    107c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    107e:	4644      	mov	r4, r8
    1080:	464d      	mov	r5, r9
    1082:	4656      	mov	r6, sl
    1084:	465f      	mov	r7, fp
    1086:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    1088:	b508      	push	{r3, lr}
    108a:	b672      	cpsid	i
    108c:	f001 f88c 	bl	21a8 <vTaskSwitchContext>
    1090:	b662      	cpsie	i
    1092:	bc0c      	pop	{r2, r3}
    1094:	6811      	ldr	r1, [r2, #0]
    1096:	6808      	ldr	r0, [r1, #0]
    1098:	3010      	adds	r0, #16
    109a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    109c:	46a0      	mov	r8, r4
    109e:	46a9      	mov	r9, r5
    10a0:	46b2      	mov	sl, r6
    10a2:	46bb      	mov	fp, r7
    10a4:	f380 8809 	msr	PSP, r0
    10a8:	3820      	subs	r0, #32
    10aa:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    10ac:	4718      	bx	r3
    10ae:	46c0      	nop			; (mov r8, r8)

000010b0 <pxCurrentTCBConst>:
    10b0:	20000ac4 	.word	0x20000ac4

000010b4 <SysTick_Handler>:
{
    10b4:	b510      	push	{r4, lr}
	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
    10b6:	4b07      	ldr	r3, [pc, #28]	; (10d4 <SysTick_Handler+0x20>)
    10b8:	4798      	blx	r3
    10ba:	0004      	movs	r4, r0
		if (xTaskIncrementTick() != pdFALSE) {
    10bc:	4b06      	ldr	r3, [pc, #24]	; (10d8 <SysTick_Handler+0x24>)
    10be:	4798      	blx	r3
    10c0:	2800      	cmp	r0, #0
    10c2:	d003      	beq.n	10cc <SysTick_Handler+0x18>
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
    10c4:	2280      	movs	r2, #128	; 0x80
    10c6:	0552      	lsls	r2, r2, #21
    10c8:	4b04      	ldr	r3, [pc, #16]	; (10dc <SysTick_Handler+0x28>)
    10ca:	601a      	str	r2, [r3, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR(ulPreviousMask);
    10cc:	0020      	movs	r0, r4
    10ce:	4b04      	ldr	r3, [pc, #16]	; (10e0 <SysTick_Handler+0x2c>)
    10d0:	4798      	blx	r3
}
    10d2:	bd10      	pop	{r4, pc}
    10d4:	0000105d 	.word	0x0000105d
    10d8:	00001f6d 	.word	0x00001f6d
    10dc:	e000ed04 	.word	0xe000ed04
    10e0:	00001065 	.word	0x00001065

000010e4 <pvPortMalloc>:
		pxIterator->pxNextFreeBlock      = pxBlockToInsert;                                                            \
	}
/*-----------------------------------------------------------*/

void *pvPortMalloc(size_t xWantedSize)
{
    10e4:	b570      	push	{r4, r5, r6, lr}
    10e6:	0004      	movs	r4, r0
	BlockLink_t *     pxBlock, *pxPreviousBlock, *pxNewBlockLink;
	static BaseType_t xHeapHasBeenInitialised = pdFALSE;
	void *            pvReturn                = NULL;

	vTaskSuspendAll();
    10e8:	4b2a      	ldr	r3, [pc, #168]	; (1194 <pvPortMalloc+0xb0>)
    10ea:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if (xHeapHasBeenInitialised == pdFALSE) {
    10ec:	4b2a      	ldr	r3, [pc, #168]	; (1198 <pvPortMalloc+0xb4>)
    10ee:	689b      	ldr	r3, [r3, #8]
    10f0:	2b00      	cmp	r3, #0
    10f2:	d011      	beq.n	1118 <pvPortMalloc+0x34>
	void *            pvReturn                = NULL;
    10f4:	2500      	movs	r5, #0
			xHeapHasBeenInitialised = pdTRUE;
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if (xWantedSize > 0) {
    10f6:	2c00      	cmp	r4, #0
    10f8:	d046      	beq.n	1188 <pvPortMalloc+0xa4>
			xWantedSize += heapSTRUCT_SIZE;
    10fa:	0020      	movs	r0, r4
    10fc:	3008      	adds	r0, #8

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if ((xWantedSize & portBYTE_ALIGNMENT_MASK) != 0) {
    10fe:	0743      	lsls	r3, r0, #29
    1100:	d002      	beq.n	1108 <pvPortMalloc+0x24>
				/* Byte alignment required. */
				xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
    1102:	2307      	movs	r3, #7
    1104:	4398      	bics	r0, r3
    1106:	3008      	adds	r0, #8
			}
		}

		if ((xWantedSize > 0) && (xWantedSize < configADJUSTED_HEAP_SIZE)) {
    1108:	1e43      	subs	r3, r0, #1
    110a:	4a24      	ldr	r2, [pc, #144]	; (119c <pvPortMalloc+0xb8>)
	void *            pvReturn                = NULL;
    110c:	2500      	movs	r5, #0
		if ((xWantedSize > 0) && (xWantedSize < configADJUSTED_HEAP_SIZE)) {
    110e:	4293      	cmp	r3, r2
    1110:	d83a      	bhi.n	1188 <pvPortMalloc+0xa4>
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock         = xStart.pxNextFreeBlock;
    1112:	4921      	ldr	r1, [pc, #132]	; (1198 <pvPortMalloc+0xb4>)
    1114:	680b      	ldr	r3, [r1, #0]
			while ((pxBlock->xBlockSize < xWantedSize) && (pxBlock->pxNextFreeBlock != NULL)) {
    1116:	e013      	b.n	1140 <pvPortMalloc+0x5c>
{
	BlockLink_t *pxFirstFreeBlock;
	uint8_t *    pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
    1118:	491f      	ldr	r1, [pc, #124]	; (1198 <pvPortMalloc+0xb4>)
    111a:	000b      	movs	r3, r1
    111c:	3314      	adds	r3, #20
	                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
    111e:	2207      	movs	r2, #7
    1120:	4393      	bics	r3, r2

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = (void *)pucAlignedHeap;
    1122:	600b      	str	r3, [r1, #0]
	xStart.xBlockSize      = (size_t)0;
    1124:	2500      	movs	r5, #0
    1126:	604d      	str	r5, [r1, #4]

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize      = configADJUSTED_HEAP_SIZE;
    1128:	4a1d      	ldr	r2, [pc, #116]	; (11a0 <pvPortMalloc+0xbc>)
    112a:	481e      	ldr	r0, [pc, #120]	; (11a4 <pvPortMalloc+0xc0>)
    112c:	6710      	str	r0, [r2, #112]	; 0x70
	xEnd.pxNextFreeBlock = NULL;
    112e:	66d5      	str	r5, [r2, #108]	; 0x6c

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock                  = (void *)pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize      = configADJUSTED_HEAP_SIZE;
    1130:	6058      	str	r0, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    1132:	326c      	adds	r2, #108	; 0x6c
    1134:	601a      	str	r2, [r3, #0]
			xHeapHasBeenInitialised = pdTRUE;
    1136:	2301      	movs	r3, #1
    1138:	608b      	str	r3, [r1, #8]
    113a:	e7db      	b.n	10f4 <pvPortMalloc+0x10>
    113c:	0019      	movs	r1, r3
				pxBlock         = pxBlock->pxNextFreeBlock;
    113e:	0013      	movs	r3, r2
			while ((pxBlock->xBlockSize < xWantedSize) && (pxBlock->pxNextFreeBlock != NULL)) {
    1140:	685a      	ldr	r2, [r3, #4]
    1142:	4290      	cmp	r0, r2
    1144:	d902      	bls.n	114c <pvPortMalloc+0x68>
    1146:	681a      	ldr	r2, [r3, #0]
    1148:	2a00      	cmp	r2, #0
    114a:	d1f7      	bne.n	113c <pvPortMalloc+0x58>
			if (pxBlock != &xEnd) {
    114c:	4a14      	ldr	r2, [pc, #80]	; (11a0 <pvPortMalloc+0xbc>)
    114e:	326c      	adds	r2, #108	; 0x6c
    1150:	4293      	cmp	r3, r2
    1152:	d01d      	beq.n	1190 <pvPortMalloc+0xac>
				pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + heapSTRUCT_SIZE);
    1154:	680d      	ldr	r5, [r1, #0]
    1156:	3508      	adds	r5, #8
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1158:	681a      	ldr	r2, [r3, #0]
    115a:	600a      	str	r2, [r1, #0]
				if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
    115c:	685a      	ldr	r2, [r3, #4]
    115e:	1a12      	subs	r2, r2, r0
    1160:	2a10      	cmp	r2, #16
    1162:	d90c      	bls.n	117e <pvPortMalloc+0x9a>
					pxNewBlockLink = (void *)(((uint8_t *)pxBlock) + xWantedSize);
    1164:	181c      	adds	r4, r3, r0
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1166:	6062      	str	r2, [r4, #4]
					pxBlock->xBlockSize        = xWantedSize;
    1168:	6058      	str	r0, [r3, #4]
					prvInsertBlockIntoFreeList((pxNewBlockLink));
    116a:	6860      	ldr	r0, [r4, #4]
    116c:	490a      	ldr	r1, [pc, #40]	; (1198 <pvPortMalloc+0xb4>)
    116e:	e000      	b.n	1172 <pvPortMalloc+0x8e>
    1170:	0011      	movs	r1, r2
    1172:	680a      	ldr	r2, [r1, #0]
    1174:	6856      	ldr	r6, [r2, #4]
    1176:	42b0      	cmp	r0, r6
    1178:	d8fa      	bhi.n	1170 <pvPortMalloc+0x8c>
    117a:	6022      	str	r2, [r4, #0]
    117c:	600c      	str	r4, [r1, #0]
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    117e:	4a0a      	ldr	r2, [pc, #40]	; (11a8 <pvPortMalloc+0xc4>)
    1180:	685b      	ldr	r3, [r3, #4]
    1182:	6811      	ldr	r1, [r2, #0]
    1184:	1acb      	subs	r3, r1, r3
    1186:	6013      	str	r3, [r2, #0]
	(void)xTaskResumeAll();
    1188:	4b08      	ldr	r3, [pc, #32]	; (11ac <pvPortMalloc+0xc8>)
    118a:	4798      	blx	r3
}
    118c:	0028      	movs	r0, r5
    118e:	bd70      	pop	{r4, r5, r6, pc}
	void *            pvReturn                = NULL;
    1190:	2500      	movs	r5, #0
    1192:	e7f9      	b.n	1188 <pvPortMalloc+0xa4>
    1194:	00001f45 	.word	0x00001f45
    1198:	200000b8 	.word	0x200000b8
    119c:	00000956 	.word	0x00000956
    11a0:	200009b8 	.word	0x200009b8
    11a4:	00000958 	.word	0x00000958
    11a8:	20000004 	.word	0x20000004
    11ac:	00002079 	.word	0x00002079

000011b0 <vPortFree>:
{
    11b0:	b570      	push	{r4, r5, r6, lr}
    11b2:	1e04      	subs	r4, r0, #0
	if (pv != NULL) {
    11b4:	d016      	beq.n	11e4 <vPortFree+0x34>
		puc -= heapSTRUCT_SIZE;
    11b6:	0005      	movs	r5, r0
    11b8:	3d08      	subs	r5, #8
		vTaskSuspendAll();
    11ba:	4b0b      	ldr	r3, [pc, #44]	; (11e8 <vPortFree+0x38>)
    11bc:	4798      	blx	r3
			prvInsertBlockIntoFreeList(((BlockLink_t *)pxLink));
    11be:	6869      	ldr	r1, [r5, #4]
    11c0:	4a0a      	ldr	r2, [pc, #40]	; (11ec <vPortFree+0x3c>)
    11c2:	e000      	b.n	11c6 <vPortFree+0x16>
    11c4:	001a      	movs	r2, r3
    11c6:	6813      	ldr	r3, [r2, #0]
    11c8:	6858      	ldr	r0, [r3, #4]
    11ca:	4281      	cmp	r1, r0
    11cc:	d8fa      	bhi.n	11c4 <vPortFree+0x14>
    11ce:	3c08      	subs	r4, #8
    11d0:	6023      	str	r3, [r4, #0]
    11d2:	6015      	str	r5, [r2, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
    11d4:	4a06      	ldr	r2, [pc, #24]	; (11f0 <vPortFree+0x40>)
    11d6:	6863      	ldr	r3, [r4, #4]
    11d8:	6811      	ldr	r1, [r2, #0]
    11da:	468c      	mov	ip, r1
    11dc:	4463      	add	r3, ip
    11de:	6013      	str	r3, [r2, #0]
		(void)xTaskResumeAll();
    11e0:	4b04      	ldr	r3, [pc, #16]	; (11f4 <vPortFree+0x44>)
    11e2:	4798      	blx	r3
}
    11e4:	bd70      	pop	{r4, r5, r6, pc}
    11e6:	46c0      	nop			; (mov r8, r8)
    11e8:	00001f45 	.word	0x00001f45
    11ec:	200000b8 	.word	0x200000b8
    11f0:	20000004 	.word	0x20000004
    11f4:	00002079 	.word	0x00002079

000011f8 <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty(const Queue_t *pxQueue)
{
    11f8:	b510      	push	{r4, lr}
    11fa:	0004      	movs	r4, r0
	BaseType_t xReturn;

	taskENTER_CRITICAL();
    11fc:	4b03      	ldr	r3, [pc, #12]	; (120c <prvIsQueueEmpty+0x14>)
    11fe:	4798      	blx	r3
	{
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
    1200:	6ba4      	ldr	r4, [r4, #56]	; 0x38
			xReturn = pdTRUE;
		} else {
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1202:	4b03      	ldr	r3, [pc, #12]	; (1210 <prvIsQueueEmpty+0x18>)
    1204:	4798      	blx	r3
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
    1206:	4260      	negs	r0, r4
    1208:	4160      	adcs	r0, r4

	return xReturn;
}
    120a:	bd10      	pop	{r4, pc}
    120c:	00001025 	.word	0x00001025
    1210:	0000103d 	.word	0x0000103d

00001214 <prvCopyDataToQueue>:
{
    1214:	b570      	push	{r4, r5, r6, lr}
    1216:	0004      	movs	r4, r0
    1218:	0016      	movs	r6, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    121a:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
    121c:	6c02      	ldr	r2, [r0, #64]	; 0x40
    121e:	2a00      	cmp	r2, #0
    1220:	d10b      	bne.n	123a <prvCopyDataToQueue+0x26>
	BaseType_t  xReturn = pdFALSE;
    1222:	2000      	movs	r0, #0
			if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    1224:	6823      	ldr	r3, [r4, #0]
    1226:	4283      	cmp	r3, r0
    1228:	d104      	bne.n	1234 <prvCopyDataToQueue+0x20>
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
    122a:	6860      	ldr	r0, [r4, #4]
    122c:	4b16      	ldr	r3, [pc, #88]	; (1288 <prvCopyDataToQueue+0x74>)
    122e:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
    1230:	2300      	movs	r3, #0
    1232:	6063      	str	r3, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + (UBaseType_t)1;
    1234:	3501      	adds	r5, #1
    1236:	63a5      	str	r5, [r4, #56]	; 0x38
}
    1238:	bd70      	pop	{r4, r5, r6, pc}
	} else if (xPosition == queueSEND_TO_BACK) {
    123a:	2e00      	cmp	r6, #0
    123c:	d10e      	bne.n	125c <prvCopyDataToQueue+0x48>
		(void)memcpy((void *)pxQueue->pcWriteTo,
    123e:	6880      	ldr	r0, [r0, #8]
    1240:	4b12      	ldr	r3, [pc, #72]	; (128c <prvCopyDataToQueue+0x78>)
    1242:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1244:	68a3      	ldr	r3, [r4, #8]
    1246:	6c22      	ldr	r2, [r4, #64]	; 0x40
    1248:	4694      	mov	ip, r2
    124a:	4463      	add	r3, ip
    124c:	60a3      	str	r3, [r4, #8]
	BaseType_t  xReturn = pdFALSE;
    124e:	2000      	movs	r0, #0
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
    1250:	6862      	ldr	r2, [r4, #4]
    1252:	4293      	cmp	r3, r2
    1254:	d3ee      	bcc.n	1234 <prvCopyDataToQueue+0x20>
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1256:	6823      	ldr	r3, [r4, #0]
    1258:	60a3      	str	r3, [r4, #8]
    125a:	e7eb      	b.n	1234 <prvCopyDataToQueue+0x20>
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
    125c:	68c0      	ldr	r0, [r0, #12]
    125e:	4b0b      	ldr	r3, [pc, #44]	; (128c <prvCopyDataToQueue+0x78>)
    1260:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1262:	6c23      	ldr	r3, [r4, #64]	; 0x40
    1264:	425b      	negs	r3, r3
    1266:	68e2      	ldr	r2, [r4, #12]
    1268:	18d2      	adds	r2, r2, r3
    126a:	60e2      	str	r2, [r4, #12]
		if (pxQueue->u.pcReadFrom
    126c:	6821      	ldr	r1, [r4, #0]
    126e:	428a      	cmp	r2, r1
    1270:	d203      	bcs.n	127a <prvCopyDataToQueue+0x66>
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
    1272:	6862      	ldr	r2, [r4, #4]
    1274:	4694      	mov	ip, r2
    1276:	4463      	add	r3, ip
    1278:	60e3      	str	r3, [r4, #12]
	BaseType_t  xReturn = pdFALSE;
    127a:	2000      	movs	r0, #0
		if (xPosition == queueOVERWRITE) {
    127c:	2e02      	cmp	r6, #2
    127e:	d1d9      	bne.n	1234 <prvCopyDataToQueue+0x20>
			if (uxMessagesWaiting > (UBaseType_t)0) {
    1280:	4285      	cmp	r5, r0
    1282:	d0d7      	beq.n	1234 <prvCopyDataToQueue+0x20>
				--uxMessagesWaiting;
    1284:	3d01      	subs	r5, #1
    1286:	e7d5      	b.n	1234 <prvCopyDataToQueue+0x20>
    1288:	000026c1 	.word	0x000026c1
    128c:	00002cc5 	.word	0x00002cc5

00001290 <prvNotifyQueueSetContainer>:
	/*-----------------------------------------------------------*/

#if (configUSE_QUEUE_SETS == 1)

static BaseType_t prvNotifyQueueSetContainer(const Queue_t *const pxQueue, const BaseType_t xCopyPosition)
{
    1290:	b570      	push	{r4, r5, r6, lr}
    1292:	b082      	sub	sp, #8
    1294:	9001      	str	r0, [sp, #4]
    1296:	000a      	movs	r2, r1
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
    1298:	6c84      	ldr	r4, [r0, #72]	; 0x48
	BaseType_t xReturn             = pdFALSE;

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
    129a:	2c00      	cmp	r4, #0
    129c:	d005      	beq.n	12aa <prvNotifyQueueSetContainer+0x1a>
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
    129e:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    12a0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    12a2:	4299      	cmp	r1, r3
    12a4:	d303      	bcc.n	12ae <prvNotifyQueueSetContainer+0x1e>
    12a6:	b672      	cpsid	i
    12a8:	e7fe      	b.n	12a8 <prvNotifyQueueSetContainer+0x18>
	configASSERT(pxQueueSetContainer);
    12aa:	b672      	cpsid	i
    12ac:	e7fe      	b.n	12ac <prvNotifyQueueSetContainer+0x1c>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
    12ae:	6ba1      	ldr	r1, [r4, #56]	; 0x38
	BaseType_t xReturn             = pdFALSE;
    12b0:	2600      	movs	r6, #0
	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
    12b2:	428b      	cmp	r3, r1
    12b4:	d802      	bhi.n	12bc <prvNotifyQueueSetContainer+0x2c>
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    12b6:	0030      	movs	r0, r6
    12b8:	b002      	add	sp, #8
    12ba:	bd70      	pop	{r4, r5, r6, pc}
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    12bc:	2345      	movs	r3, #69	; 0x45
    12be:	5ce5      	ldrb	r5, [r4, r3]
    12c0:	b26d      	sxtb	r5, r5
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
    12c2:	a901      	add	r1, sp, #4
    12c4:	0020      	movs	r0, r4
    12c6:	4b0a      	ldr	r3, [pc, #40]	; (12f0 <prvNotifyQueueSetContainer+0x60>)
    12c8:	4798      	blx	r3
    12ca:	0006      	movs	r6, r0
		if (cTxLock == queueUNLOCKED) {
    12cc:	1c6b      	adds	r3, r5, #1
    12ce:	d10a      	bne.n	12e6 <prvNotifyQueueSetContainer+0x56>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
    12d0:	6a63      	ldr	r3, [r4, #36]	; 0x24
    12d2:	2b00      	cmp	r3, #0
    12d4:	d0ef      	beq.n	12b6 <prvNotifyQueueSetContainer+0x26>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
    12d6:	0020      	movs	r0, r4
    12d8:	3024      	adds	r0, #36	; 0x24
    12da:	4b06      	ldr	r3, [pc, #24]	; (12f4 <prvNotifyQueueSetContainer+0x64>)
    12dc:	4798      	blx	r3
    12de:	2800      	cmp	r0, #0
    12e0:	d0e9      	beq.n	12b6 <prvNotifyQueueSetContainer+0x26>
					xReturn = pdTRUE;
    12e2:	2601      	movs	r6, #1
    12e4:	e7e7      	b.n	12b6 <prvNotifyQueueSetContainer+0x26>
			pxQueueSetContainer->cTxLock = (int8_t)(cTxLock + 1);
    12e6:	3501      	adds	r5, #1
    12e8:	b26d      	sxtb	r5, r5
    12ea:	2345      	movs	r3, #69	; 0x45
    12ec:	54e5      	strb	r5, [r4, r3]
    12ee:	e7e2      	b.n	12b6 <prvNotifyQueueSetContainer+0x26>
    12f0:	00001215 	.word	0x00001215
    12f4:	00002355 	.word	0x00002355

000012f8 <prvCopyDataFromQueue>:
{
    12f8:	b510      	push	{r4, lr}
    12fa:	000c      	movs	r4, r1
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
    12fc:	6c02      	ldr	r2, [r0, #64]	; 0x40
    12fe:	2a00      	cmp	r2, #0
    1300:	d00b      	beq.n	131a <prvCopyDataFromQueue+0x22>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1302:	68c3      	ldr	r3, [r0, #12]
    1304:	189b      	adds	r3, r3, r2
    1306:	60c3      	str	r3, [r0, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
    1308:	6841      	ldr	r1, [r0, #4]
    130a:	428b      	cmp	r3, r1
    130c:	d301      	bcc.n	1312 <prvCopyDataFromQueue+0x1a>
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    130e:	6803      	ldr	r3, [r0, #0]
    1310:	60c3      	str	r3, [r0, #12]
		(void)memcpy((void *)pvBuffer,
    1312:	68c1      	ldr	r1, [r0, #12]
    1314:	0020      	movs	r0, r4
    1316:	4b01      	ldr	r3, [pc, #4]	; (131c <prvCopyDataFromQueue+0x24>)
    1318:	4798      	blx	r3
}
    131a:	bd10      	pop	{r4, pc}
    131c:	00002cc5 	.word	0x00002cc5

00001320 <prvUnlockQueue>:
{
    1320:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1322:	0007      	movs	r7, r0
	taskENTER_CRITICAL();
    1324:	4b25      	ldr	r3, [pc, #148]	; (13bc <prvUnlockQueue+0x9c>)
    1326:	4798      	blx	r3
		int8_t cTxLock = pxQueue->cTxLock;
    1328:	2345      	movs	r3, #69	; 0x45
    132a:	5cfc      	ldrb	r4, [r7, r3]
    132c:	b264      	sxtb	r4, r4
		while (cTxLock > queueLOCKED_UNMODIFIED) {
    132e:	2c00      	cmp	r4, #0
    1330:	dd1c      	ble.n	136c <prvUnlockQueue+0x4c>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    1332:	4e23      	ldr	r6, [pc, #140]	; (13c0 <prvUnlockQueue+0xa0>)
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    1334:	4d23      	ldr	r5, [pc, #140]	; (13c4 <prvUnlockQueue+0xa4>)
    1336:	e00b      	b.n	1350 <prvUnlockQueue+0x30>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    1338:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    133a:	2b00      	cmp	r3, #0
    133c:	d016      	beq.n	136c <prvUnlockQueue+0x4c>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    133e:	0038      	movs	r0, r7
    1340:	3024      	adds	r0, #36	; 0x24
    1342:	47a8      	blx	r5
    1344:	2800      	cmp	r0, #0
    1346:	d10e      	bne.n	1366 <prvUnlockQueue+0x46>
    1348:	3c01      	subs	r4, #1
    134a:	b264      	sxtb	r4, r4
		while (cTxLock > queueLOCKED_UNMODIFIED) {
    134c:	2c00      	cmp	r4, #0
    134e:	d00d      	beq.n	136c <prvUnlockQueue+0x4c>
				if (pxQueue->pxQueueSetContainer != NULL) {
    1350:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    1352:	2b00      	cmp	r3, #0
    1354:	d0f0      	beq.n	1338 <prvUnlockQueue+0x18>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    1356:	2100      	movs	r1, #0
    1358:	0038      	movs	r0, r7
    135a:	47b0      	blx	r6
    135c:	2800      	cmp	r0, #0
    135e:	d0f3      	beq.n	1348 <prvUnlockQueue+0x28>
						vTaskMissedYield();
    1360:	4b19      	ldr	r3, [pc, #100]	; (13c8 <prvUnlockQueue+0xa8>)
    1362:	4798      	blx	r3
    1364:	e7f0      	b.n	1348 <prvUnlockQueue+0x28>
							vTaskMissedYield();
    1366:	4b18      	ldr	r3, [pc, #96]	; (13c8 <prvUnlockQueue+0xa8>)
    1368:	4798      	blx	r3
    136a:	e7ed      	b.n	1348 <prvUnlockQueue+0x28>
		pxQueue->cTxLock = queueUNLOCKED;
    136c:	22ff      	movs	r2, #255	; 0xff
    136e:	2345      	movs	r3, #69	; 0x45
    1370:	54fa      	strb	r2, [r7, r3]
	taskEXIT_CRITICAL();
    1372:	4b16      	ldr	r3, [pc, #88]	; (13cc <prvUnlockQueue+0xac>)
    1374:	4798      	blx	r3
	taskENTER_CRITICAL();
    1376:	4b11      	ldr	r3, [pc, #68]	; (13bc <prvUnlockQueue+0x9c>)
    1378:	4798      	blx	r3
		int8_t cRxLock = pxQueue->cRxLock;
    137a:	2344      	movs	r3, #68	; 0x44
    137c:	5cfc      	ldrb	r4, [r7, r3]
    137e:	b264      	sxtb	r4, r4
		while (cRxLock > queueLOCKED_UNMODIFIED) {
    1380:	2c00      	cmp	r4, #0
    1382:	dd14      	ble.n	13ae <prvUnlockQueue+0x8e>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    1384:	693b      	ldr	r3, [r7, #16]
    1386:	2b00      	cmp	r3, #0
    1388:	d011      	beq.n	13ae <prvUnlockQueue+0x8e>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    138a:	003d      	movs	r5, r7
    138c:	3510      	adds	r5, #16
    138e:	4e0d      	ldr	r6, [pc, #52]	; (13c4 <prvUnlockQueue+0xa4>)
    1390:	e006      	b.n	13a0 <prvUnlockQueue+0x80>
    1392:	3c01      	subs	r4, #1
    1394:	b264      	sxtb	r4, r4
		while (cRxLock > queueLOCKED_UNMODIFIED) {
    1396:	2c00      	cmp	r4, #0
    1398:	d009      	beq.n	13ae <prvUnlockQueue+0x8e>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    139a:	693b      	ldr	r3, [r7, #16]
    139c:	2b00      	cmp	r3, #0
    139e:	d006      	beq.n	13ae <prvUnlockQueue+0x8e>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    13a0:	0028      	movs	r0, r5
    13a2:	47b0      	blx	r6
    13a4:	2800      	cmp	r0, #0
    13a6:	d0f4      	beq.n	1392 <prvUnlockQueue+0x72>
					vTaskMissedYield();
    13a8:	4b07      	ldr	r3, [pc, #28]	; (13c8 <prvUnlockQueue+0xa8>)
    13aa:	4798      	blx	r3
    13ac:	e7f1      	b.n	1392 <prvUnlockQueue+0x72>
		pxQueue->cRxLock = queueUNLOCKED;
    13ae:	22ff      	movs	r2, #255	; 0xff
    13b0:	2344      	movs	r3, #68	; 0x44
    13b2:	54fa      	strb	r2, [r7, r3]
	taskEXIT_CRITICAL();
    13b4:	4b05      	ldr	r3, [pc, #20]	; (13cc <prvUnlockQueue+0xac>)
    13b6:	4798      	blx	r3
}
    13b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    13ba:	46c0      	nop			; (mov r8, r8)
    13bc:	00001025 	.word	0x00001025
    13c0:	00001291 	.word	0x00001291
    13c4:	00002355 	.word	0x00002355
    13c8:	0000244d 	.word	0x0000244d
    13cc:	0000103d 	.word	0x0000103d

000013d0 <xQueueGenericReset>:
{
    13d0:	b570      	push	{r4, r5, r6, lr}
    13d2:	0004      	movs	r4, r0
    13d4:	000d      	movs	r5, r1
	configASSERT(pxQueue);
    13d6:	2800      	cmp	r0, #0
    13d8:	d021      	beq.n	141e <xQueueGenericReset+0x4e>
	taskENTER_CRITICAL();
    13da:	4b17      	ldr	r3, [pc, #92]	; (1438 <xQueueGenericReset+0x68>)
    13dc:	4798      	blx	r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    13de:	6822      	ldr	r2, [r4, #0]
    13e0:	6c21      	ldr	r1, [r4, #64]	; 0x40
    13e2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    13e4:	434b      	muls	r3, r1
    13e6:	18d0      	adds	r0, r2, r3
    13e8:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
    13ea:	2000      	movs	r0, #0
    13ec:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo         = pxQueue->pcHead;
    13ee:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
    13f0:	1a5b      	subs	r3, r3, r1
    13f2:	18d3      	adds	r3, r2, r3
    13f4:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock           = queueUNLOCKED;
    13f6:	23ff      	movs	r3, #255	; 0xff
    13f8:	2244      	movs	r2, #68	; 0x44
    13fa:	54a3      	strb	r3, [r4, r2]
		pxQueue->cTxLock           = queueUNLOCKED;
    13fc:	3201      	adds	r2, #1
    13fe:	54a3      	strb	r3, [r4, r2]
		if (xNewQueue == pdFALSE) {
    1400:	2d00      	cmp	r5, #0
    1402:	d111      	bne.n	1428 <xQueueGenericReset+0x58>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    1404:	6923      	ldr	r3, [r4, #16]
    1406:	2b00      	cmp	r3, #0
    1408:	d005      	beq.n	1416 <xQueueGenericReset+0x46>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    140a:	0020      	movs	r0, r4
    140c:	3010      	adds	r0, #16
    140e:	4b0b      	ldr	r3, [pc, #44]	; (143c <xQueueGenericReset+0x6c>)
    1410:	4798      	blx	r3
    1412:	2800      	cmp	r0, #0
    1414:	d105      	bne.n	1422 <xQueueGenericReset+0x52>
	taskEXIT_CRITICAL();
    1416:	4b0a      	ldr	r3, [pc, #40]	; (1440 <xQueueGenericReset+0x70>)
    1418:	4798      	blx	r3
}
    141a:	2001      	movs	r0, #1
    141c:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(pxQueue);
    141e:	b672      	cpsid	i
    1420:	e7fe      	b.n	1420 <xQueueGenericReset+0x50>
					queueYIELD_IF_USING_PREEMPTION();
    1422:	4b08      	ldr	r3, [pc, #32]	; (1444 <xQueueGenericReset+0x74>)
    1424:	4798      	blx	r3
    1426:	e7f6      	b.n	1416 <xQueueGenericReset+0x46>
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
    1428:	0020      	movs	r0, r4
    142a:	3010      	adds	r0, #16
    142c:	4d06      	ldr	r5, [pc, #24]	; (1448 <xQueueGenericReset+0x78>)
    142e:	47a8      	blx	r5
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
    1430:	0020      	movs	r0, r4
    1432:	3024      	adds	r0, #36	; 0x24
    1434:	47a8      	blx	r5
    1436:	e7ee      	b.n	1416 <xQueueGenericReset+0x46>
    1438:	00001025 	.word	0x00001025
    143c:	00002355 	.word	0x00002355
    1440:	0000103d 	.word	0x0000103d
    1444:	0000100d 	.word	0x0000100d
    1448:	00000e9d 	.word	0x00000e9d

0000144c <xQueueGenericCreate>:
{
    144c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    144e:	0006      	movs	r6, r0
    1450:	000d      	movs	r5, r1
    1452:	0017      	movs	r7, r2
	configASSERT(uxQueueLength > (UBaseType_t)0);
    1454:	2800      	cmp	r0, #0
    1456:	d101      	bne.n	145c <xQueueGenericCreate+0x10>
    1458:	b672      	cpsid	i
    145a:	e7fe      	b.n	145a <xQueueGenericCreate+0xe>
		xQueueSizeInBytes = (size_t)(
    145c:	0008      	movs	r0, r1
    145e:	4370      	muls	r0, r6
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
    1460:	3054      	adds	r0, #84	; 0x54
    1462:	4b0b      	ldr	r3, [pc, #44]	; (1490 <xQueueGenericCreate+0x44>)
    1464:	4798      	blx	r3
    1466:	1e04      	subs	r4, r0, #0
	if (pxNewQueue != NULL) {
    1468:	d010      	beq.n	148c <xQueueGenericCreate+0x40>
	if (uxItemSize == (UBaseType_t)0) {
    146a:	2d00      	cmp	r5, #0
    146c:	d003      	beq.n	1476 <xQueueGenericCreate+0x2a>
		pucQueueStorage = ((uint8_t *)pxNewQueue) + sizeof(Queue_t);
    146e:	0003      	movs	r3, r0
    1470:	3354      	adds	r3, #84	; 0x54
		pxNewQueue->pcHead = (int8_t *)pucQueueStorage;
    1472:	6003      	str	r3, [r0, #0]
    1474:	e000      	b.n	1478 <xQueueGenericCreate+0x2c>
		pxNewQueue->pcHead = (int8_t *)pxNewQueue;
    1476:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength   = uxQueueLength;
    1478:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
    147a:	6425      	str	r5, [r4, #64]	; 0x40
	(void)xQueueGenericReset(pxNewQueue, pdTRUE);
    147c:	2101      	movs	r1, #1
    147e:	0020      	movs	r0, r4
    1480:	4b04      	ldr	r3, [pc, #16]	; (1494 <xQueueGenericCreate+0x48>)
    1482:	4798      	blx	r3
		pxNewQueue->ucQueueType = ucQueueType;
    1484:	2350      	movs	r3, #80	; 0x50
    1486:	54e7      	strb	r7, [r4, r3]
		pxNewQueue->pxQueueSetContainer = NULL;
    1488:	2300      	movs	r3, #0
    148a:	64a3      	str	r3, [r4, #72]	; 0x48
}
    148c:	0020      	movs	r0, r4
    148e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1490:	000010e5 	.word	0x000010e5
    1494:	000013d1 	.word	0x000013d1

00001498 <xQueueCreateCountingSemaphore>:
{
    1498:	b510      	push	{r4, lr}
    149a:	000c      	movs	r4, r1
	configASSERT(uxMaxCount != 0);
    149c:	2800      	cmp	r0, #0
    149e:	d101      	bne.n	14a4 <xQueueCreateCountingSemaphore+0xc>
    14a0:	b672      	cpsid	i
    14a2:	e7fe      	b.n	14a2 <xQueueCreateCountingSemaphore+0xa>
	configASSERT(uxInitialCount <= uxMaxCount);
    14a4:	4288      	cmp	r0, r1
    14a6:	d201      	bcs.n	14ac <xQueueCreateCountingSemaphore+0x14>
    14a8:	b672      	cpsid	i
    14aa:	e7fe      	b.n	14aa <xQueueCreateCountingSemaphore+0x12>
	xHandle = xQueueGenericCreate(uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE);
    14ac:	2202      	movs	r2, #2
    14ae:	2100      	movs	r1, #0
    14b0:	4b02      	ldr	r3, [pc, #8]	; (14bc <xQueueCreateCountingSemaphore+0x24>)
    14b2:	4798      	blx	r3
	if (xHandle != NULL) {
    14b4:	2800      	cmp	r0, #0
    14b6:	d000      	beq.n	14ba <xQueueCreateCountingSemaphore+0x22>
		((Queue_t *)xHandle)->uxMessagesWaiting = uxInitialCount;
    14b8:	6384      	str	r4, [r0, #56]	; 0x38
}
    14ba:	bd10      	pop	{r4, pc}
    14bc:	0000144d 	.word	0x0000144d

000014c0 <xQueueGenericSend>:
{
    14c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    14c2:	46ce      	mov	lr, r9
    14c4:	4647      	mov	r7, r8
    14c6:	b580      	push	{r7, lr}
    14c8:	b085      	sub	sp, #20
    14ca:	0004      	movs	r4, r0
    14cc:	000f      	movs	r7, r1
    14ce:	9201      	str	r2, [sp, #4]
    14d0:	001d      	movs	r5, r3
	configASSERT(pxQueue);
    14d2:	2800      	cmp	r0, #0
    14d4:	d00c      	beq.n	14f0 <xQueueGenericSend+0x30>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    14d6:	2900      	cmp	r1, #0
    14d8:	d00c      	beq.n	14f4 <xQueueGenericSend+0x34>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    14da:	2d02      	cmp	r5, #2
    14dc:	d00f      	beq.n	14fe <xQueueGenericSend+0x3e>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    14de:	4b4e      	ldr	r3, [pc, #312]	; (1618 <xQueueGenericSend+0x158>)
    14e0:	4798      	blx	r3
    14e2:	2800      	cmp	r0, #0
    14e4:	d110      	bne.n	1508 <xQueueGenericSend+0x48>
    14e6:	9b01      	ldr	r3, [sp, #4]
    14e8:	2b00      	cmp	r3, #0
    14ea:	d011      	beq.n	1510 <xQueueGenericSend+0x50>
    14ec:	b672      	cpsid	i
    14ee:	e7fe      	b.n	14ee <xQueueGenericSend+0x2e>
	configASSERT(pxQueue);
    14f0:	b672      	cpsid	i
    14f2:	e7fe      	b.n	14f2 <xQueueGenericSend+0x32>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    14f4:	6c03      	ldr	r3, [r0, #64]	; 0x40
    14f6:	2b00      	cmp	r3, #0
    14f8:	d0ef      	beq.n	14da <xQueueGenericSend+0x1a>
    14fa:	b672      	cpsid	i
    14fc:	e7fe      	b.n	14fc <xQueueGenericSend+0x3c>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    14fe:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    1500:	2b01      	cmp	r3, #1
    1502:	d0ec      	beq.n	14de <xQueueGenericSend+0x1e>
    1504:	b672      	cpsid	i
    1506:	e7fe      	b.n	1506 <xQueueGenericSend+0x46>
    1508:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    150a:	4b44      	ldr	r3, [pc, #272]	; (161c <xQueueGenericSend+0x15c>)
    150c:	4698      	mov	r8, r3
    150e:	e04c      	b.n	15aa <xQueueGenericSend+0xea>
    1510:	2600      	movs	r6, #0
    1512:	e7fa      	b.n	150a <xQueueGenericSend+0x4a>
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    1514:	002a      	movs	r2, r5
    1516:	0039      	movs	r1, r7
    1518:	0020      	movs	r0, r4
    151a:	4b41      	ldr	r3, [pc, #260]	; (1620 <xQueueGenericSend+0x160>)
    151c:	4798      	blx	r3
					if (pxQueue->pxQueueSetContainer != NULL) {
    151e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    1520:	2b00      	cmp	r3, #0
    1522:	d00f      	beq.n	1544 <xQueueGenericSend+0x84>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    1524:	0029      	movs	r1, r5
    1526:	0020      	movs	r0, r4
    1528:	4b3e      	ldr	r3, [pc, #248]	; (1624 <xQueueGenericSend+0x164>)
    152a:	4798      	blx	r3
    152c:	2800      	cmp	r0, #0
    152e:	d001      	beq.n	1534 <xQueueGenericSend+0x74>
							queueYIELD_IF_USING_PREEMPTION();
    1530:	4b3d      	ldr	r3, [pc, #244]	; (1628 <xQueueGenericSend+0x168>)
    1532:	4798      	blx	r3
				taskEXIT_CRITICAL();
    1534:	4b3d      	ldr	r3, [pc, #244]	; (162c <xQueueGenericSend+0x16c>)
    1536:	4798      	blx	r3
				return pdPASS;
    1538:	2001      	movs	r0, #1
}
    153a:	b005      	add	sp, #20
    153c:	bc0c      	pop	{r2, r3}
    153e:	4690      	mov	r8, r2
    1540:	4699      	mov	r9, r3
    1542:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    1544:	6a63      	ldr	r3, [r4, #36]	; 0x24
    1546:	2b00      	cmp	r3, #0
    1548:	d008      	beq.n	155c <xQueueGenericSend+0x9c>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    154a:	0020      	movs	r0, r4
    154c:	3024      	adds	r0, #36	; 0x24
    154e:	4b38      	ldr	r3, [pc, #224]	; (1630 <xQueueGenericSend+0x170>)
    1550:	4798      	blx	r3
    1552:	2800      	cmp	r0, #0
    1554:	d0ee      	beq.n	1534 <xQueueGenericSend+0x74>
								queueYIELD_IF_USING_PREEMPTION();
    1556:	4b34      	ldr	r3, [pc, #208]	; (1628 <xQueueGenericSend+0x168>)
    1558:	4798      	blx	r3
    155a:	e7eb      	b.n	1534 <xQueueGenericSend+0x74>
						} else if (xYieldRequired != pdFALSE) {
    155c:	2800      	cmp	r0, #0
    155e:	d0e9      	beq.n	1534 <xQueueGenericSend+0x74>
							queueYIELD_IF_USING_PREEMPTION();
    1560:	4b31      	ldr	r3, [pc, #196]	; (1628 <xQueueGenericSend+0x168>)
    1562:	4798      	blx	r3
    1564:	e7e6      	b.n	1534 <xQueueGenericSend+0x74>
					taskEXIT_CRITICAL();
    1566:	4b31      	ldr	r3, [pc, #196]	; (162c <xQueueGenericSend+0x16c>)
    1568:	4798      	blx	r3
					return errQUEUE_FULL;
    156a:	2000      	movs	r0, #0
    156c:	e7e5      	b.n	153a <xQueueGenericSend+0x7a>
		prvLockQueue(pxQueue);
    156e:	4b2f      	ldr	r3, [pc, #188]	; (162c <xQueueGenericSend+0x16c>)
    1570:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    1572:	a901      	add	r1, sp, #4
    1574:	a802      	add	r0, sp, #8
    1576:	4b2f      	ldr	r3, [pc, #188]	; (1634 <xQueueGenericSend+0x174>)
    1578:	4798      	blx	r3
    157a:	2800      	cmp	r0, #0
    157c:	d144      	bne.n	1608 <xQueueGenericSend+0x148>
	taskENTER_CRITICAL();
    157e:	4b27      	ldr	r3, [pc, #156]	; (161c <xQueueGenericSend+0x15c>)
    1580:	4798      	blx	r3
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
    1582:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1584:	4699      	mov	r9, r3
    1586:	6be6      	ldr	r6, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
    1588:	4b28      	ldr	r3, [pc, #160]	; (162c <xQueueGenericSend+0x16c>)
    158a:	4798      	blx	r3
			if (prvIsQueueFull(pxQueue) != pdFALSE) {
    158c:	45b1      	cmp	r9, r6
    158e:	d135      	bne.n	15fc <xQueueGenericSend+0x13c>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
    1590:	0020      	movs	r0, r4
    1592:	3010      	adds	r0, #16
    1594:	9901      	ldr	r1, [sp, #4]
    1596:	4b28      	ldr	r3, [pc, #160]	; (1638 <xQueueGenericSend+0x178>)
    1598:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    159a:	0020      	movs	r0, r4
    159c:	4b27      	ldr	r3, [pc, #156]	; (163c <xQueueGenericSend+0x17c>)
    159e:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    15a0:	4b27      	ldr	r3, [pc, #156]	; (1640 <xQueueGenericSend+0x180>)
    15a2:	4798      	blx	r3
    15a4:	2800      	cmp	r0, #0
    15a6:	d026      	beq.n	15f6 <xQueueGenericSend+0x136>
    15a8:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    15aa:	47c0      	blx	r8
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    15ac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    15ae:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    15b0:	4293      	cmp	r3, r2
    15b2:	d3af      	bcc.n	1514 <xQueueGenericSend+0x54>
    15b4:	2d02      	cmp	r5, #2
    15b6:	d0ad      	beq.n	1514 <xQueueGenericSend+0x54>
				if (xTicksToWait == (TickType_t)0) {
    15b8:	9b01      	ldr	r3, [sp, #4]
    15ba:	2b00      	cmp	r3, #0
    15bc:	d0d3      	beq.n	1566 <xQueueGenericSend+0xa6>
				} else if (xEntryTimeSet == pdFALSE) {
    15be:	2e00      	cmp	r6, #0
    15c0:	d102      	bne.n	15c8 <xQueueGenericSend+0x108>
					vTaskInternalSetTimeOutState(&xTimeOut);
    15c2:	a802      	add	r0, sp, #8
    15c4:	4b1f      	ldr	r3, [pc, #124]	; (1644 <xQueueGenericSend+0x184>)
    15c6:	4798      	blx	r3
		taskEXIT_CRITICAL();
    15c8:	4b18      	ldr	r3, [pc, #96]	; (162c <xQueueGenericSend+0x16c>)
    15ca:	4798      	blx	r3
		vTaskSuspendAll();
    15cc:	4b1e      	ldr	r3, [pc, #120]	; (1648 <xQueueGenericSend+0x188>)
    15ce:	4798      	blx	r3
		prvLockQueue(pxQueue);
    15d0:	4b12      	ldr	r3, [pc, #72]	; (161c <xQueueGenericSend+0x15c>)
    15d2:	4798      	blx	r3
    15d4:	2344      	movs	r3, #68	; 0x44
    15d6:	5ce3      	ldrb	r3, [r4, r3]
    15d8:	b25b      	sxtb	r3, r3
    15da:	3301      	adds	r3, #1
    15dc:	d102      	bne.n	15e4 <xQueueGenericSend+0x124>
    15de:	2200      	movs	r2, #0
    15e0:	2344      	movs	r3, #68	; 0x44
    15e2:	54e2      	strb	r2, [r4, r3]
    15e4:	2345      	movs	r3, #69	; 0x45
    15e6:	5ce3      	ldrb	r3, [r4, r3]
    15e8:	b25b      	sxtb	r3, r3
    15ea:	3301      	adds	r3, #1
    15ec:	d1bf      	bne.n	156e <xQueueGenericSend+0xae>
    15ee:	2200      	movs	r2, #0
    15f0:	2345      	movs	r3, #69	; 0x45
    15f2:	54e2      	strb	r2, [r4, r3]
    15f4:	e7bb      	b.n	156e <xQueueGenericSend+0xae>
					portYIELD_WITHIN_API();
    15f6:	4b0c      	ldr	r3, [pc, #48]	; (1628 <xQueueGenericSend+0x168>)
    15f8:	4798      	blx	r3
    15fa:	e7d5      	b.n	15a8 <xQueueGenericSend+0xe8>
				prvUnlockQueue(pxQueue);
    15fc:	0020      	movs	r0, r4
    15fe:	4b0f      	ldr	r3, [pc, #60]	; (163c <xQueueGenericSend+0x17c>)
    1600:	4798      	blx	r3
				(void)xTaskResumeAll();
    1602:	4b0f      	ldr	r3, [pc, #60]	; (1640 <xQueueGenericSend+0x180>)
    1604:	4798      	blx	r3
    1606:	e7cf      	b.n	15a8 <xQueueGenericSend+0xe8>
			prvUnlockQueue(pxQueue);
    1608:	0020      	movs	r0, r4
    160a:	4b0c      	ldr	r3, [pc, #48]	; (163c <xQueueGenericSend+0x17c>)
    160c:	4798      	blx	r3
			(void)xTaskResumeAll();
    160e:	4b0c      	ldr	r3, [pc, #48]	; (1640 <xQueueGenericSend+0x180>)
    1610:	4798      	blx	r3
			return errQUEUE_FULL;
    1612:	2000      	movs	r0, #0
    1614:	e791      	b.n	153a <xQueueGenericSend+0x7a>
    1616:	46c0      	nop			; (mov r8, r8)
    1618:	0000260d 	.word	0x0000260d
    161c:	00001025 	.word	0x00001025
    1620:	00001215 	.word	0x00001215
    1624:	00001291 	.word	0x00001291
    1628:	0000100d 	.word	0x0000100d
    162c:	0000103d 	.word	0x0000103d
    1630:	00002355 	.word	0x00002355
    1634:	000023e1 	.word	0x000023e1
    1638:	000022f1 	.word	0x000022f1
    163c:	00001321 	.word	0x00001321
    1640:	00002079 	.word	0x00002079
    1644:	000023d1 	.word	0x000023d1
    1648:	00001f45 	.word	0x00001f45

0000164c <xQueueCreateMutex>:
{
    164c:	b570      	push	{r4, r5, r6, lr}
    164e:	0002      	movs	r2, r0
	pxNewQueue = (Queue_t *)xQueueGenericCreate(uxMutexLength, uxMutexSize, ucQueueType);
    1650:	2100      	movs	r1, #0
    1652:	2001      	movs	r0, #1
    1654:	4b06      	ldr	r3, [pc, #24]	; (1670 <xQueueCreateMutex+0x24>)
    1656:	4798      	blx	r3
    1658:	1e04      	subs	r4, r0, #0
	if (pxNewQueue != NULL) {
    165a:	d007      	beq.n	166c <xQueueCreateMutex+0x20>
		pxNewQueue->pxMutexHolder = NULL;
    165c:	2300      	movs	r3, #0
    165e:	6043      	str	r3, [r0, #4]
		pxNewQueue->uxQueueType   = queueQUEUE_IS_MUTEX;
    1660:	6003      	str	r3, [r0, #0]
		pxNewQueue->u.uxRecursiveCallCount = 0;
    1662:	60c3      	str	r3, [r0, #12]
		(void)xQueueGenericSend(pxNewQueue, NULL, (TickType_t)0U, queueSEND_TO_BACK);
    1664:	2200      	movs	r2, #0
    1666:	2100      	movs	r1, #0
    1668:	4d02      	ldr	r5, [pc, #8]	; (1674 <xQueueCreateMutex+0x28>)
    166a:	47a8      	blx	r5
}
    166c:	0020      	movs	r0, r4
    166e:	bd70      	pop	{r4, r5, r6, pc}
    1670:	0000144d 	.word	0x0000144d
    1674:	000014c1 	.word	0x000014c1

00001678 <xQueueGenericSendFromISR>:
{
    1678:	b5f0      	push	{r4, r5, r6, r7, lr}
    167a:	b083      	sub	sp, #12
    167c:	0004      	movs	r4, r0
    167e:	9101      	str	r1, [sp, #4]
    1680:	0016      	movs	r6, r2
    1682:	001d      	movs	r5, r3
	configASSERT(pxQueue);
    1684:	2800      	cmp	r0, #0
    1686:	d012      	beq.n	16ae <xQueueGenericSendFromISR+0x36>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    1688:	9b01      	ldr	r3, [sp, #4]
    168a:	2b00      	cmp	r3, #0
    168c:	d011      	beq.n	16b2 <xQueueGenericSendFromISR+0x3a>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    168e:	2d02      	cmp	r5, #2
    1690:	d014      	beq.n	16bc <xQueueGenericSendFromISR+0x44>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1692:	4b28      	ldr	r3, [pc, #160]	; (1734 <xQueueGenericSendFromISR+0xbc>)
    1694:	4798      	blx	r3
    1696:	9000      	str	r0, [sp, #0]
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    1698:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    169a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    169c:	429a      	cmp	r2, r3
    169e:	d82f      	bhi.n	1700 <xQueueGenericSendFromISR+0x88>
			xReturn = errQUEUE_FULL;
    16a0:	2500      	movs	r5, #0
	portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);
    16a2:	9800      	ldr	r0, [sp, #0]
    16a4:	4b24      	ldr	r3, [pc, #144]	; (1738 <xQueueGenericSendFromISR+0xc0>)
    16a6:	4798      	blx	r3
}
    16a8:	0028      	movs	r0, r5
    16aa:	b003      	add	sp, #12
    16ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
	configASSERT(pxQueue);
    16ae:	b672      	cpsid	i
    16b0:	e7fe      	b.n	16b0 <xQueueGenericSendFromISR+0x38>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    16b2:	6c03      	ldr	r3, [r0, #64]	; 0x40
    16b4:	2b00      	cmp	r3, #0
    16b6:	d0ea      	beq.n	168e <xQueueGenericSendFromISR+0x16>
    16b8:	b672      	cpsid	i
    16ba:	e7fe      	b.n	16ba <xQueueGenericSendFromISR+0x42>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    16bc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    16be:	2b01      	cmp	r3, #1
    16c0:	d01a      	beq.n	16f8 <xQueueGenericSendFromISR+0x80>
    16c2:	b672      	cpsid	i
    16c4:	e7fe      	b.n	16c4 <xQueueGenericSendFromISR+0x4c>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    16c6:	6a63      	ldr	r3, [r4, #36]	; 0x24
			xReturn = pdPASS;
    16c8:	2501      	movs	r5, #1
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    16ca:	2b00      	cmp	r3, #0
    16cc:	d0e9      	beq.n	16a2 <xQueueGenericSendFromISR+0x2a>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    16ce:	0020      	movs	r0, r4
    16d0:	3024      	adds	r0, #36	; 0x24
    16d2:	4b1a      	ldr	r3, [pc, #104]	; (173c <xQueueGenericSendFromISR+0xc4>)
    16d4:	4798      	blx	r3
    16d6:	2800      	cmp	r0, #0
    16d8:	d0e3      	beq.n	16a2 <xQueueGenericSendFromISR+0x2a>
								if (pxHigherPriorityTaskWoken != NULL) {
    16da:	2e00      	cmp	r6, #0
    16dc:	d00a      	beq.n	16f4 <xQueueGenericSendFromISR+0x7c>
									*pxHigherPriorityTaskWoken = pdTRUE;
    16de:	2301      	movs	r3, #1
    16e0:	6033      	str	r3, [r6, #0]
    16e2:	e7de      	b.n	16a2 <xQueueGenericSendFromISR+0x2a>
				pxQueue->cTxLock = (int8_t)(cTxLock + 1);
    16e4:	1c7b      	adds	r3, r7, #1
    16e6:	b25b      	sxtb	r3, r3
    16e8:	2245      	movs	r2, #69	; 0x45
    16ea:	54a3      	strb	r3, [r4, r2]
			xReturn = pdPASS;
    16ec:	2501      	movs	r5, #1
    16ee:	e7d8      	b.n	16a2 <xQueueGenericSendFromISR+0x2a>
    16f0:	2501      	movs	r5, #1
    16f2:	e7d6      	b.n	16a2 <xQueueGenericSendFromISR+0x2a>
    16f4:	2501      	movs	r5, #1
    16f6:	e7d4      	b.n	16a2 <xQueueGenericSendFromISR+0x2a>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    16f8:	4b0e      	ldr	r3, [pc, #56]	; (1734 <xQueueGenericSendFromISR+0xbc>)
    16fa:	4798      	blx	r3
    16fc:	9000      	str	r0, [sp, #0]
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    16fe:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			const int8_t cTxLock = pxQueue->cTxLock;
    1700:	2345      	movs	r3, #69	; 0x45
    1702:	5ce7      	ldrb	r7, [r4, r3]
    1704:	b27f      	sxtb	r7, r7
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    1706:	002a      	movs	r2, r5
    1708:	9901      	ldr	r1, [sp, #4]
    170a:	0020      	movs	r0, r4
    170c:	4b0c      	ldr	r3, [pc, #48]	; (1740 <xQueueGenericSendFromISR+0xc8>)
    170e:	4798      	blx	r3
			if (cTxLock == queueUNLOCKED) {
    1710:	1c7b      	adds	r3, r7, #1
    1712:	d1e7      	bne.n	16e4 <xQueueGenericSendFromISR+0x6c>
					if (pxQueue->pxQueueSetContainer != NULL) {
    1714:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    1716:	2b00      	cmp	r3, #0
    1718:	d0d5      	beq.n	16c6 <xQueueGenericSendFromISR+0x4e>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    171a:	0029      	movs	r1, r5
    171c:	0020      	movs	r0, r4
    171e:	4b09      	ldr	r3, [pc, #36]	; (1744 <xQueueGenericSendFromISR+0xcc>)
    1720:	4798      	blx	r3
			xReturn = pdPASS;
    1722:	2501      	movs	r5, #1
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    1724:	2800      	cmp	r0, #0
    1726:	d0bc      	beq.n	16a2 <xQueueGenericSendFromISR+0x2a>
							if (pxHigherPriorityTaskWoken != NULL) {
    1728:	2e00      	cmp	r6, #0
    172a:	d0e1      	beq.n	16f0 <xQueueGenericSendFromISR+0x78>
								*pxHigherPriorityTaskWoken = pdTRUE;
    172c:	2301      	movs	r3, #1
    172e:	6033      	str	r3, [r6, #0]
    1730:	e7b7      	b.n	16a2 <xQueueGenericSendFromISR+0x2a>
    1732:	46c0      	nop			; (mov r8, r8)
    1734:	0000105d 	.word	0x0000105d
    1738:	00001065 	.word	0x00001065
    173c:	00002355 	.word	0x00002355
    1740:	00001215 	.word	0x00001215
    1744:	00001291 	.word	0x00001291

00001748 <xQueueGiveFromISR>:
{
    1748:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    174a:	0004      	movs	r4, r0
    174c:	000f      	movs	r7, r1
	configASSERT(pxQueue);
    174e:	2800      	cmp	r0, #0
    1750:	d004      	beq.n	175c <xQueueGiveFromISR+0x14>
	configASSERT(pxQueue->uxItemSize == 0);
    1752:	6c03      	ldr	r3, [r0, #64]	; 0x40
    1754:	2b00      	cmp	r3, #0
    1756:	d003      	beq.n	1760 <xQueueGiveFromISR+0x18>
    1758:	b672      	cpsid	i
    175a:	e7fe      	b.n	175a <xQueueGiveFromISR+0x12>
	configASSERT(pxQueue);
    175c:	b672      	cpsid	i
    175e:	e7fe      	b.n	175e <xQueueGiveFromISR+0x16>
	configASSERT(!((pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) && (pxQueue->pxMutexHolder != NULL)));
    1760:	6803      	ldr	r3, [r0, #0]
    1762:	2b00      	cmp	r3, #0
    1764:	d021      	beq.n	17aa <xQueueGiveFromISR+0x62>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1766:	4b20      	ldr	r3, [pc, #128]	; (17e8 <xQueueGiveFromISR+0xa0>)
    1768:	4798      	blx	r3
    176a:	0006      	movs	r6, r0
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    176c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
			xReturn = errQUEUE_FULL;
    176e:	2500      	movs	r5, #0
		if (uxMessagesWaiting < pxQueue->uxLength) {
    1770:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    1772:	429a      	cmp	r2, r3
    1774:	d214      	bcs.n	17a0 <xQueueGiveFromISR+0x58>
			const int8_t cTxLock = pxQueue->cTxLock;
    1776:	2345      	movs	r3, #69	; 0x45
    1778:	5ce3      	ldrb	r3, [r4, r3]
    177a:	b25b      	sxtb	r3, r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + (UBaseType_t)1;
    177c:	3201      	adds	r2, #1
    177e:	63a2      	str	r2, [r4, #56]	; 0x38
			if (cTxLock == queueUNLOCKED) {
    1780:	1c5a      	adds	r2, r3, #1
    1782:	d126      	bne.n	17d2 <xQueueGiveFromISR+0x8a>
					if (pxQueue->pxQueueSetContainer != NULL) {
    1784:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    1786:	2b00      	cmp	r3, #0
    1788:	d014      	beq.n	17b4 <xQueueGiveFromISR+0x6c>
						if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    178a:	2100      	movs	r1, #0
    178c:	0020      	movs	r0, r4
    178e:	4b17      	ldr	r3, [pc, #92]	; (17ec <xQueueGiveFromISR+0xa4>)
    1790:	4798      	blx	r3
			xReturn = pdPASS;
    1792:	3501      	adds	r5, #1
						if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    1794:	2800      	cmp	r0, #0
    1796:	d003      	beq.n	17a0 <xQueueGiveFromISR+0x58>
							if (pxHigherPriorityTaskWoken != NULL) {
    1798:	2f00      	cmp	r7, #0
    179a:	d020      	beq.n	17de <xQueueGiveFromISR+0x96>
								*pxHigherPriorityTaskWoken = pdTRUE;
    179c:	2301      	movs	r3, #1
    179e:	603b      	str	r3, [r7, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedInterruptStatus);
    17a0:	0030      	movs	r0, r6
    17a2:	4b13      	ldr	r3, [pc, #76]	; (17f0 <xQueueGiveFromISR+0xa8>)
    17a4:	4798      	blx	r3
}
    17a6:	0028      	movs	r0, r5
    17a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	configASSERT(!((pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) && (pxQueue->pxMutexHolder != NULL)));
    17aa:	6843      	ldr	r3, [r0, #4]
    17ac:	2b00      	cmp	r3, #0
    17ae:	d0da      	beq.n	1766 <xQueueGiveFromISR+0x1e>
    17b0:	b672      	cpsid	i
    17b2:	e7fe      	b.n	17b2 <xQueueGiveFromISR+0x6a>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    17b4:	6a63      	ldr	r3, [r4, #36]	; 0x24
			xReturn = pdPASS;
    17b6:	2501      	movs	r5, #1
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    17b8:	2b00      	cmp	r3, #0
    17ba:	d0f1      	beq.n	17a0 <xQueueGiveFromISR+0x58>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    17bc:	0020      	movs	r0, r4
    17be:	3024      	adds	r0, #36	; 0x24
    17c0:	4b0c      	ldr	r3, [pc, #48]	; (17f4 <xQueueGiveFromISR+0xac>)
    17c2:	4798      	blx	r3
    17c4:	2800      	cmp	r0, #0
    17c6:	d0eb      	beq.n	17a0 <xQueueGiveFromISR+0x58>
								if (pxHigherPriorityTaskWoken != NULL) {
    17c8:	2f00      	cmp	r7, #0
    17ca:	d00a      	beq.n	17e2 <xQueueGiveFromISR+0x9a>
									*pxHigherPriorityTaskWoken = pdTRUE;
    17cc:	2301      	movs	r3, #1
    17ce:	603b      	str	r3, [r7, #0]
    17d0:	e7e6      	b.n	17a0 <xQueueGiveFromISR+0x58>
				pxQueue->cTxLock = (int8_t)(cTxLock + 1);
    17d2:	3301      	adds	r3, #1
    17d4:	b25b      	sxtb	r3, r3
    17d6:	2245      	movs	r2, #69	; 0x45
    17d8:	54a3      	strb	r3, [r4, r2]
			xReturn = pdPASS;
    17da:	2501      	movs	r5, #1
    17dc:	e7e0      	b.n	17a0 <xQueueGiveFromISR+0x58>
    17de:	2501      	movs	r5, #1
    17e0:	e7de      	b.n	17a0 <xQueueGiveFromISR+0x58>
    17e2:	2501      	movs	r5, #1
    17e4:	e7dc      	b.n	17a0 <xQueueGiveFromISR+0x58>
    17e6:	46c0      	nop			; (mov r8, r8)
    17e8:	0000105d 	.word	0x0000105d
    17ec:	00001291 	.word	0x00001291
    17f0:	00001065 	.word	0x00001065
    17f4:	00002355 	.word	0x00002355

000017f8 <xQueueReceive>:
{
    17f8:	b5f0      	push	{r4, r5, r6, r7, lr}
    17fa:	46c6      	mov	lr, r8
    17fc:	b500      	push	{lr}
    17fe:	b084      	sub	sp, #16
    1800:	0004      	movs	r4, r0
    1802:	000f      	movs	r7, r1
    1804:	9201      	str	r2, [sp, #4]
	configASSERT((pxQueue));
    1806:	2800      	cmp	r0, #0
    1808:	d00a      	beq.n	1820 <xQueueReceive+0x28>
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
    180a:	2900      	cmp	r1, #0
    180c:	d00a      	beq.n	1824 <xQueueReceive+0x2c>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    180e:	4b42      	ldr	r3, [pc, #264]	; (1918 <xQueueReceive+0x120>)
    1810:	4798      	blx	r3
    1812:	2800      	cmp	r0, #0
    1814:	d10b      	bne.n	182e <xQueueReceive+0x36>
    1816:	9b01      	ldr	r3, [sp, #4]
    1818:	2b00      	cmp	r3, #0
    181a:	d00c      	beq.n	1836 <xQueueReceive+0x3e>
    181c:	b672      	cpsid	i
    181e:	e7fe      	b.n	181e <xQueueReceive+0x26>
	configASSERT((pxQueue));
    1820:	b672      	cpsid	i
    1822:	e7fe      	b.n	1822 <xQueueReceive+0x2a>
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
    1824:	6c03      	ldr	r3, [r0, #64]	; 0x40
    1826:	2b00      	cmp	r3, #0
    1828:	d0f1      	beq.n	180e <xQueueReceive+0x16>
    182a:	b672      	cpsid	i
    182c:	e7fe      	b.n	182c <xQueueReceive+0x34>
    182e:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    1830:	4b3a      	ldr	r3, [pc, #232]	; (191c <xQueueReceive+0x124>)
    1832:	4698      	mov	r8, r3
    1834:	e02f      	b.n	1896 <xQueueReceive+0x9e>
    1836:	2600      	movs	r6, #0
    1838:	e7fa      	b.n	1830 <xQueueReceive+0x38>
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    183a:	0039      	movs	r1, r7
    183c:	0020      	movs	r0, r4
    183e:	4b38      	ldr	r3, [pc, #224]	; (1920 <xQueueReceive+0x128>)
    1840:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
    1842:	3d01      	subs	r5, #1
    1844:	63a5      	str	r5, [r4, #56]	; 0x38
				if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    1846:	6923      	ldr	r3, [r4, #16]
    1848:	2b00      	cmp	r3, #0
    184a:	d007      	beq.n	185c <xQueueReceive+0x64>
					if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    184c:	0020      	movs	r0, r4
    184e:	3010      	adds	r0, #16
    1850:	4b34      	ldr	r3, [pc, #208]	; (1924 <xQueueReceive+0x12c>)
    1852:	4798      	blx	r3
    1854:	2800      	cmp	r0, #0
    1856:	d001      	beq.n	185c <xQueueReceive+0x64>
						queueYIELD_IF_USING_PREEMPTION();
    1858:	4b33      	ldr	r3, [pc, #204]	; (1928 <xQueueReceive+0x130>)
    185a:	4798      	blx	r3
				taskEXIT_CRITICAL();
    185c:	4b33      	ldr	r3, [pc, #204]	; (192c <xQueueReceive+0x134>)
    185e:	4798      	blx	r3
				return pdPASS;
    1860:	2001      	movs	r0, #1
}
    1862:	b004      	add	sp, #16
    1864:	bc04      	pop	{r2}
    1866:	4690      	mov	r8, r2
    1868:	bdf0      	pop	{r4, r5, r6, r7, pc}
					taskEXIT_CRITICAL();
    186a:	4b30      	ldr	r3, [pc, #192]	; (192c <xQueueReceive+0x134>)
    186c:	4798      	blx	r3
					return errQUEUE_EMPTY;
    186e:	2000      	movs	r0, #0
    1870:	e7f7      	b.n	1862 <xQueueReceive+0x6a>
					vTaskInternalSetTimeOutState(&xTimeOut);
    1872:	a802      	add	r0, sp, #8
    1874:	4b2e      	ldr	r3, [pc, #184]	; (1930 <xQueueReceive+0x138>)
    1876:	4798      	blx	r3
    1878:	e016      	b.n	18a8 <xQueueReceive+0xb0>
		prvLockQueue(pxQueue);
    187a:	2200      	movs	r2, #0
    187c:	2344      	movs	r3, #68	; 0x44
    187e:	54e2      	strb	r2, [r4, r3]
    1880:	e01d      	b.n	18be <xQueueReceive+0xc6>
    1882:	2200      	movs	r2, #0
    1884:	2345      	movs	r3, #69	; 0x45
    1886:	54e2      	strb	r2, [r4, r3]
    1888:	e01e      	b.n	18c8 <xQueueReceive+0xd0>
				prvUnlockQueue(pxQueue);
    188a:	0020      	movs	r0, r4
    188c:	4b29      	ldr	r3, [pc, #164]	; (1934 <xQueueReceive+0x13c>)
    188e:	4798      	blx	r3
				(void)xTaskResumeAll();
    1890:	4b29      	ldr	r3, [pc, #164]	; (1938 <xQueueReceive+0x140>)
    1892:	4798      	blx	r3
    1894:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    1896:	47c0      	blx	r8
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1898:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if (uxMessagesWaiting > (UBaseType_t)0) {
    189a:	2d00      	cmp	r5, #0
    189c:	d1cd      	bne.n	183a <xQueueReceive+0x42>
				if (xTicksToWait == (TickType_t)0) {
    189e:	9b01      	ldr	r3, [sp, #4]
    18a0:	2b00      	cmp	r3, #0
    18a2:	d0e2      	beq.n	186a <xQueueReceive+0x72>
				} else if (xEntryTimeSet == pdFALSE) {
    18a4:	2e00      	cmp	r6, #0
    18a6:	d0e4      	beq.n	1872 <xQueueReceive+0x7a>
		taskEXIT_CRITICAL();
    18a8:	4b20      	ldr	r3, [pc, #128]	; (192c <xQueueReceive+0x134>)
    18aa:	4798      	blx	r3
		vTaskSuspendAll();
    18ac:	4b23      	ldr	r3, [pc, #140]	; (193c <xQueueReceive+0x144>)
    18ae:	4798      	blx	r3
		prvLockQueue(pxQueue);
    18b0:	4b1a      	ldr	r3, [pc, #104]	; (191c <xQueueReceive+0x124>)
    18b2:	4798      	blx	r3
    18b4:	2344      	movs	r3, #68	; 0x44
    18b6:	5ce3      	ldrb	r3, [r4, r3]
    18b8:	b25b      	sxtb	r3, r3
    18ba:	3301      	adds	r3, #1
    18bc:	d0dd      	beq.n	187a <xQueueReceive+0x82>
    18be:	2345      	movs	r3, #69	; 0x45
    18c0:	5ce3      	ldrb	r3, [r4, r3]
    18c2:	b25b      	sxtb	r3, r3
    18c4:	3301      	adds	r3, #1
    18c6:	d0dc      	beq.n	1882 <xQueueReceive+0x8a>
    18c8:	4b18      	ldr	r3, [pc, #96]	; (192c <xQueueReceive+0x134>)
    18ca:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    18cc:	a901      	add	r1, sp, #4
    18ce:	a802      	add	r0, sp, #8
    18d0:	4b1b      	ldr	r3, [pc, #108]	; (1940 <xQueueReceive+0x148>)
    18d2:	4798      	blx	r3
    18d4:	2800      	cmp	r0, #0
    18d6:	d113      	bne.n	1900 <xQueueReceive+0x108>
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    18d8:	0020      	movs	r0, r4
    18da:	4b1a      	ldr	r3, [pc, #104]	; (1944 <xQueueReceive+0x14c>)
    18dc:	4798      	blx	r3
    18de:	2800      	cmp	r0, #0
    18e0:	d0d3      	beq.n	188a <xQueueReceive+0x92>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
    18e2:	0020      	movs	r0, r4
    18e4:	3024      	adds	r0, #36	; 0x24
    18e6:	9901      	ldr	r1, [sp, #4]
    18e8:	4b17      	ldr	r3, [pc, #92]	; (1948 <xQueueReceive+0x150>)
    18ea:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    18ec:	0020      	movs	r0, r4
    18ee:	4b11      	ldr	r3, [pc, #68]	; (1934 <xQueueReceive+0x13c>)
    18f0:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    18f2:	4b11      	ldr	r3, [pc, #68]	; (1938 <xQueueReceive+0x140>)
    18f4:	4798      	blx	r3
    18f6:	2800      	cmp	r0, #0
    18f8:	d1cc      	bne.n	1894 <xQueueReceive+0x9c>
					portYIELD_WITHIN_API();
    18fa:	4b0b      	ldr	r3, [pc, #44]	; (1928 <xQueueReceive+0x130>)
    18fc:	4798      	blx	r3
    18fe:	e7c9      	b.n	1894 <xQueueReceive+0x9c>
			prvUnlockQueue(pxQueue);
    1900:	0020      	movs	r0, r4
    1902:	4b0c      	ldr	r3, [pc, #48]	; (1934 <xQueueReceive+0x13c>)
    1904:	4798      	blx	r3
			(void)xTaskResumeAll();
    1906:	4b0c      	ldr	r3, [pc, #48]	; (1938 <xQueueReceive+0x140>)
    1908:	4798      	blx	r3
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    190a:	0020      	movs	r0, r4
    190c:	4b0d      	ldr	r3, [pc, #52]	; (1944 <xQueueReceive+0x14c>)
    190e:	4798      	blx	r3
    1910:	2800      	cmp	r0, #0
    1912:	d0bf      	beq.n	1894 <xQueueReceive+0x9c>
				return errQUEUE_EMPTY;
    1914:	2000      	movs	r0, #0
    1916:	e7a4      	b.n	1862 <xQueueReceive+0x6a>
    1918:	0000260d 	.word	0x0000260d
    191c:	00001025 	.word	0x00001025
    1920:	000012f9 	.word	0x000012f9
    1924:	00002355 	.word	0x00002355
    1928:	0000100d 	.word	0x0000100d
    192c:	0000103d 	.word	0x0000103d
    1930:	000023d1 	.word	0x000023d1
    1934:	00001321 	.word	0x00001321
    1938:	00002079 	.word	0x00002079
    193c:	00001f45 	.word	0x00001f45
    1940:	000023e1 	.word	0x000023e1
    1944:	000011f9 	.word	0x000011f9
    1948:	000022f1 	.word	0x000022f1

0000194c <xQueueSemaphoreTake>:
{
    194c:	b5f0      	push	{r4, r5, r6, r7, lr}
    194e:	b085      	sub	sp, #20
    1950:	1e04      	subs	r4, r0, #0
    1952:	9101      	str	r1, [sp, #4]
	configASSERT((pxQueue));
    1954:	d004      	beq.n	1960 <xQueueSemaphoreTake+0x14>
	configASSERT(pxQueue->uxItemSize == 0);
    1956:	6c03      	ldr	r3, [r0, #64]	; 0x40
    1958:	2b00      	cmp	r3, #0
    195a:	d003      	beq.n	1964 <xQueueSemaphoreTake+0x18>
    195c:	b672      	cpsid	i
    195e:	e7fe      	b.n	195e <xQueueSemaphoreTake+0x12>
	configASSERT((pxQueue));
    1960:	b672      	cpsid	i
    1962:	e7fe      	b.n	1962 <xQueueSemaphoreTake+0x16>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    1964:	4b50      	ldr	r3, [pc, #320]	; (1aa8 <xQueueSemaphoreTake+0x15c>)
    1966:	4798      	blx	r3
    1968:	2800      	cmp	r0, #0
    196a:	d104      	bne.n	1976 <xQueueSemaphoreTake+0x2a>
    196c:	9b01      	ldr	r3, [sp, #4]
    196e:	2b00      	cmp	r3, #0
    1970:	d005      	beq.n	197e <xQueueSemaphoreTake+0x32>
    1972:	b672      	cpsid	i
    1974:	e7fe      	b.n	1974 <xQueueSemaphoreTake+0x28>
    1976:	2500      	movs	r5, #0
    1978:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    197a:	4f4c      	ldr	r7, [pc, #304]	; (1aac <xQueueSemaphoreTake+0x160>)
    197c:	e048      	b.n	1a10 <xQueueSemaphoreTake+0xc4>
    197e:	2500      	movs	r5, #0
    1980:	2600      	movs	r6, #0
    1982:	e7fa      	b.n	197a <xQueueSemaphoreTake+0x2e>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - (UBaseType_t)1;
    1984:	3b01      	subs	r3, #1
    1986:	63a3      	str	r3, [r4, #56]	; 0x38
					if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    1988:	6823      	ldr	r3, [r4, #0]
    198a:	2b00      	cmp	r3, #0
    198c:	d102      	bne.n	1994 <xQueueSemaphoreTake+0x48>
						    = (int8_t *)pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as
    198e:	4b48      	ldr	r3, [pc, #288]	; (1ab0 <xQueueSemaphoreTake+0x164>)
    1990:	4798      	blx	r3
    1992:	6060      	str	r0, [r4, #4]
				if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    1994:	6923      	ldr	r3, [r4, #16]
    1996:	2b00      	cmp	r3, #0
    1998:	d007      	beq.n	19aa <xQueueSemaphoreTake+0x5e>
					if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    199a:	0020      	movs	r0, r4
    199c:	3010      	adds	r0, #16
    199e:	4b45      	ldr	r3, [pc, #276]	; (1ab4 <xQueueSemaphoreTake+0x168>)
    19a0:	4798      	blx	r3
    19a2:	2800      	cmp	r0, #0
    19a4:	d001      	beq.n	19aa <xQueueSemaphoreTake+0x5e>
						queueYIELD_IF_USING_PREEMPTION();
    19a6:	4b44      	ldr	r3, [pc, #272]	; (1ab8 <xQueueSemaphoreTake+0x16c>)
    19a8:	4798      	blx	r3
				taskEXIT_CRITICAL();
    19aa:	4b44      	ldr	r3, [pc, #272]	; (1abc <xQueueSemaphoreTake+0x170>)
    19ac:	4798      	blx	r3
				return pdPASS;
    19ae:	2501      	movs	r5, #1
}
    19b0:	0028      	movs	r0, r5
    19b2:	b005      	add	sp, #20
    19b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
						configASSERT(xInheritanceOccurred == pdFALSE);
    19b6:	2d00      	cmp	r5, #0
    19b8:	d001      	beq.n	19be <xQueueSemaphoreTake+0x72>
    19ba:	b672      	cpsid	i
    19bc:	e7fe      	b.n	19bc <xQueueSemaphoreTake+0x70>
					taskEXIT_CRITICAL();
    19be:	4b3f      	ldr	r3, [pc, #252]	; (1abc <xQueueSemaphoreTake+0x170>)
    19c0:	4798      	blx	r3
					return errQUEUE_EMPTY;
    19c2:	e7f5      	b.n	19b0 <xQueueSemaphoreTake+0x64>
					vTaskInternalSetTimeOutState(&xTimeOut);
    19c4:	a802      	add	r0, sp, #8
    19c6:	4b3e      	ldr	r3, [pc, #248]	; (1ac0 <xQueueSemaphoreTake+0x174>)
    19c8:	4798      	blx	r3
    19ca:	e02a      	b.n	1a22 <xQueueSemaphoreTake+0xd6>
		prvLockQueue(pxQueue);
    19cc:	2200      	movs	r2, #0
    19ce:	2344      	movs	r3, #68	; 0x44
    19d0:	54e2      	strb	r2, [r4, r3]
    19d2:	e031      	b.n	1a38 <xQueueSemaphoreTake+0xec>
    19d4:	2200      	movs	r2, #0
    19d6:	2345      	movs	r3, #69	; 0x45
    19d8:	54e2      	strb	r2, [r4, r3]
    19da:	e032      	b.n	1a42 <xQueueSemaphoreTake+0xf6>
						taskENTER_CRITICAL();
    19dc:	4b33      	ldr	r3, [pc, #204]	; (1aac <xQueueSemaphoreTake+0x160>)
    19de:	4798      	blx	r3
							xInheritanceOccurred = xTaskPriorityInherit((void *)pxQueue->pxMutexHolder);
    19e0:	6860      	ldr	r0, [r4, #4]
    19e2:	4b38      	ldr	r3, [pc, #224]	; (1ac4 <xQueueSemaphoreTake+0x178>)
    19e4:	4798      	blx	r3
    19e6:	0005      	movs	r5, r0
						taskEXIT_CRITICAL();
    19e8:	4b34      	ldr	r3, [pc, #208]	; (1abc <xQueueSemaphoreTake+0x170>)
    19ea:	4798      	blx	r3
    19ec:	e039      	b.n	1a62 <xQueueSemaphoreTake+0x116>
				prvUnlockQueue(pxQueue);
    19ee:	0020      	movs	r0, r4
    19f0:	4b35      	ldr	r3, [pc, #212]	; (1ac8 <xQueueSemaphoreTake+0x17c>)
    19f2:	4798      	blx	r3
				(void)xTaskResumeAll();
    19f4:	4b35      	ldr	r3, [pc, #212]	; (1acc <xQueueSemaphoreTake+0x180>)
    19f6:	4798      	blx	r3
    19f8:	e009      	b.n	1a0e <xQueueSemaphoreTake+0xc2>
			prvUnlockQueue(pxQueue);
    19fa:	0020      	movs	r0, r4
    19fc:	4b32      	ldr	r3, [pc, #200]	; (1ac8 <xQueueSemaphoreTake+0x17c>)
    19fe:	4798      	blx	r3
			(void)xTaskResumeAll();
    1a00:	4b32      	ldr	r3, [pc, #200]	; (1acc <xQueueSemaphoreTake+0x180>)
    1a02:	4798      	blx	r3
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    1a04:	0020      	movs	r0, r4
    1a06:	4b32      	ldr	r3, [pc, #200]	; (1ad0 <xQueueSemaphoreTake+0x184>)
    1a08:	4798      	blx	r3
    1a0a:	2800      	cmp	r0, #0
    1a0c:	d138      	bne.n	1a80 <xQueueSemaphoreTake+0x134>
    1a0e:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    1a10:	47b8      	blx	r7
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1a12:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if (uxSemaphoreCount > (UBaseType_t)0) {
    1a14:	2b00      	cmp	r3, #0
    1a16:	d1b5      	bne.n	1984 <xQueueSemaphoreTake+0x38>
				if (xTicksToWait == (TickType_t)0) {
    1a18:	9b01      	ldr	r3, [sp, #4]
    1a1a:	2b00      	cmp	r3, #0
    1a1c:	d0cb      	beq.n	19b6 <xQueueSemaphoreTake+0x6a>
				} else if (xEntryTimeSet == pdFALSE) {
    1a1e:	2e00      	cmp	r6, #0
    1a20:	d0d0      	beq.n	19c4 <xQueueSemaphoreTake+0x78>
		taskEXIT_CRITICAL();
    1a22:	4b26      	ldr	r3, [pc, #152]	; (1abc <xQueueSemaphoreTake+0x170>)
    1a24:	4798      	blx	r3
		vTaskSuspendAll();
    1a26:	4b2b      	ldr	r3, [pc, #172]	; (1ad4 <xQueueSemaphoreTake+0x188>)
    1a28:	4798      	blx	r3
		prvLockQueue(pxQueue);
    1a2a:	4b20      	ldr	r3, [pc, #128]	; (1aac <xQueueSemaphoreTake+0x160>)
    1a2c:	4798      	blx	r3
    1a2e:	2344      	movs	r3, #68	; 0x44
    1a30:	5ce3      	ldrb	r3, [r4, r3]
    1a32:	b25b      	sxtb	r3, r3
    1a34:	3301      	adds	r3, #1
    1a36:	d0c9      	beq.n	19cc <xQueueSemaphoreTake+0x80>
    1a38:	2345      	movs	r3, #69	; 0x45
    1a3a:	5ce3      	ldrb	r3, [r4, r3]
    1a3c:	b25b      	sxtb	r3, r3
    1a3e:	3301      	adds	r3, #1
    1a40:	d0c8      	beq.n	19d4 <xQueueSemaphoreTake+0x88>
    1a42:	4b1e      	ldr	r3, [pc, #120]	; (1abc <xQueueSemaphoreTake+0x170>)
    1a44:	4798      	blx	r3
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    1a46:	a901      	add	r1, sp, #4
    1a48:	a802      	add	r0, sp, #8
    1a4a:	4b23      	ldr	r3, [pc, #140]	; (1ad8 <xQueueSemaphoreTake+0x18c>)
    1a4c:	4798      	blx	r3
    1a4e:	2800      	cmp	r0, #0
    1a50:	d1d3      	bne.n	19fa <xQueueSemaphoreTake+0xae>
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    1a52:	0020      	movs	r0, r4
    1a54:	4b1e      	ldr	r3, [pc, #120]	; (1ad0 <xQueueSemaphoreTake+0x184>)
    1a56:	4798      	blx	r3
    1a58:	2800      	cmp	r0, #0
    1a5a:	d0c8      	beq.n	19ee <xQueueSemaphoreTake+0xa2>
					if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    1a5c:	6823      	ldr	r3, [r4, #0]
    1a5e:	2b00      	cmp	r3, #0
    1a60:	d0bc      	beq.n	19dc <xQueueSemaphoreTake+0x90>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
    1a62:	0020      	movs	r0, r4
    1a64:	3024      	adds	r0, #36	; 0x24
    1a66:	9901      	ldr	r1, [sp, #4]
    1a68:	4b1c      	ldr	r3, [pc, #112]	; (1adc <xQueueSemaphoreTake+0x190>)
    1a6a:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    1a6c:	0020      	movs	r0, r4
    1a6e:	4b16      	ldr	r3, [pc, #88]	; (1ac8 <xQueueSemaphoreTake+0x17c>)
    1a70:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    1a72:	4b16      	ldr	r3, [pc, #88]	; (1acc <xQueueSemaphoreTake+0x180>)
    1a74:	4798      	blx	r3
    1a76:	2800      	cmp	r0, #0
    1a78:	d1c9      	bne.n	1a0e <xQueueSemaphoreTake+0xc2>
					portYIELD_WITHIN_API();
    1a7a:	4b0f      	ldr	r3, [pc, #60]	; (1ab8 <xQueueSemaphoreTake+0x16c>)
    1a7c:	4798      	blx	r3
    1a7e:	e7c6      	b.n	1a0e <xQueueSemaphoreTake+0xc2>
					if (xInheritanceOccurred != pdFALSE) {
    1a80:	2d00      	cmp	r5, #0
    1a82:	d100      	bne.n	1a86 <xQueueSemaphoreTake+0x13a>
    1a84:	e794      	b.n	19b0 <xQueueSemaphoreTake+0x64>
						taskENTER_CRITICAL();
    1a86:	4b09      	ldr	r3, [pc, #36]	; (1aac <xQueueSemaphoreTake+0x160>)
    1a88:	4798      	blx	r3
	if (listCURRENT_LIST_LENGTH(&(pxQueue->xTasksWaitingToReceive)) > 0) {
    1a8a:	6a63      	ldr	r3, [r4, #36]	; 0x24
		uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    1a8c:	2100      	movs	r1, #0
	if (listCURRENT_LIST_LENGTH(&(pxQueue->xTasksWaitingToReceive)) > 0) {
    1a8e:	2b00      	cmp	r3, #0
    1a90:	d003      	beq.n	1a9a <xQueueSemaphoreTake+0x14e>
		    = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY(&(pxQueue->xTasksWaitingToReceive));
    1a92:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1a94:	681b      	ldr	r3, [r3, #0]
    1a96:	3105      	adds	r1, #5
    1a98:	1ac9      	subs	r1, r1, r3
							vTaskPriorityDisinheritAfterTimeout((void *)pxQueue->pxMutexHolder,
    1a9a:	6860      	ldr	r0, [r4, #4]
    1a9c:	4b10      	ldr	r3, [pc, #64]	; (1ae0 <xQueueSemaphoreTake+0x194>)
    1a9e:	4798      	blx	r3
						taskEXIT_CRITICAL();
    1aa0:	4b06      	ldr	r3, [pc, #24]	; (1abc <xQueueSemaphoreTake+0x170>)
    1aa2:	4798      	blx	r3
				return errQUEUE_EMPTY;
    1aa4:	2500      	movs	r5, #0
    1aa6:	e783      	b.n	19b0 <xQueueSemaphoreTake+0x64>
    1aa8:	0000260d 	.word	0x0000260d
    1aac:	00001025 	.word	0x00001025
    1ab0:	000028e9 	.word	0x000028e9
    1ab4:	00002355 	.word	0x00002355
    1ab8:	0000100d 	.word	0x0000100d
    1abc:	0000103d 	.word	0x0000103d
    1ac0:	000023d1 	.word	0x000023d1
    1ac4:	00002629 	.word	0x00002629
    1ac8:	00001321 	.word	0x00001321
    1acc:	00002079 	.word	0x00002079
    1ad0:	000011f9 	.word	0x000011f9
    1ad4:	00001f45 	.word	0x00001f45
    1ad8:	000023e1 	.word	0x000023e1
    1adc:	000022f1 	.word	0x000022f1
    1ae0:	0000273d 	.word	0x0000273d

00001ae4 <vQueueDelete>:
{
    1ae4:	b510      	push	{r4, lr}
	configASSERT(pxQueue);
    1ae6:	2800      	cmp	r0, #0
    1ae8:	d101      	bne.n	1aee <vQueueDelete+0xa>
    1aea:	b672      	cpsid	i
    1aec:	e7fe      	b.n	1aec <vQueueDelete+0x8>
		vPortFree(pxQueue);
    1aee:	4b01      	ldr	r3, [pc, #4]	; (1af4 <vQueueDelete+0x10>)
    1af0:	4798      	blx	r3
}
    1af2:	bd10      	pop	{r4, pc}
    1af4:	000011b1 	.word	0x000011b1

00001af8 <vQueueWaitForMessageRestricted>:
{
    1af8:	b570      	push	{r4, r5, r6, lr}
    1afa:	0004      	movs	r4, r0
    1afc:	000d      	movs	r5, r1
    1afe:	0016      	movs	r6, r2
	prvLockQueue(pxQueue);
    1b00:	4b11      	ldr	r3, [pc, #68]	; (1b48 <vQueueWaitForMessageRestricted+0x50>)
    1b02:	4798      	blx	r3
    1b04:	2344      	movs	r3, #68	; 0x44
    1b06:	5ce3      	ldrb	r3, [r4, r3]
    1b08:	b25b      	sxtb	r3, r3
    1b0a:	3301      	adds	r3, #1
    1b0c:	d00d      	beq.n	1b2a <vQueueWaitForMessageRestricted+0x32>
    1b0e:	2345      	movs	r3, #69	; 0x45
    1b10:	5ce3      	ldrb	r3, [r4, r3]
    1b12:	b25b      	sxtb	r3, r3
    1b14:	3301      	adds	r3, #1
    1b16:	d00c      	beq.n	1b32 <vQueueWaitForMessageRestricted+0x3a>
    1b18:	4b0c      	ldr	r3, [pc, #48]	; (1b4c <vQueueWaitForMessageRestricted+0x54>)
    1b1a:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
    1b1c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1b1e:	2b00      	cmp	r3, #0
    1b20:	d00b      	beq.n	1b3a <vQueueWaitForMessageRestricted+0x42>
	prvUnlockQueue(pxQueue);
    1b22:	0020      	movs	r0, r4
    1b24:	4b0a      	ldr	r3, [pc, #40]	; (1b50 <vQueueWaitForMessageRestricted+0x58>)
    1b26:	4798      	blx	r3
}
    1b28:	bd70      	pop	{r4, r5, r6, pc}
	prvLockQueue(pxQueue);
    1b2a:	2200      	movs	r2, #0
    1b2c:	2344      	movs	r3, #68	; 0x44
    1b2e:	54e2      	strb	r2, [r4, r3]
    1b30:	e7ed      	b.n	1b0e <vQueueWaitForMessageRestricted+0x16>
    1b32:	2200      	movs	r2, #0
    1b34:	2345      	movs	r3, #69	; 0x45
    1b36:	54e2      	strb	r2, [r4, r3]
    1b38:	e7ee      	b.n	1b18 <vQueueWaitForMessageRestricted+0x20>
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
    1b3a:	0020      	movs	r0, r4
    1b3c:	3024      	adds	r0, #36	; 0x24
    1b3e:	0032      	movs	r2, r6
    1b40:	0029      	movs	r1, r5
    1b42:	4b04      	ldr	r3, [pc, #16]	; (1b54 <vQueueWaitForMessageRestricted+0x5c>)
    1b44:	4798      	blx	r3
    1b46:	e7ec      	b.n	1b22 <vQueueWaitForMessageRestricted+0x2a>
    1b48:	00001025 	.word	0x00001025
    1b4c:	0000103d 	.word	0x0000103d
    1b50:	00001321 	.word	0x00001321
    1b54:	0000231d 	.word	0x0000231d

00001b58 <prvTaskIsTaskSuspended>:

	/* Accesses xPendingReadyList so must be called from a critical
	section. */

	/* It does not make sense to check if the calling task is suspended. */
	configASSERT(xTask);
    1b58:	2800      	cmp	r0, #0
    1b5a:	d00c      	beq.n	1b76 <prvTaskIsTaskSuspended+0x1e>

	/* Is the task being resumed actually in the suspended list? */
	if (listIS_CONTAINED_WITHIN(&xSuspendedTaskList, &(pxTCB->xStateListItem)) != pdFALSE) {
    1b5c:	4a08      	ldr	r2, [pc, #32]	; (1b80 <prvTaskIsTaskSuspended+0x28>)
	BaseType_t         xReturn = pdFALSE;
    1b5e:	2100      	movs	r1, #0
	if (listIS_CONTAINED_WITHIN(&xSuspendedTaskList, &(pxTCB->xStateListItem)) != pdFALSE) {
    1b60:	6943      	ldr	r3, [r0, #20]
    1b62:	4293      	cmp	r3, r2
    1b64:	d105      	bne.n	1b72 <prvTaskIsTaskSuspended+0x1a>
		/* Has the task already been resumed from within an ISR? */
		if (listIS_CONTAINED_WITHIN(&xPendingReadyList, &(pxTCB->xEventListItem)) == pdFALSE) {
    1b66:	6a83      	ldr	r3, [r0, #40]	; 0x28
    1b68:	3214      	adds	r2, #20
    1b6a:	4293      	cmp	r3, r2
    1b6c:	d005      	beq.n	1b7a <prvTaskIsTaskSuspended+0x22>
	BaseType_t         xReturn = pdFALSE;
    1b6e:	4259      	negs	r1, r3
    1b70:	4159      	adcs	r1, r3
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    1b72:	0008      	movs	r0, r1
    1b74:	4770      	bx	lr
	configASSERT(xTask);
    1b76:	b672      	cpsid	i
    1b78:	e7fe      	b.n	1b78 <prvTaskIsTaskSuspended+0x20>
	BaseType_t         xReturn = pdFALSE;
    1b7a:	2100      	movs	r1, #0
	return xReturn;
    1b7c:	e7f9      	b.n	1b72 <prvTaskIsTaskSuspended+0x1a>
    1b7e:	46c0      	nop			; (mov r8, r8)
    1b80:	20000a2c 	.word	0x20000a2c

00001b84 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    1b84:	4b08      	ldr	r3, [pc, #32]	; (1ba8 <prvResetNextTaskUnblockTime+0x24>)
    1b86:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1b88:	681b      	ldr	r3, [r3, #0]
    1b8a:	2b00      	cmp	r3, #0
    1b8c:	d006      	beq.n	1b9c <prvResetNextTaskUnblockTime+0x18>
	} else {
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    1b8e:	4b06      	ldr	r3, [pc, #24]	; (1ba8 <prvResetNextTaskUnblockTime+0x24>)
    1b90:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    1b92:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
    1b94:	68d2      	ldr	r2, [r2, #12]
    1b96:	6852      	ldr	r2, [r2, #4]
    1b98:	62da      	str	r2, [r3, #44]	; 0x2c
	}
}
    1b9a:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
    1b9c:	2201      	movs	r2, #1
    1b9e:	4252      	negs	r2, r2
    1ba0:	4b01      	ldr	r3, [pc, #4]	; (1ba8 <prvResetNextTaskUnblockTime+0x24>)
    1ba2:	62da      	str	r2, [r3, #44]	; 0x2c
    1ba4:	e7f9      	b.n	1b9a <prvResetNextTaskUnblockTime+0x16>
    1ba6:	46c0      	nop			; (mov r8, r8)
    1ba8:	20000a2c 	.word	0x20000a2c

00001bac <prvIdleTask>:
{
    1bac:	b570      	push	{r4, r5, r6, lr}
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
    1bae:	4c03      	ldr	r4, [pc, #12]	; (1bbc <prvIdleTask+0x10>)
				taskYIELD();
    1bb0:	4d03      	ldr	r5, [pc, #12]	; (1bc0 <prvIdleTask+0x14>)
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
    1bb2:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1bb4:	2b01      	cmp	r3, #1
    1bb6:	d9fc      	bls.n	1bb2 <prvIdleTask+0x6>
				taskYIELD();
    1bb8:	47a8      	blx	r5
    1bba:	e7fa      	b.n	1bb2 <prvIdleTask+0x6>
    1bbc:	20000a2c 	.word	0x20000a2c
    1bc0:	0000100d 	.word	0x0000100d

00001bc4 <prvAddCurrentTaskToDelayedList>:

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)
{
    1bc4:	b570      	push	{r4, r5, r6, lr}
    1bc6:	0004      	movs	r4, r0
    1bc8:	000d      	movs	r5, r1
	TickType_t       xTimeToWake;
	const TickType_t xConstTickCount = xTickCount;
    1bca:	4b15      	ldr	r3, [pc, #84]	; (1c20 <prvAddCurrentTaskToDelayedList+0x5c>)
    1bcc:	695e      	ldr	r6, [r3, #20]
	}
#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
    1bce:	6998      	ldr	r0, [r3, #24]
    1bd0:	3004      	adds	r0, #4
    1bd2:	4b14      	ldr	r3, [pc, #80]	; (1c24 <prvAddCurrentTaskToDelayedList+0x60>)
    1bd4:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

#if (INCLUDE_vTaskSuspend == 1)
	{
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
    1bd6:	1c63      	adds	r3, r4, #1
    1bd8:	d012      	beq.n	1c00 <prvAddCurrentTaskToDelayedList+0x3c>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
		} else {
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    1bda:	1934      	adds	r4, r6, r4

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
    1bdc:	4b10      	ldr	r3, [pc, #64]	; (1c20 <prvAddCurrentTaskToDelayedList+0x5c>)
    1bde:	699b      	ldr	r3, [r3, #24]
    1be0:	605c      	str	r4, [r3, #4]

			if (xTimeToWake < xConstTickCount) {
    1be2:	42a6      	cmp	r6, r4
    1be4:	d815      	bhi.n	1c12 <prvAddCurrentTaskToDelayedList+0x4e>
				list. */
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
			} else {
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
    1be6:	4d10      	ldr	r5, [pc, #64]	; (1c28 <prvAddCurrentTaskToDelayedList+0x64>)
    1be8:	6aa8      	ldr	r0, [r5, #40]	; 0x28
    1bea:	4b0d      	ldr	r3, [pc, #52]	; (1c20 <prvAddCurrentTaskToDelayedList+0x5c>)
    1bec:	6999      	ldr	r1, [r3, #24]
    1bee:	3104      	adds	r1, #4
    1bf0:	4b0e      	ldr	r3, [pc, #56]	; (1c2c <prvAddCurrentTaskToDelayedList+0x68>)
    1bf2:	4798      	blx	r3

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if (xTimeToWake < xNextTaskUnblockTime) {
    1bf4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    1bf6:	429c      	cmp	r4, r3
    1bf8:	d211      	bcs.n	1c1e <prvAddCurrentTaskToDelayedList+0x5a>
					xNextTaskUnblockTime = xTimeToWake;
    1bfa:	4b0b      	ldr	r3, [pc, #44]	; (1c28 <prvAddCurrentTaskToDelayedList+0x64>)
    1bfc:	62dc      	str	r4, [r3, #44]	; 0x2c

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		(void)xCanBlockIndefinitely;
	}
#endif /* INCLUDE_vTaskSuspend */
}
    1bfe:	e00e      	b.n	1c1e <prvAddCurrentTaskToDelayedList+0x5a>
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
    1c00:	2d00      	cmp	r5, #0
    1c02:	d0ea      	beq.n	1bda <prvAddCurrentTaskToDelayedList+0x16>
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
    1c04:	4b06      	ldr	r3, [pc, #24]	; (1c20 <prvAddCurrentTaskToDelayedList+0x5c>)
    1c06:	6999      	ldr	r1, [r3, #24]
    1c08:	3104      	adds	r1, #4
    1c0a:	4807      	ldr	r0, [pc, #28]	; (1c28 <prvAddCurrentTaskToDelayedList+0x64>)
    1c0c:	4b08      	ldr	r3, [pc, #32]	; (1c30 <prvAddCurrentTaskToDelayedList+0x6c>)
    1c0e:	4798      	blx	r3
    1c10:	e005      	b.n	1c1e <prvAddCurrentTaskToDelayedList+0x5a>
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
    1c12:	4b03      	ldr	r3, [pc, #12]	; (1c20 <prvAddCurrentTaskToDelayedList+0x5c>)
    1c14:	69d8      	ldr	r0, [r3, #28]
    1c16:	6999      	ldr	r1, [r3, #24]
    1c18:	3104      	adds	r1, #4
    1c1a:	4b04      	ldr	r3, [pc, #16]	; (1c2c <prvAddCurrentTaskToDelayedList+0x68>)
    1c1c:	4798      	blx	r3
}
    1c1e:	bd70      	pop	{r4, r5, r6, pc}
    1c20:	20000aac 	.word	0x20000aac
    1c24:	00000eff 	.word	0x00000eff
    1c28:	20000a2c 	.word	0x20000a2c
    1c2c:	00000ed1 	.word	0x00000ed1
    1c30:	00000eb9 	.word	0x00000eb9

00001c34 <xTaskCreate>:
{
    1c34:	b5f0      	push	{r4, r5, r6, r7, lr}
    1c36:	46d6      	mov	lr, sl
    1c38:	464f      	mov	r7, r9
    1c3a:	4646      	mov	r6, r8
    1c3c:	b5c0      	push	{r6, r7, lr}
    1c3e:	b084      	sub	sp, #16
    1c40:	9001      	str	r0, [sp, #4]
    1c42:	000d      	movs	r5, r1
    1c44:	9302      	str	r3, [sp, #8]
		pxStack = (StackType_t *)pvPortMalloc(
    1c46:	0097      	lsls	r7, r2, #2
    1c48:	0038      	movs	r0, r7
    1c4a:	4b61      	ldr	r3, [pc, #388]	; (1dd0 <xTaskCreate+0x19c>)
    1c4c:	4798      	blx	r3
    1c4e:	1e06      	subs	r6, r0, #0
		if (pxStack != NULL) {
    1c50:	d100      	bne.n	1c54 <xTaskCreate+0x20>
    1c52:	e089      	b.n	1d68 <xTaskCreate+0x134>
			pxNewTCB = (TCB_t *)pvPortMalloc(
    1c54:	2054      	movs	r0, #84	; 0x54
    1c56:	4b5e      	ldr	r3, [pc, #376]	; (1dd0 <xTaskCreate+0x19c>)
    1c58:	4798      	blx	r3
    1c5a:	1e04      	subs	r4, r0, #0
			if (pxNewTCB != NULL) {
    1c5c:	d100      	bne.n	1c60 <xTaskCreate+0x2c>
    1c5e:	e080      	b.n	1d62 <xTaskCreate+0x12e>
				pxNewTCB->pxStack = pxStack;
    1c60:	6306      	str	r6, [r0, #48]	; 0x30
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
    1c62:	003a      	movs	r2, r7
    1c64:	21a5      	movs	r1, #165	; 0xa5
    1c66:	0030      	movs	r0, r6
    1c68:	4b5a      	ldr	r3, [pc, #360]	; (1dd4 <xTaskCreate+0x1a0>)
    1c6a:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
    1c6c:	1f3a      	subs	r2, r7, #4
    1c6e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    1c70:	469c      	mov	ip, r3
    1c72:	4462      	add	r2, ip
		                      & (~(
    1c74:	2307      	movs	r3, #7
    1c76:	439a      	bics	r2, r3
    1c78:	4690      	mov	r8, r2
		pxNewTCB->pcTaskName[x] = pcName[x];
    1c7a:	782a      	ldrb	r2, [r5, #0]
    1c7c:	332d      	adds	r3, #45	; 0x2d
    1c7e:	54e2      	strb	r2, [r4, r3]
		if (pcName[x] == 0x00) {
    1c80:	782b      	ldrb	r3, [r5, #0]
    1c82:	2b00      	cmp	r3, #0
    1c84:	d00d      	beq.n	1ca2 <xTaskCreate+0x6e>
    1c86:	3501      	adds	r5, #1
    1c88:	0023      	movs	r3, r4
    1c8a:	3335      	adds	r3, #53	; 0x35
    1c8c:	0020      	movs	r0, r4
    1c8e:	303c      	adds	r0, #60	; 0x3c
		pxNewTCB->pcTaskName[x] = pcName[x];
    1c90:	782a      	ldrb	r2, [r5, #0]
    1c92:	701a      	strb	r2, [r3, #0]
		if (pcName[x] == 0x00) {
    1c94:	782a      	ldrb	r2, [r5, #0]
    1c96:	2a00      	cmp	r2, #0
    1c98:	d003      	beq.n	1ca2 <xTaskCreate+0x6e>
    1c9a:	3501      	adds	r5, #1
    1c9c:	3301      	adds	r3, #1
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
    1c9e:	4283      	cmp	r3, r0
    1ca0:	d1f6      	bne.n	1c90 <xTaskCreate+0x5c>
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
    1ca2:	2200      	movs	r2, #0
    1ca4:	233b      	movs	r3, #59	; 0x3b
    1ca6:	54e2      	strb	r2, [r4, r3]
    1ca8:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    1caa:	2f04      	cmp	r7, #4
    1cac:	d900      	bls.n	1cb0 <xTaskCreate+0x7c>
    1cae:	2704      	movs	r7, #4
	pxNewTCB->uxPriority = uxPriority;
    1cb0:	62e7      	str	r7, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
    1cb2:	6467      	str	r7, [r4, #68]	; 0x44
		pxNewTCB->uxMutexesHeld  = 0;
    1cb4:	2600      	movs	r6, #0
    1cb6:	64a6      	str	r6, [r4, #72]	; 0x48
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
    1cb8:	1d23      	adds	r3, r4, #4
    1cba:	9303      	str	r3, [sp, #12]
    1cbc:	0018      	movs	r0, r3
    1cbe:	4d46      	ldr	r5, [pc, #280]	; (1dd8 <xTaskCreate+0x1a4>)
    1cc0:	47a8      	blx	r5
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
    1cc2:	0020      	movs	r0, r4
    1cc4:	3018      	adds	r0, #24
    1cc6:	47a8      	blx	r5
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
    1cc8:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE(
    1cca:	2305      	movs	r3, #5
    1ccc:	1bdb      	subs	r3, r3, r7
    1cce:	61a3      	str	r3, [r4, #24]
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
    1cd0:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
    1cd2:	64e6      	str	r6, [r4, #76]	; 0x4c
		pxNewTCB->ucNotifyState   = taskNOT_WAITING_NOTIFICATION;
    1cd4:	2350      	movs	r3, #80	; 0x50
    1cd6:	54e6      	strb	r6, [r4, r3]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
    1cd8:	9a02      	ldr	r2, [sp, #8]
    1cda:	9901      	ldr	r1, [sp, #4]
    1cdc:	4640      	mov	r0, r8
    1cde:	4b3f      	ldr	r3, [pc, #252]	; (1ddc <xTaskCreate+0x1a8>)
    1ce0:	4798      	blx	r3
    1ce2:	6020      	str	r0, [r4, #0]
	if ((void *)pxCreatedTask != NULL) {
    1ce4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    1ce6:	2b00      	cmp	r3, #0
    1ce8:	d000      	beq.n	1cec <xTaskCreate+0xb8>
		*pxCreatedTask = (TaskHandle_t)pxNewTCB;
    1cea:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
    1cec:	4b3c      	ldr	r3, [pc, #240]	; (1de0 <xTaskCreate+0x1ac>)
    1cee:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
    1cf0:	4b3c      	ldr	r3, [pc, #240]	; (1de4 <xTaskCreate+0x1b0>)
    1cf2:	6a1a      	ldr	r2, [r3, #32]
    1cf4:	3201      	adds	r2, #1
    1cf6:	621a      	str	r2, [r3, #32]
		if (pxCurrentTCB == NULL) {
    1cf8:	699b      	ldr	r3, [r3, #24]
    1cfa:	2b00      	cmp	r3, #0
    1cfc:	d037      	beq.n	1d6e <xTaskCreate+0x13a>
			if (xSchedulerRunning == pdFALSE) {
    1cfe:	4b39      	ldr	r3, [pc, #228]	; (1de4 <xTaskCreate+0x1b0>)
    1d00:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    1d02:	2b00      	cmp	r3, #0
    1d04:	d107      	bne.n	1d16 <xTaskCreate+0xe2>
				if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
    1d06:	4b37      	ldr	r3, [pc, #220]	; (1de4 <xTaskCreate+0x1b0>)
    1d08:	699b      	ldr	r3, [r3, #24]
    1d0a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1d0c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1d0e:	4293      	cmp	r3, r2
    1d10:	d801      	bhi.n	1d16 <xTaskCreate+0xe2>
					pxCurrentTCB = pxNewTCB;
    1d12:	4b34      	ldr	r3, [pc, #208]	; (1de4 <xTaskCreate+0x1b0>)
    1d14:	619c      	str	r4, [r3, #24]
		uxTaskNumber++;
    1d16:	4933      	ldr	r1, [pc, #204]	; (1de4 <xTaskCreate+0x1b0>)
    1d18:	6d0b      	ldr	r3, [r1, #80]	; 0x50
    1d1a:	3301      	adds	r3, #1
    1d1c:	650b      	str	r3, [r1, #80]	; 0x50
			pxNewTCB->uxTCBNumber = uxTaskNumber;
    1d1e:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList(pxNewTCB);
    1d20:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1d22:	6d4b      	ldr	r3, [r1, #84]	; 0x54
    1d24:	429a      	cmp	r2, r3
    1d26:	d900      	bls.n	1d2a <xTaskCreate+0xf6>
    1d28:	654a      	str	r2, [r1, #84]	; 0x54
    1d2a:	0090      	lsls	r0, r2, #2
    1d2c:	1882      	adds	r2, r0, r2
    1d2e:	0092      	lsls	r2, r2, #2
    1d30:	482d      	ldr	r0, [pc, #180]	; (1de8 <xTaskCreate+0x1b4>)
    1d32:	3030      	adds	r0, #48	; 0x30
    1d34:	1880      	adds	r0, r0, r2
    1d36:	9903      	ldr	r1, [sp, #12]
    1d38:	4b2c      	ldr	r3, [pc, #176]	; (1dec <xTaskCreate+0x1b8>)
    1d3a:	4798      	blx	r3
	taskEXIT_CRITICAL();
    1d3c:	4b2c      	ldr	r3, [pc, #176]	; (1df0 <xTaskCreate+0x1bc>)
    1d3e:	4798      	blx	r3
	if (xSchedulerRunning != pdFALSE) {
    1d40:	4b28      	ldr	r3, [pc, #160]	; (1de4 <xTaskCreate+0x1b0>)
    1d42:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
		xReturn = pdPASS;
    1d44:	2001      	movs	r0, #1
	if (xSchedulerRunning != pdFALSE) {
    1d46:	2b00      	cmp	r3, #0
    1d48:	d005      	beq.n	1d56 <xTaskCreate+0x122>
		if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
    1d4a:	4b26      	ldr	r3, [pc, #152]	; (1de4 <xTaskCreate+0x1b0>)
    1d4c:	699b      	ldr	r3, [r3, #24]
    1d4e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1d50:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    1d52:	429a      	cmp	r2, r3
    1d54:	d338      	bcc.n	1dc8 <xTaskCreate+0x194>
}
    1d56:	b004      	add	sp, #16
    1d58:	bc1c      	pop	{r2, r3, r4}
    1d5a:	4690      	mov	r8, r2
    1d5c:	4699      	mov	r9, r3
    1d5e:	46a2      	mov	sl, r4
    1d60:	bdf0      	pop	{r4, r5, r6, r7, pc}
				vPortFree(pxStack);
    1d62:	0030      	movs	r0, r6
    1d64:	4b23      	ldr	r3, [pc, #140]	; (1df4 <xTaskCreate+0x1c0>)
    1d66:	4798      	blx	r3
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1d68:	2001      	movs	r0, #1
    1d6a:	4240      	negs	r0, r0
    1d6c:	e7f3      	b.n	1d56 <xTaskCreate+0x122>
			pxCurrentTCB = pxNewTCB;
    1d6e:	4b1d      	ldr	r3, [pc, #116]	; (1de4 <xTaskCreate+0x1b0>)
    1d70:	619c      	str	r4, [r3, #24]
			if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
    1d72:	6a1b      	ldr	r3, [r3, #32]
    1d74:	2b01      	cmp	r3, #1
    1d76:	d1ce      	bne.n	1d16 <xTaskCreate+0xe2>
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
    1d78:	4f1b      	ldr	r7, [pc, #108]	; (1de8 <xTaskCreate+0x1b4>)
    1d7a:	0038      	movs	r0, r7
    1d7c:	3030      	adds	r0, #48	; 0x30
    1d7e:	4e1e      	ldr	r6, [pc, #120]	; (1df8 <xTaskCreate+0x1c4>)
    1d80:	47b0      	blx	r6
    1d82:	0038      	movs	r0, r7
    1d84:	3044      	adds	r0, #68	; 0x44
    1d86:	47b0      	blx	r6
    1d88:	0038      	movs	r0, r7
    1d8a:	3058      	adds	r0, #88	; 0x58
    1d8c:	47b0      	blx	r6
    1d8e:	0038      	movs	r0, r7
    1d90:	306c      	adds	r0, #108	; 0x6c
    1d92:	47b0      	blx	r6
    1d94:	0038      	movs	r0, r7
    1d96:	3080      	adds	r0, #128	; 0x80
    1d98:	47b0      	blx	r6
	vListInitialise(&xDelayedTaskList1);
    1d9a:	4b12      	ldr	r3, [pc, #72]	; (1de4 <xTaskCreate+0x1b0>)
    1d9c:	4698      	mov	r8, r3
    1d9e:	2324      	movs	r3, #36	; 0x24
    1da0:	4443      	add	r3, r8
    1da2:	469a      	mov	sl, r3
    1da4:	0018      	movs	r0, r3
    1da6:	47b0      	blx	r6
	vListInitialise(&xDelayedTaskList2);
    1da8:	2338      	movs	r3, #56	; 0x38
    1daa:	4443      	add	r3, r8
    1dac:	4699      	mov	r9, r3
    1dae:	0018      	movs	r0, r3
    1db0:	47b0      	blx	r6
	vListInitialise(&xPendingReadyList);
    1db2:	0038      	movs	r0, r7
    1db4:	3014      	adds	r0, #20
    1db6:	47b0      	blx	r6
		vListInitialise(&xSuspendedTaskList);
    1db8:	0038      	movs	r0, r7
    1dba:	47b0      	blx	r6
	pxDelayedTaskList         = &xDelayedTaskList1;
    1dbc:	4653      	mov	r3, sl
    1dbe:	62bb      	str	r3, [r7, #40]	; 0x28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1dc0:	4643      	mov	r3, r8
    1dc2:	464a      	mov	r2, r9
    1dc4:	61da      	str	r2, [r3, #28]
    1dc6:	e7a6      	b.n	1d16 <xTaskCreate+0xe2>
			taskYIELD_IF_USING_PREEMPTION();
    1dc8:	4b0c      	ldr	r3, [pc, #48]	; (1dfc <xTaskCreate+0x1c8>)
    1dca:	4798      	blx	r3
		xReturn = pdPASS;
    1dcc:	2001      	movs	r0, #1
    1dce:	e7c2      	b.n	1d56 <xTaskCreate+0x122>
    1dd0:	000010e5 	.word	0x000010e5
    1dd4:	00002cd7 	.word	0x00002cd7
    1dd8:	00000eb3 	.word	0x00000eb3
    1ddc:	00000f85 	.word	0x00000f85
    1de0:	00001025 	.word	0x00001025
    1de4:	20000aac 	.word	0x20000aac
    1de8:	20000a2c 	.word	0x20000a2c
    1dec:	00000eb9 	.word	0x00000eb9
    1df0:	0000103d 	.word	0x0000103d
    1df4:	000011b1 	.word	0x000011b1
    1df8:	00000e9d 	.word	0x00000e9d
    1dfc:	0000100d 	.word	0x0000100d

00001e00 <eTaskGetState>:
{
    1e00:	b570      	push	{r4, r5, r6, lr}
    1e02:	1e04      	subs	r4, r0, #0
	configASSERT(pxTCB);
    1e04:	d015      	beq.n	1e32 <eTaskGetState+0x32>
	if (pxTCB == pxCurrentTCB) {
    1e06:	4b11      	ldr	r3, [pc, #68]	; (1e4c <eTaskGetState+0x4c>)
    1e08:	699b      	ldr	r3, [r3, #24]
    1e0a:	4298      	cmp	r0, r3
    1e0c:	d018      	beq.n	1e40 <eTaskGetState+0x40>
		taskENTER_CRITICAL();
    1e0e:	4b10      	ldr	r3, [pc, #64]	; (1e50 <eTaskGetState+0x50>)
    1e10:	4798      	blx	r3
			pxStateList = (List_t *)listLIST_ITEM_CONTAINER(&(pxTCB->xStateListItem));
    1e12:	6965      	ldr	r5, [r4, #20]
		taskEXIT_CRITICAL();
    1e14:	4b0f      	ldr	r3, [pc, #60]	; (1e54 <eTaskGetState+0x54>)
    1e16:	4798      	blx	r3
		if ((pxStateList == pxDelayedTaskList) || (pxStateList == pxOverflowDelayedTaskList)) {
    1e18:	4b0f      	ldr	r3, [pc, #60]	; (1e58 <eTaskGetState+0x58>)
    1e1a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1e1c:	429d      	cmp	r5, r3
    1e1e:	d011      	beq.n	1e44 <eTaskGetState+0x44>
    1e20:	4b0a      	ldr	r3, [pc, #40]	; (1e4c <eTaskGetState+0x4c>)
    1e22:	69db      	ldr	r3, [r3, #28]
    1e24:	429d      	cmp	r5, r3
    1e26:	d00f      	beq.n	1e48 <eTaskGetState+0x48>
		else if (pxStateList == &xSuspendedTaskList) {
    1e28:	4b0b      	ldr	r3, [pc, #44]	; (1e58 <eTaskGetState+0x58>)
			eReturn = eReady;
    1e2a:	2001      	movs	r0, #1
		else if (pxStateList == &xSuspendedTaskList) {
    1e2c:	429d      	cmp	r5, r3
    1e2e:	d002      	beq.n	1e36 <eTaskGetState+0x36>
} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    1e30:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(pxTCB);
    1e32:	b672      	cpsid	i
    1e34:	e7fe      	b.n	1e34 <eTaskGetState+0x34>
			if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) == NULL) {
    1e36:	6aa0      	ldr	r0, [r4, #40]	; 0x28
				eReturn = eBlocked;
    1e38:	4243      	negs	r3, r0
    1e3a:	4158      	adcs	r0, r3
    1e3c:	3002      	adds	r0, #2
    1e3e:	e7f7      	b.n	1e30 <eTaskGetState+0x30>
		eReturn = eRunning;
    1e40:	2000      	movs	r0, #0
    1e42:	e7f5      	b.n	1e30 <eTaskGetState+0x30>
			eReturn = eBlocked;
    1e44:	2002      	movs	r0, #2
    1e46:	e7f3      	b.n	1e30 <eTaskGetState+0x30>
    1e48:	2002      	movs	r0, #2
    1e4a:	e7f1      	b.n	1e30 <eTaskGetState+0x30>
    1e4c:	20000aac 	.word	0x20000aac
    1e50:	00001025 	.word	0x00001025
    1e54:	0000103d 	.word	0x0000103d
    1e58:	20000a2c 	.word	0x20000a2c

00001e5c <vTaskResume>:
{
    1e5c:	b570      	push	{r4, r5, r6, lr}
    1e5e:	1e04      	subs	r4, r0, #0
	configASSERT(xTaskToResume);
    1e60:	d00d      	beq.n	1e7e <vTaskResume+0x22>
	if ((pxTCB != NULL) && (pxTCB != pxCurrentTCB)) {
    1e62:	4b16      	ldr	r3, [pc, #88]	; (1ebc <vTaskResume+0x60>)
    1e64:	699b      	ldr	r3, [r3, #24]
    1e66:	4298      	cmp	r0, r3
    1e68:	d008      	beq.n	1e7c <vTaskResume+0x20>
		taskENTER_CRITICAL();
    1e6a:	4b15      	ldr	r3, [pc, #84]	; (1ec0 <vTaskResume+0x64>)
    1e6c:	4798      	blx	r3
			if (prvTaskIsTaskSuspended(pxTCB) != pdFALSE) {
    1e6e:	0020      	movs	r0, r4
    1e70:	4b14      	ldr	r3, [pc, #80]	; (1ec4 <vTaskResume+0x68>)
    1e72:	4798      	blx	r3
    1e74:	2800      	cmp	r0, #0
    1e76:	d104      	bne.n	1e82 <vTaskResume+0x26>
		taskEXIT_CRITICAL();
    1e78:	4b13      	ldr	r3, [pc, #76]	; (1ec8 <vTaskResume+0x6c>)
    1e7a:	4798      	blx	r3
}
    1e7c:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(xTaskToResume);
    1e7e:	b672      	cpsid	i
    1e80:	e7fe      	b.n	1e80 <vTaskResume+0x24>
				(void)uxListRemove(&(pxTCB->xStateListItem));
    1e82:	1d25      	adds	r5, r4, #4
    1e84:	0028      	movs	r0, r5
    1e86:	4b11      	ldr	r3, [pc, #68]	; (1ecc <vTaskResume+0x70>)
    1e88:	4798      	blx	r3
				prvAddTaskToReadyList(pxTCB);
    1e8a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    1e8c:	4a0b      	ldr	r2, [pc, #44]	; (1ebc <vTaskResume+0x60>)
    1e8e:	6d52      	ldr	r2, [r2, #84]	; 0x54
    1e90:	4293      	cmp	r3, r2
    1e92:	d901      	bls.n	1e98 <vTaskResume+0x3c>
    1e94:	4a09      	ldr	r2, [pc, #36]	; (1ebc <vTaskResume+0x60>)
    1e96:	6553      	str	r3, [r2, #84]	; 0x54
    1e98:	0098      	lsls	r0, r3, #2
    1e9a:	18c3      	adds	r3, r0, r3
    1e9c:	009b      	lsls	r3, r3, #2
    1e9e:	480c      	ldr	r0, [pc, #48]	; (1ed0 <vTaskResume+0x74>)
    1ea0:	3030      	adds	r0, #48	; 0x30
    1ea2:	18c0      	adds	r0, r0, r3
    1ea4:	0029      	movs	r1, r5
    1ea6:	4b0b      	ldr	r3, [pc, #44]	; (1ed4 <vTaskResume+0x78>)
    1ea8:	4798      	blx	r3
				if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    1eaa:	4b04      	ldr	r3, [pc, #16]	; (1ebc <vTaskResume+0x60>)
    1eac:	699b      	ldr	r3, [r3, #24]
    1eae:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    1eb0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1eb2:	429a      	cmp	r2, r3
    1eb4:	d3e0      	bcc.n	1e78 <vTaskResume+0x1c>
					taskYIELD_IF_USING_PREEMPTION();
    1eb6:	4b08      	ldr	r3, [pc, #32]	; (1ed8 <vTaskResume+0x7c>)
    1eb8:	4798      	blx	r3
    1eba:	e7dd      	b.n	1e78 <vTaskResume+0x1c>
    1ebc:	20000aac 	.word	0x20000aac
    1ec0:	00001025 	.word	0x00001025
    1ec4:	00001b59 	.word	0x00001b59
    1ec8:	0000103d 	.word	0x0000103d
    1ecc:	00000eff 	.word	0x00000eff
    1ed0:	20000a2c 	.word	0x20000a2c
    1ed4:	00000eb9 	.word	0x00000eb9
    1ed8:	0000100d 	.word	0x0000100d

00001edc <vTaskStartScheduler>:
{
    1edc:	b510      	push	{r4, lr}
    1ede:	b082      	sub	sp, #8
		xReturn = xTaskCreate(prvIdleTask,
    1ee0:	4b11      	ldr	r3, [pc, #68]	; (1f28 <vTaskStartScheduler+0x4c>)
    1ee2:	335c      	adds	r3, #92	; 0x5c
    1ee4:	9301      	str	r3, [sp, #4]
    1ee6:	2300      	movs	r3, #0
    1ee8:	9300      	str	r3, [sp, #0]
    1eea:	2240      	movs	r2, #64	; 0x40
    1eec:	490f      	ldr	r1, [pc, #60]	; (1f2c <vTaskStartScheduler+0x50>)
    1eee:	4810      	ldr	r0, [pc, #64]	; (1f30 <vTaskStartScheduler+0x54>)
    1ef0:	4c10      	ldr	r4, [pc, #64]	; (1f34 <vTaskStartScheduler+0x58>)
    1ef2:	47a0      	blx	r4
		if (xReturn == pdPASS) {
    1ef4:	2801      	cmp	r0, #1
    1ef6:	d003      	beq.n	1f00 <vTaskStartScheduler+0x24>
		configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
    1ef8:	1c43      	adds	r3, r0, #1
    1efa:	d012      	beq.n	1f22 <vTaskStartScheduler+0x46>
}
    1efc:	b002      	add	sp, #8
    1efe:	bd10      	pop	{r4, pc}
			xReturn = xTimerCreateTimerTask();
    1f00:	4b0d      	ldr	r3, [pc, #52]	; (1f38 <vTaskStartScheduler+0x5c>)
    1f02:	4798      	blx	r3
	if (xReturn == pdPASS) {
    1f04:	2801      	cmp	r0, #1
    1f06:	d1f7      	bne.n	1ef8 <vTaskStartScheduler+0x1c>
		portDISABLE_INTERRUPTS();
    1f08:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
    1f0a:	2201      	movs	r2, #1
    1f0c:	4252      	negs	r2, r2
    1f0e:	4b0b      	ldr	r3, [pc, #44]	; (1f3c <vTaskStartScheduler+0x60>)
    1f10:	62da      	str	r2, [r3, #44]	; 0x2c
		xSchedulerRunning    = pdTRUE;
    1f12:	4b05      	ldr	r3, [pc, #20]	; (1f28 <vTaskStartScheduler+0x4c>)
    1f14:	3202      	adds	r2, #2
    1f16:	64da      	str	r2, [r3, #76]	; 0x4c
		xTickCount           = (TickType_t)0U;
    1f18:	2200      	movs	r2, #0
    1f1a:	615a      	str	r2, [r3, #20]
		if (xPortStartScheduler() != pdFALSE) {
    1f1c:	4b08      	ldr	r3, [pc, #32]	; (1f40 <vTaskStartScheduler+0x64>)
    1f1e:	4798      	blx	r3
    1f20:	e7ec      	b.n	1efc <vTaskStartScheduler+0x20>
		configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
    1f22:	b672      	cpsid	i
    1f24:	e7fe      	b.n	1f24 <vTaskStartScheduler+0x48>
    1f26:	46c0      	nop			; (mov r8, r8)
    1f28:	20000aac 	.word	0x20000aac
    1f2c:	00002f48 	.word	0x00002f48
    1f30:	00001bad 	.word	0x00001bad
    1f34:	00001c35 	.word	0x00001c35
    1f38:	00002999 	.word	0x00002999
    1f3c:	20000a2c 	.word	0x20000a2c
    1f40:	00000fa9 	.word	0x00000fa9

00001f44 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
    1f44:	4a02      	ldr	r2, [pc, #8]	; (1f50 <vTaskSuspendAll+0xc>)
    1f46:	6d93      	ldr	r3, [r2, #88]	; 0x58
    1f48:	3301      	adds	r3, #1
    1f4a:	6593      	str	r3, [r2, #88]	; 0x58
}
    1f4c:	4770      	bx	lr
    1f4e:	46c0      	nop			; (mov r8, r8)
    1f50:	20000aac 	.word	0x20000aac

00001f54 <xTaskGetTickCount>:
		xTicks = xTickCount;
    1f54:	4b01      	ldr	r3, [pc, #4]	; (1f5c <xTaskGetTickCount+0x8>)
    1f56:	6958      	ldr	r0, [r3, #20]
}
    1f58:	4770      	bx	lr
    1f5a:	46c0      	nop			; (mov r8, r8)
    1f5c:	20000aac 	.word	0x20000aac

00001f60 <uxTaskGetNumberOfTasks>:
	return uxCurrentNumberOfTasks;
    1f60:	4b01      	ldr	r3, [pc, #4]	; (1f68 <uxTaskGetNumberOfTasks+0x8>)
    1f62:	6a18      	ldr	r0, [r3, #32]
}
    1f64:	4770      	bx	lr
    1f66:	46c0      	nop			; (mov r8, r8)
    1f68:	20000aac 	.word	0x20000aac

00001f6c <xTaskIncrementTick>:
{
    1f6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1f6e:	46ce      	mov	lr, r9
    1f70:	4647      	mov	r7, r8
    1f72:	b580      	push	{r7, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    1f74:	4b3b      	ldr	r3, [pc, #236]	; (2064 <STACK_SIZE+0x64>)
    1f76:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    1f78:	2b00      	cmp	r3, #0
    1f7a:	d164      	bne.n	2046 <STACK_SIZE+0x46>
		const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
    1f7c:	4b39      	ldr	r3, [pc, #228]	; (2064 <STACK_SIZE+0x64>)
    1f7e:	695e      	ldr	r6, [r3, #20]
    1f80:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
    1f82:	615e      	str	r6, [r3, #20]
		if (xConstTickCount
    1f84:	2e00      	cmp	r6, #0
    1f86:	d111      	bne.n	1fac <xTaskIncrementTick+0x40>
			taskSWITCH_DELAYED_LISTS();
    1f88:	4b37      	ldr	r3, [pc, #220]	; (2068 <STACK_SIZE+0x68>)
    1f8a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1f8c:	681b      	ldr	r3, [r3, #0]
    1f8e:	2b00      	cmp	r3, #0
    1f90:	d001      	beq.n	1f96 <xTaskIncrementTick+0x2a>
    1f92:	b672      	cpsid	i
    1f94:	e7fe      	b.n	1f94 <xTaskIncrementTick+0x28>
    1f96:	4a34      	ldr	r2, [pc, #208]	; (2068 <STACK_SIZE+0x68>)
    1f98:	6a91      	ldr	r1, [r2, #40]	; 0x28
    1f9a:	4b32      	ldr	r3, [pc, #200]	; (2064 <STACK_SIZE+0x64>)
    1f9c:	69d8      	ldr	r0, [r3, #28]
    1f9e:	6290      	str	r0, [r2, #40]	; 0x28
    1fa0:	61d9      	str	r1, [r3, #28]
    1fa2:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    1fa4:	3201      	adds	r2, #1
    1fa6:	661a      	str	r2, [r3, #96]	; 0x60
    1fa8:	4b30      	ldr	r3, [pc, #192]	; (206c <STACK_SIZE+0x6c>)
    1faa:	4798      	blx	r3
		if (xConstTickCount >= xNextTaskUnblockTime) {
    1fac:	4b2e      	ldr	r3, [pc, #184]	; (2068 <STACK_SIZE+0x68>)
    1fae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	BaseType_t xSwitchRequired = pdFALSE;
    1fb0:	2400      	movs	r4, #0
		if (xConstTickCount >= xNextTaskUnblockTime) {
    1fb2:	429e      	cmp	r6, r3
    1fb4:	d337      	bcc.n	2026 <STACK_SIZE+0x26>
    1fb6:	2400      	movs	r4, #0
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    1fb8:	4b2b      	ldr	r3, [pc, #172]	; (2068 <STACK_SIZE+0x68>)
    1fba:	4699      	mov	r9, r3
					prvAddTaskToReadyList(pxTCB);
    1fbc:	2230      	movs	r2, #48	; 0x30
    1fbe:	4694      	mov	ip, r2
    1fc0:	4463      	add	r3, ip
    1fc2:	4698      	mov	r8, r3
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    1fc4:	464b      	mov	r3, r9
    1fc6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1fc8:	681b      	ldr	r3, [r3, #0]
    1fca:	2b00      	cmp	r3, #0
    1fcc:	d027      	beq.n	201e <STACK_SIZE+0x1e>
					pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    1fce:	4b26      	ldr	r3, [pc, #152]	; (2068 <STACK_SIZE+0x68>)
    1fd0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1fd2:	68db      	ldr	r3, [r3, #12]
    1fd4:	68df      	ldr	r7, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
    1fd6:	687b      	ldr	r3, [r7, #4]
					if (xConstTickCount < xItemValue) {
    1fd8:	429e      	cmp	r6, r3
    1fda:	d331      	bcc.n	2040 <STACK_SIZE+0x40>
					(void)uxListRemove(&(pxTCB->xStateListItem));
    1fdc:	1d3d      	adds	r5, r7, #4
    1fde:	0028      	movs	r0, r5
    1fe0:	4b23      	ldr	r3, [pc, #140]	; (2070 <STACK_SIZE+0x70>)
    1fe2:	4798      	blx	r3
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
    1fe4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1fe6:	2b00      	cmp	r3, #0
    1fe8:	d003      	beq.n	1ff2 <xTaskIncrementTick+0x86>
						(void)uxListRemove(&(pxTCB->xEventListItem));
    1fea:	0038      	movs	r0, r7
    1fec:	3018      	adds	r0, #24
    1fee:	4b20      	ldr	r3, [pc, #128]	; (2070 <STACK_SIZE+0x70>)
    1ff0:	4798      	blx	r3
					prvAddTaskToReadyList(pxTCB);
    1ff2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1ff4:	4a1b      	ldr	r2, [pc, #108]	; (2064 <STACK_SIZE+0x64>)
    1ff6:	6d52      	ldr	r2, [r2, #84]	; 0x54
    1ff8:	4293      	cmp	r3, r2
    1ffa:	d901      	bls.n	2000 <STACK_SIZE>
    1ffc:	4a19      	ldr	r2, [pc, #100]	; (2064 <STACK_SIZE+0x64>)
    1ffe:	6553      	str	r3, [r2, #84]	; 0x54
    2000:	0098      	lsls	r0, r3, #2
    2002:	18c0      	adds	r0, r0, r3
    2004:	0080      	lsls	r0, r0, #2
    2006:	4440      	add	r0, r8
    2008:	0029      	movs	r1, r5
    200a:	4b1a      	ldr	r3, [pc, #104]	; (2074 <STACK_SIZE+0x74>)
    200c:	4798      	blx	r3
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    200e:	4b15      	ldr	r3, [pc, #84]	; (2064 <STACK_SIZE+0x64>)
    2010:	699b      	ldr	r3, [r3, #24]
    2012:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    2014:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2016:	429a      	cmp	r2, r3
    2018:	d3d4      	bcc.n	1fc4 <xTaskIncrementTick+0x58>
							xSwitchRequired = pdTRUE;
    201a:	2401      	movs	r4, #1
    201c:	e7d2      	b.n	1fc4 <xTaskIncrementTick+0x58>
					    = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    201e:	2201      	movs	r2, #1
    2020:	4252      	negs	r2, r2
    2022:	4b11      	ldr	r3, [pc, #68]	; (2068 <STACK_SIZE+0x68>)
    2024:	62da      	str	r2, [r3, #44]	; 0x2c
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
    2026:	4b0f      	ldr	r3, [pc, #60]	; (2064 <STACK_SIZE+0x64>)
    2028:	699b      	ldr	r3, [r3, #24]
    202a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    202c:	0093      	lsls	r3, r2, #2
    202e:	189b      	adds	r3, r3, r2
    2030:	009b      	lsls	r3, r3, #2
    2032:	4a0d      	ldr	r2, [pc, #52]	; (2068 <STACK_SIZE+0x68>)
    2034:	18d3      	adds	r3, r2, r3
    2036:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    2038:	2b01      	cmp	r3, #1
    203a:	d909      	bls.n	2050 <STACK_SIZE+0x50>
				xSwitchRequired = pdTRUE;
    203c:	2401      	movs	r4, #1
    203e:	e007      	b.n	2050 <STACK_SIZE+0x50>
						xNextTaskUnblockTime = xItemValue;
    2040:	4a09      	ldr	r2, [pc, #36]	; (2068 <STACK_SIZE+0x68>)
    2042:	62d3      	str	r3, [r2, #44]	; 0x2c
						break;
    2044:	e7ef      	b.n	2026 <STACK_SIZE+0x26>
		++uxPendedTicks;
    2046:	4a07      	ldr	r2, [pc, #28]	; (2064 <STACK_SIZE+0x64>)
    2048:	6e53      	ldr	r3, [r2, #100]	; 0x64
    204a:	3301      	adds	r3, #1
    204c:	6653      	str	r3, [r2, #100]	; 0x64
	BaseType_t xSwitchRequired = pdFALSE;
    204e:	2400      	movs	r4, #0
		if (xYieldPending != pdFALSE) {
    2050:	4b04      	ldr	r3, [pc, #16]	; (2064 <STACK_SIZE+0x64>)
    2052:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    2054:	2b00      	cmp	r3, #0
    2056:	d000      	beq.n	205a <STACK_SIZE+0x5a>
			xSwitchRequired = pdTRUE;
    2058:	2401      	movs	r4, #1
}
    205a:	0020      	movs	r0, r4
    205c:	bc0c      	pop	{r2, r3}
    205e:	4690      	mov	r8, r2
    2060:	4699      	mov	r9, r3
    2062:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2064:	20000aac 	.word	0x20000aac
    2068:	20000a2c 	.word	0x20000a2c
    206c:	00001b85 	.word	0x00001b85
    2070:	00000eff 	.word	0x00000eff
    2074:	00000eb9 	.word	0x00000eb9

00002078 <xTaskResumeAll>:
{
    2078:	b5f0      	push	{r4, r5, r6, r7, lr}
    207a:	b083      	sub	sp, #12
	configASSERT(uxSchedulerSuspended);
    207c:	4b31      	ldr	r3, [pc, #196]	; (2144 <xTaskResumeAll+0xcc>)
    207e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    2080:	2b00      	cmp	r3, #0
    2082:	d101      	bne.n	2088 <xTaskResumeAll+0x10>
    2084:	b672      	cpsid	i
    2086:	e7fe      	b.n	2086 <xTaskResumeAll+0xe>
	taskENTER_CRITICAL();
    2088:	4b2f      	ldr	r3, [pc, #188]	; (2148 <xTaskResumeAll+0xd0>)
    208a:	4798      	blx	r3
		--uxSchedulerSuspended;
    208c:	4b2d      	ldr	r3, [pc, #180]	; (2144 <xTaskResumeAll+0xcc>)
    208e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    2090:	3a01      	subs	r2, #1
    2092:	659a      	str	r2, [r3, #88]	; 0x58
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    2094:	6d9b      	ldr	r3, [r3, #88]	; 0x58
	BaseType_t xAlreadyYielded = pdFALSE;
    2096:	2400      	movs	r4, #0
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    2098:	2b00      	cmp	r3, #0
    209a:	d104      	bne.n	20a6 <xTaskResumeAll+0x2e>
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
    209c:	4b29      	ldr	r3, [pc, #164]	; (2144 <xTaskResumeAll+0xcc>)
    209e:	6a1b      	ldr	r3, [r3, #32]
    20a0:	2500      	movs	r5, #0
    20a2:	2b00      	cmp	r3, #0
    20a4:	d104      	bne.n	20b0 <xTaskResumeAll+0x38>
	taskEXIT_CRITICAL();
    20a6:	4b29      	ldr	r3, [pc, #164]	; (214c <xTaskResumeAll+0xd4>)
    20a8:	4798      	blx	r3
}
    20aa:	0020      	movs	r0, r4
    20ac:	b003      	add	sp, #12
    20ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
    20b0:	4f27      	ldr	r7, [pc, #156]	; (2150 <xTaskResumeAll+0xd8>)
					prvAddTaskToReadyList(pxTCB);
    20b2:	003e      	movs	r6, r7
    20b4:	3630      	adds	r6, #48	; 0x30
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
    20b6:	697b      	ldr	r3, [r7, #20]
    20b8:	2b00      	cmp	r3, #0
    20ba:	d022      	beq.n	2102 <xTaskResumeAll+0x8a>
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
    20bc:	4b24      	ldr	r3, [pc, #144]	; (2150 <xTaskResumeAll+0xd8>)
    20be:	6a1b      	ldr	r3, [r3, #32]
    20c0:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xEventListItem));
    20c2:	0028      	movs	r0, r5
    20c4:	3018      	adds	r0, #24
    20c6:	4c23      	ldr	r4, [pc, #140]	; (2154 <xTaskResumeAll+0xdc>)
    20c8:	47a0      	blx	r4
					(void)uxListRemove(&(pxTCB->xStateListItem));
    20ca:	1d2b      	adds	r3, r5, #4
    20cc:	9301      	str	r3, [sp, #4]
    20ce:	0018      	movs	r0, r3
    20d0:	47a0      	blx	r4
					prvAddTaskToReadyList(pxTCB);
    20d2:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    20d4:	4a1b      	ldr	r2, [pc, #108]	; (2144 <xTaskResumeAll+0xcc>)
    20d6:	6d52      	ldr	r2, [r2, #84]	; 0x54
    20d8:	4293      	cmp	r3, r2
    20da:	d901      	bls.n	20e0 <xTaskResumeAll+0x68>
    20dc:	4a19      	ldr	r2, [pc, #100]	; (2144 <xTaskResumeAll+0xcc>)
    20de:	6553      	str	r3, [r2, #84]	; 0x54
    20e0:	0098      	lsls	r0, r3, #2
    20e2:	18c0      	adds	r0, r0, r3
    20e4:	0080      	lsls	r0, r0, #2
    20e6:	1830      	adds	r0, r6, r0
    20e8:	9901      	ldr	r1, [sp, #4]
    20ea:	4b1b      	ldr	r3, [pc, #108]	; (2158 <xTaskResumeAll+0xe0>)
    20ec:	4798      	blx	r3
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    20ee:	4b15      	ldr	r3, [pc, #84]	; (2144 <xTaskResumeAll+0xcc>)
    20f0:	699b      	ldr	r3, [r3, #24]
    20f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    20f4:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    20f6:	429a      	cmp	r2, r3
    20f8:	d3dd      	bcc.n	20b6 <xTaskResumeAll+0x3e>
						xYieldPending = pdTRUE;
    20fa:	2201      	movs	r2, #1
    20fc:	4b11      	ldr	r3, [pc, #68]	; (2144 <xTaskResumeAll+0xcc>)
    20fe:	669a      	str	r2, [r3, #104]	; 0x68
    2100:	e7d9      	b.n	20b6 <xTaskResumeAll+0x3e>
				if (pxTCB != NULL) {
    2102:	2d00      	cmp	r5, #0
    2104:	d001      	beq.n	210a <xTaskResumeAll+0x92>
					prvResetNextTaskUnblockTime();
    2106:	4b15      	ldr	r3, [pc, #84]	; (215c <xTaskResumeAll+0xe4>)
    2108:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    210a:	4b0e      	ldr	r3, [pc, #56]	; (2144 <xTaskResumeAll+0xcc>)
    210c:	6e5c      	ldr	r4, [r3, #100]	; 0x64
					if (uxPendedCounts > (UBaseType_t)0U) {
    210e:	2c00      	cmp	r4, #0
    2110:	d00e      	beq.n	2130 <xTaskResumeAll+0xb8>
							if (xTaskIncrementTick() != pdFALSE) {
    2112:	4f13      	ldr	r7, [pc, #76]	; (2160 <xTaskResumeAll+0xe8>)
								xYieldPending = pdTRUE;
    2114:	001e      	movs	r6, r3
    2116:	2501      	movs	r5, #1
    2118:	e002      	b.n	2120 <xTaskResumeAll+0xa8>
							--uxPendedCounts;
    211a:	3c01      	subs	r4, #1
						} while (uxPendedCounts > (UBaseType_t)0U);
    211c:	2c00      	cmp	r4, #0
    211e:	d004      	beq.n	212a <xTaskResumeAll+0xb2>
							if (xTaskIncrementTick() != pdFALSE) {
    2120:	47b8      	blx	r7
    2122:	2800      	cmp	r0, #0
    2124:	d0f9      	beq.n	211a <xTaskResumeAll+0xa2>
								xYieldPending = pdTRUE;
    2126:	66b5      	str	r5, [r6, #104]	; 0x68
    2128:	e7f7      	b.n	211a <xTaskResumeAll+0xa2>
						uxPendedTicks = 0;
    212a:	2200      	movs	r2, #0
    212c:	4b05      	ldr	r3, [pc, #20]	; (2144 <xTaskResumeAll+0xcc>)
    212e:	665a      	str	r2, [r3, #100]	; 0x64
				if (xYieldPending != pdFALSE) {
    2130:	4b04      	ldr	r3, [pc, #16]	; (2144 <xTaskResumeAll+0xcc>)
    2132:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	BaseType_t xAlreadyYielded = pdFALSE;
    2134:	2400      	movs	r4, #0
				if (xYieldPending != pdFALSE) {
    2136:	2b00      	cmp	r3, #0
    2138:	d0b5      	beq.n	20a6 <xTaskResumeAll+0x2e>
					taskYIELD_IF_USING_PREEMPTION();
    213a:	4b0a      	ldr	r3, [pc, #40]	; (2164 <xTaskResumeAll+0xec>)
    213c:	4798      	blx	r3
						xAlreadyYielded = pdTRUE;
    213e:	3401      	adds	r4, #1
    2140:	e7b1      	b.n	20a6 <xTaskResumeAll+0x2e>
    2142:	46c0      	nop			; (mov r8, r8)
    2144:	20000aac 	.word	0x20000aac
    2148:	00001025 	.word	0x00001025
    214c:	0000103d 	.word	0x0000103d
    2150:	20000a2c 	.word	0x20000a2c
    2154:	00000eff 	.word	0x00000eff
    2158:	00000eb9 	.word	0x00000eb9
    215c:	00001b85 	.word	0x00001b85
    2160:	00001f6d 	.word	0x00001f6d
    2164:	0000100d 	.word	0x0000100d

00002168 <vTaskDelay>:
{
    2168:	b510      	push	{r4, lr}
    216a:	1e04      	subs	r4, r0, #0
	if (xTicksToDelay > (TickType_t)0U) {
    216c:	d00f      	beq.n	218e <vTaskDelay+0x26>
		configASSERT(uxSchedulerSuspended == 0);
    216e:	4b09      	ldr	r3, [pc, #36]	; (2194 <vTaskDelay+0x2c>)
    2170:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    2172:	2b00      	cmp	r3, #0
    2174:	d001      	beq.n	217a <vTaskDelay+0x12>
    2176:	b672      	cpsid	i
    2178:	e7fe      	b.n	2178 <vTaskDelay+0x10>
		vTaskSuspendAll();
    217a:	4b07      	ldr	r3, [pc, #28]	; (2198 <vTaskDelay+0x30>)
    217c:	4798      	blx	r3
			prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
    217e:	2100      	movs	r1, #0
    2180:	0020      	movs	r0, r4
    2182:	4b06      	ldr	r3, [pc, #24]	; (219c <vTaskDelay+0x34>)
    2184:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
    2186:	4b06      	ldr	r3, [pc, #24]	; (21a0 <vTaskDelay+0x38>)
    2188:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
    218a:	2800      	cmp	r0, #0
    218c:	d101      	bne.n	2192 <vTaskDelay+0x2a>
		portYIELD_WITHIN_API();
    218e:	4b05      	ldr	r3, [pc, #20]	; (21a4 <vTaskDelay+0x3c>)
    2190:	4798      	blx	r3
}
    2192:	bd10      	pop	{r4, pc}
    2194:	20000aac 	.word	0x20000aac
    2198:	00001f45 	.word	0x00001f45
    219c:	00001bc5 	.word	0x00001bc5
    21a0:	00002079 	.word	0x00002079
    21a4:	0000100d 	.word	0x0000100d

000021a8 <vTaskSwitchContext>:
{
    21a8:	b510      	push	{r4, lr}
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    21aa:	4b20      	ldr	r3, [pc, #128]	; (222c <vTaskSwitchContext+0x84>)
    21ac:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    21ae:	2b00      	cmp	r3, #0
    21b0:	d119      	bne.n	21e6 <vTaskSwitchContext+0x3e>
		xYieldPending = pdFALSE;
    21b2:	4b1e      	ldr	r3, [pc, #120]	; (222c <vTaskSwitchContext+0x84>)
    21b4:	2200      	movs	r2, #0
    21b6:	669a      	str	r2, [r3, #104]	; 0x68
		taskSELECT_HIGHEST_PRIORITY_TASK();
    21b8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    21ba:	009a      	lsls	r2, r3, #2
    21bc:	18d2      	adds	r2, r2, r3
    21be:	0092      	lsls	r2, r2, #2
    21c0:	491b      	ldr	r1, [pc, #108]	; (2230 <vTaskSwitchContext+0x88>)
    21c2:	188a      	adds	r2, r1, r2
    21c4:	6b12      	ldr	r2, [r2, #48]	; 0x30
    21c6:	2a00      	cmp	r2, #0
    21c8:	d111      	bne.n	21ee <vTaskSwitchContext+0x46>
    21ca:	2b00      	cmp	r3, #0
    21cc:	d009      	beq.n	21e2 <vTaskSwitchContext+0x3a>
    21ce:	3b01      	subs	r3, #1
    21d0:	009a      	lsls	r2, r3, #2
    21d2:	18d2      	adds	r2, r2, r3
    21d4:	0092      	lsls	r2, r2, #2
    21d6:	188a      	adds	r2, r1, r2
    21d8:	6b12      	ldr	r2, [r2, #48]	; 0x30
    21da:	2a00      	cmp	r2, #0
    21dc:	d107      	bne.n	21ee <vTaskSwitchContext+0x46>
    21de:	2b00      	cmp	r3, #0
    21e0:	d1f5      	bne.n	21ce <vTaskSwitchContext+0x26>
    21e2:	b672      	cpsid	i
    21e4:	e7fe      	b.n	21e4 <vTaskSwitchContext+0x3c>
		xYieldPending = pdTRUE;
    21e6:	2201      	movs	r2, #1
    21e8:	4b10      	ldr	r3, [pc, #64]	; (222c <vTaskSwitchContext+0x84>)
    21ea:	669a      	str	r2, [r3, #104]	; 0x68
}
    21ec:	bd10      	pop	{r4, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK();
    21ee:	4a10      	ldr	r2, [pc, #64]	; (2230 <vTaskSwitchContext+0x88>)
    21f0:	0099      	lsls	r1, r3, #2
    21f2:	18c8      	adds	r0, r1, r3
    21f4:	0080      	lsls	r0, r0, #2
    21f6:	1810      	adds	r0, r2, r0
    21f8:	6b44      	ldr	r4, [r0, #52]	; 0x34
    21fa:	6864      	ldr	r4, [r4, #4]
    21fc:	6344      	str	r4, [r0, #52]	; 0x34
    21fe:	18c9      	adds	r1, r1, r3
    2200:	0089      	lsls	r1, r1, #2
    2202:	0002      	movs	r2, r0
    2204:	3238      	adds	r2, #56	; 0x38
    2206:	4294      	cmp	r4, r2
    2208:	d00a      	beq.n	2220 <vTaskSwitchContext+0x78>
    220a:	009a      	lsls	r2, r3, #2
    220c:	18d2      	adds	r2, r2, r3
    220e:	0092      	lsls	r2, r2, #2
    2210:	4907      	ldr	r1, [pc, #28]	; (2230 <vTaskSwitchContext+0x88>)
    2212:	188a      	adds	r2, r1, r2
    2214:	6b52      	ldr	r2, [r2, #52]	; 0x34
    2216:	68d1      	ldr	r1, [r2, #12]
    2218:	4a04      	ldr	r2, [pc, #16]	; (222c <vTaskSwitchContext+0x84>)
    221a:	6191      	str	r1, [r2, #24]
    221c:	6553      	str	r3, [r2, #84]	; 0x54
}
    221e:	e7e5      	b.n	21ec <vTaskSwitchContext+0x44>
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2220:	6860      	ldr	r0, [r4, #4]
    2222:	000a      	movs	r2, r1
    2224:	4902      	ldr	r1, [pc, #8]	; (2230 <vTaskSwitchContext+0x88>)
    2226:	188a      	adds	r2, r1, r2
    2228:	6350      	str	r0, [r2, #52]	; 0x34
    222a:	e7ee      	b.n	220a <vTaskSwitchContext+0x62>
    222c:	20000aac 	.word	0x20000aac
    2230:	20000a2c 	.word	0x20000a2c

00002234 <vTaskSuspend>:
{
    2234:	b570      	push	{r4, r5, r6, lr}
    2236:	0005      	movs	r5, r0
	taskENTER_CRITICAL();
    2238:	4b24      	ldr	r3, [pc, #144]	; (22cc <vTaskSuspend+0x98>)
    223a:	4798      	blx	r3
		pxTCB = prvGetTCBFromHandle(xTaskToSuspend);
    223c:	1e2c      	subs	r4, r5, #0
    223e:	d01d      	beq.n	227c <vTaskSuspend+0x48>
		if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
    2240:	1d25      	adds	r5, r4, #4
    2242:	0028      	movs	r0, r5
    2244:	4b22      	ldr	r3, [pc, #136]	; (22d0 <vTaskSuspend+0x9c>)
    2246:	4798      	blx	r3
		if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
    2248:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    224a:	2b00      	cmp	r3, #0
    224c:	d003      	beq.n	2256 <vTaskSuspend+0x22>
			(void)uxListRemove(&(pxTCB->xEventListItem));
    224e:	0020      	movs	r0, r4
    2250:	3018      	adds	r0, #24
    2252:	4b1f      	ldr	r3, [pc, #124]	; (22d0 <vTaskSuspend+0x9c>)
    2254:	4798      	blx	r3
		vListInsertEnd(&xSuspendedTaskList, &(pxTCB->xStateListItem));
    2256:	0029      	movs	r1, r5
    2258:	481e      	ldr	r0, [pc, #120]	; (22d4 <vTaskSuspend+0xa0>)
    225a:	4b1f      	ldr	r3, [pc, #124]	; (22d8 <vTaskSuspend+0xa4>)
    225c:	4798      	blx	r3
			if (pxTCB->ucNotifyState == taskWAITING_NOTIFICATION) {
    225e:	2350      	movs	r3, #80	; 0x50
    2260:	5ce3      	ldrb	r3, [r4, r3]
    2262:	2b01      	cmp	r3, #1
    2264:	d00d      	beq.n	2282 <vTaskSuspend+0x4e>
	taskEXIT_CRITICAL();
    2266:	4b1d      	ldr	r3, [pc, #116]	; (22dc <vTaskSuspend+0xa8>)
    2268:	4798      	blx	r3
	if (xSchedulerRunning != pdFALSE) {
    226a:	4b1d      	ldr	r3, [pc, #116]	; (22e0 <vTaskSuspend+0xac>)
    226c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    226e:	2b00      	cmp	r3, #0
    2270:	d10b      	bne.n	228a <vTaskSuspend+0x56>
	if (pxTCB == pxCurrentTCB) {
    2272:	4b1b      	ldr	r3, [pc, #108]	; (22e0 <vTaskSuspend+0xac>)
    2274:	699b      	ldr	r3, [r3, #24]
    2276:	429c      	cmp	r4, r3
    2278:	d00e      	beq.n	2298 <vTaskSuspend+0x64>
}
    227a:	bd70      	pop	{r4, r5, r6, pc}
		pxTCB = prvGetTCBFromHandle(xTaskToSuspend);
    227c:	4b18      	ldr	r3, [pc, #96]	; (22e0 <vTaskSuspend+0xac>)
    227e:	699c      	ldr	r4, [r3, #24]
    2280:	e7de      	b.n	2240 <vTaskSuspend+0xc>
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2282:	2200      	movs	r2, #0
    2284:	334f      	adds	r3, #79	; 0x4f
    2286:	54e2      	strb	r2, [r4, r3]
    2288:	e7ed      	b.n	2266 <vTaskSuspend+0x32>
		taskENTER_CRITICAL();
    228a:	4b10      	ldr	r3, [pc, #64]	; (22cc <vTaskSuspend+0x98>)
    228c:	4798      	blx	r3
			prvResetNextTaskUnblockTime();
    228e:	4b15      	ldr	r3, [pc, #84]	; (22e4 <vTaskSuspend+0xb0>)
    2290:	4798      	blx	r3
		taskEXIT_CRITICAL();
    2292:	4b12      	ldr	r3, [pc, #72]	; (22dc <vTaskSuspend+0xa8>)
    2294:	4798      	blx	r3
    2296:	e7ec      	b.n	2272 <vTaskSuspend+0x3e>
		if (xSchedulerRunning != pdFALSE) {
    2298:	4b11      	ldr	r3, [pc, #68]	; (22e0 <vTaskSuspend+0xac>)
    229a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    229c:	2b00      	cmp	r3, #0
    229e:	d008      	beq.n	22b2 <vTaskSuspend+0x7e>
			configASSERT(uxSchedulerSuspended == 0);
    22a0:	4b0f      	ldr	r3, [pc, #60]	; (22e0 <vTaskSuspend+0xac>)
    22a2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    22a4:	2b00      	cmp	r3, #0
    22a6:	d001      	beq.n	22ac <vTaskSuspend+0x78>
    22a8:	b672      	cpsid	i
    22aa:	e7fe      	b.n	22aa <vTaskSuspend+0x76>
			portYIELD_WITHIN_API();
    22ac:	4b0e      	ldr	r3, [pc, #56]	; (22e8 <vTaskSuspend+0xb4>)
    22ae:	4798      	blx	r3
    22b0:	e7e3      	b.n	227a <vTaskSuspend+0x46>
			if (listCURRENT_LIST_LENGTH(&xSuspendedTaskList) == uxCurrentNumberOfTasks) {
    22b2:	4b08      	ldr	r3, [pc, #32]	; (22d4 <vTaskSuspend+0xa0>)
    22b4:	681a      	ldr	r2, [r3, #0]
    22b6:	4b0a      	ldr	r3, [pc, #40]	; (22e0 <vTaskSuspend+0xac>)
    22b8:	6a1b      	ldr	r3, [r3, #32]
    22ba:	429a      	cmp	r2, r3
    22bc:	d002      	beq.n	22c4 <vTaskSuspend+0x90>
				vTaskSwitchContext();
    22be:	4b0b      	ldr	r3, [pc, #44]	; (22ec <vTaskSuspend+0xb8>)
    22c0:	4798      	blx	r3
}
    22c2:	e7da      	b.n	227a <vTaskSuspend+0x46>
				pxCurrentTCB = NULL;
    22c4:	2200      	movs	r2, #0
    22c6:	4b06      	ldr	r3, [pc, #24]	; (22e0 <vTaskSuspend+0xac>)
    22c8:	619a      	str	r2, [r3, #24]
    22ca:	e7d6      	b.n	227a <vTaskSuspend+0x46>
    22cc:	00001025 	.word	0x00001025
    22d0:	00000eff 	.word	0x00000eff
    22d4:	20000a2c 	.word	0x20000a2c
    22d8:	00000eb9 	.word	0x00000eb9
    22dc:	0000103d 	.word	0x0000103d
    22e0:	20000aac 	.word	0x20000aac
    22e4:	00001b85 	.word	0x00001b85
    22e8:	0000100d 	.word	0x0000100d
    22ec:	000021a9 	.word	0x000021a9

000022f0 <vTaskPlaceOnEventList>:
{
    22f0:	b510      	push	{r4, lr}
    22f2:	000c      	movs	r4, r1
	configASSERT(pxEventList);
    22f4:	2800      	cmp	r0, #0
    22f6:	d101      	bne.n	22fc <vTaskPlaceOnEventList+0xc>
    22f8:	b672      	cpsid	i
    22fa:	e7fe      	b.n	22fa <vTaskPlaceOnEventList+0xa>
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
    22fc:	4b04      	ldr	r3, [pc, #16]	; (2310 <vTaskPlaceOnEventList+0x20>)
    22fe:	6999      	ldr	r1, [r3, #24]
    2300:	3118      	adds	r1, #24
    2302:	4b04      	ldr	r3, [pc, #16]	; (2314 <vTaskPlaceOnEventList+0x24>)
    2304:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
    2306:	2101      	movs	r1, #1
    2308:	0020      	movs	r0, r4
    230a:	4b03      	ldr	r3, [pc, #12]	; (2318 <vTaskPlaceOnEventList+0x28>)
    230c:	4798      	blx	r3
}
    230e:	bd10      	pop	{r4, pc}
    2310:	20000aac 	.word	0x20000aac
    2314:	00000ed1 	.word	0x00000ed1
    2318:	00001bc5 	.word	0x00001bc5

0000231c <vTaskPlaceOnEventListRestricted>:
{
    231c:	b570      	push	{r4, r5, r6, lr}
    231e:	000c      	movs	r4, r1
    2320:	0015      	movs	r5, r2
	configASSERT(pxEventList);
    2322:	2800      	cmp	r0, #0
    2324:	d00d      	beq.n	2342 <vTaskPlaceOnEventListRestricted+0x26>
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
    2326:	4b08      	ldr	r3, [pc, #32]	; (2348 <vTaskPlaceOnEventListRestricted+0x2c>)
    2328:	6999      	ldr	r1, [r3, #24]
    232a:	3118      	adds	r1, #24
    232c:	4b07      	ldr	r3, [pc, #28]	; (234c <vTaskPlaceOnEventListRestricted+0x30>)
    232e:	4798      	blx	r3
	if (xWaitIndefinitely != pdFALSE) {
    2330:	2d00      	cmp	r5, #0
    2332:	d001      	beq.n	2338 <vTaskPlaceOnEventListRestricted+0x1c>
		xTicksToWait = portMAX_DELAY;
    2334:	2401      	movs	r4, #1
    2336:	4264      	negs	r4, r4
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
    2338:	0029      	movs	r1, r5
    233a:	0020      	movs	r0, r4
    233c:	4b04      	ldr	r3, [pc, #16]	; (2350 <vTaskPlaceOnEventListRestricted+0x34>)
    233e:	4798      	blx	r3
}
    2340:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(pxEventList);
    2342:	b672      	cpsid	i
    2344:	e7fe      	b.n	2344 <vTaskPlaceOnEventListRestricted+0x28>
    2346:	46c0      	nop			; (mov r8, r8)
    2348:	20000aac 	.word	0x20000aac
    234c:	00000eb9 	.word	0x00000eb9
    2350:	00001bc5 	.word	0x00001bc5

00002354 <xTaskRemoveFromEventList>:
{
    2354:	b570      	push	{r4, r5, r6, lr}
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
    2356:	68c3      	ldr	r3, [r0, #12]
    2358:	68dc      	ldr	r4, [r3, #12]
	configASSERT(pxUnblockedTCB);
    235a:	2c00      	cmp	r4, #0
    235c:	d028      	beq.n	23b0 <xTaskRemoveFromEventList+0x5c>
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
    235e:	0025      	movs	r5, r4
    2360:	3518      	adds	r5, #24
    2362:	0028      	movs	r0, r5
    2364:	4b16      	ldr	r3, [pc, #88]	; (23c0 <xTaskRemoveFromEventList+0x6c>)
    2366:	4798      	blx	r3
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    2368:	4b16      	ldr	r3, [pc, #88]	; (23c4 <xTaskRemoveFromEventList+0x70>)
    236a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    236c:	2b00      	cmp	r3, #0
    236e:	d121      	bne.n	23b4 <xTaskRemoveFromEventList+0x60>
		(void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
    2370:	1d25      	adds	r5, r4, #4
    2372:	0028      	movs	r0, r5
    2374:	4b12      	ldr	r3, [pc, #72]	; (23c0 <xTaskRemoveFromEventList+0x6c>)
    2376:	4798      	blx	r3
		prvAddTaskToReadyList(pxUnblockedTCB);
    2378:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    237a:	4a12      	ldr	r2, [pc, #72]	; (23c4 <xTaskRemoveFromEventList+0x70>)
    237c:	6d52      	ldr	r2, [r2, #84]	; 0x54
    237e:	4293      	cmp	r3, r2
    2380:	d901      	bls.n	2386 <xTaskRemoveFromEventList+0x32>
    2382:	4a10      	ldr	r2, [pc, #64]	; (23c4 <xTaskRemoveFromEventList+0x70>)
    2384:	6553      	str	r3, [r2, #84]	; 0x54
    2386:	0098      	lsls	r0, r3, #2
    2388:	18c3      	adds	r3, r0, r3
    238a:	009b      	lsls	r3, r3, #2
    238c:	480e      	ldr	r0, [pc, #56]	; (23c8 <xTaskRemoveFromEventList+0x74>)
    238e:	3030      	adds	r0, #48	; 0x30
    2390:	18c0      	adds	r0, r0, r3
    2392:	0029      	movs	r1, r5
    2394:	4b0d      	ldr	r3, [pc, #52]	; (23cc <xTaskRemoveFromEventList+0x78>)
    2396:	4798      	blx	r3
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
    2398:	4b0a      	ldr	r3, [pc, #40]	; (23c4 <xTaskRemoveFromEventList+0x70>)
    239a:	699b      	ldr	r3, [r3, #24]
    239c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    239e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		xReturn = pdFALSE;
    23a0:	2000      	movs	r0, #0
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
    23a2:	429a      	cmp	r2, r3
    23a4:	d903      	bls.n	23ae <xTaskRemoveFromEventList+0x5a>
		xYieldPending = pdTRUE;
    23a6:	2201      	movs	r2, #1
    23a8:	4b06      	ldr	r3, [pc, #24]	; (23c4 <xTaskRemoveFromEventList+0x70>)
    23aa:	669a      	str	r2, [r3, #104]	; 0x68
		xReturn = pdTRUE;
    23ac:	3001      	adds	r0, #1
}
    23ae:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(pxUnblockedTCB);
    23b0:	b672      	cpsid	i
    23b2:	e7fe      	b.n	23b2 <xTaskRemoveFromEventList+0x5e>
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
    23b4:	0029      	movs	r1, r5
    23b6:	4804      	ldr	r0, [pc, #16]	; (23c8 <xTaskRemoveFromEventList+0x74>)
    23b8:	3014      	adds	r0, #20
    23ba:	4b04      	ldr	r3, [pc, #16]	; (23cc <xTaskRemoveFromEventList+0x78>)
    23bc:	4798      	blx	r3
    23be:	e7eb      	b.n	2398 <xTaskRemoveFromEventList+0x44>
    23c0:	00000eff 	.word	0x00000eff
    23c4:	20000aac 	.word	0x20000aac
    23c8:	20000a2c 	.word	0x20000a2c
    23cc:	00000eb9 	.word	0x00000eb9

000023d0 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
    23d0:	4b02      	ldr	r3, [pc, #8]	; (23dc <vTaskInternalSetTimeOutState+0xc>)
    23d2:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    23d4:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    23d6:	695b      	ldr	r3, [r3, #20]
    23d8:	6043      	str	r3, [r0, #4]
}
    23da:	4770      	bx	lr
    23dc:	20000aac 	.word	0x20000aac

000023e0 <xTaskCheckForTimeOut>:
{
    23e0:	b570      	push	{r4, r5, r6, lr}
    23e2:	0006      	movs	r6, r0
    23e4:	000d      	movs	r5, r1
	configASSERT(pxTimeOut);
    23e6:	2800      	cmp	r0, #0
    23e8:	d01b      	beq.n	2422 <xTaskCheckForTimeOut+0x42>
	configASSERT(pxTicksToWait);
    23ea:	2900      	cmp	r1, #0
    23ec:	d01b      	beq.n	2426 <xTaskCheckForTimeOut+0x46>
	taskENTER_CRITICAL();
    23ee:	4b13      	ldr	r3, [pc, #76]	; (243c <xTaskCheckForTimeOut+0x5c>)
    23f0:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
    23f2:	4b13      	ldr	r3, [pc, #76]	; (2440 <xTaskCheckForTimeOut+0x60>)
    23f4:	695a      	ldr	r2, [r3, #20]
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
    23f6:	6871      	ldr	r1, [r6, #4]
		    if (*pxTicksToWait == portMAX_DELAY) {
    23f8:	682b      	ldr	r3, [r5, #0]
    23fa:	1c58      	adds	r0, r3, #1
    23fc:	d01c      	beq.n	2438 <xTaskCheckForTimeOut+0x58>
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
    23fe:	4810      	ldr	r0, [pc, #64]	; (2440 <xTaskCheckForTimeOut+0x60>)
    2400:	6e00      	ldr	r0, [r0, #96]	; 0x60
    2402:	6834      	ldr	r4, [r6, #0]
    2404:	4284      	cmp	r4, r0
    2406:	d002      	beq.n	240e <xTaskCheckForTimeOut+0x2e>
			xReturn = pdTRUE;
    2408:	2401      	movs	r4, #1
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
    240a:	428a      	cmp	r2, r1
    240c:	d205      	bcs.n	241a <xTaskCheckForTimeOut+0x3a>
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
    240e:	1a52      	subs	r2, r2, r1
		} else if (xElapsedTime < *pxTicksToWait) /*lint !e961 Explicit casting is only redundant with some compilers,
    2410:	429a      	cmp	r2, r3
    2412:	d30a      	bcc.n	242a <xTaskCheckForTimeOut+0x4a>
			*pxTicksToWait = 0;
    2414:	2300      	movs	r3, #0
    2416:	602b      	str	r3, [r5, #0]
			xReturn        = pdTRUE;
    2418:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
    241a:	4b0a      	ldr	r3, [pc, #40]	; (2444 <xTaskCheckForTimeOut+0x64>)
    241c:	4798      	blx	r3
}
    241e:	0020      	movs	r0, r4
    2420:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT(pxTimeOut);
    2422:	b672      	cpsid	i
    2424:	e7fe      	b.n	2424 <xTaskCheckForTimeOut+0x44>
	configASSERT(pxTicksToWait);
    2426:	b672      	cpsid	i
    2428:	e7fe      	b.n	2428 <xTaskCheckForTimeOut+0x48>
			*pxTicksToWait -= xElapsedTime;
    242a:	1a9b      	subs	r3, r3, r2
    242c:	602b      	str	r3, [r5, #0]
			vTaskInternalSetTimeOutState(pxTimeOut);
    242e:	0030      	movs	r0, r6
    2430:	4b05      	ldr	r3, [pc, #20]	; (2448 <xTaskCheckForTimeOut+0x68>)
    2432:	4798      	blx	r3
			xReturn = pdFALSE;
    2434:	2400      	movs	r4, #0
    2436:	e7f0      	b.n	241a <xTaskCheckForTimeOut+0x3a>
			xReturn = pdFALSE;
    2438:	2400      	movs	r4, #0
    243a:	e7ee      	b.n	241a <xTaskCheckForTimeOut+0x3a>
    243c:	00001025 	.word	0x00001025
    2440:	20000aac 	.word	0x20000aac
    2444:	0000103d 	.word	0x0000103d
    2448:	000023d1 	.word	0x000023d1

0000244c <vTaskMissedYield>:
	xYieldPending = pdTRUE;
    244c:	2201      	movs	r2, #1
    244e:	4b01      	ldr	r3, [pc, #4]	; (2454 <vTaskMissedYield+0x8>)
    2450:	669a      	str	r2, [r3, #104]	; 0x68
}
    2452:	4770      	bx	lr
    2454:	20000aac 	.word	0x20000aac

00002458 <vTaskGetInfo>:
{
    2458:	b570      	push	{r4, r5, r6, lr}
    245a:	000c      	movs	r4, r1
    245c:	0016      	movs	r6, r2
	pxTCB = prvGetTCBFromHandle(xTask);
    245e:	1e05      	subs	r5, r0, #0
    2460:	d01b      	beq.n	249a <vTaskGetInfo+0x42>
	pxTaskStatus->xHandle           = (TaskHandle_t)pxTCB;
    2462:	6025      	str	r5, [r4, #0]
	pxTaskStatus->pcTaskName        = (const char *)&(pxTCB->pcTaskName[0]);
    2464:	002a      	movs	r2, r5
    2466:	3234      	adds	r2, #52	; 0x34
    2468:	6062      	str	r2, [r4, #4]
	pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
    246a:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    246c:	6122      	str	r2, [r4, #16]
	pxTaskStatus->pxStackBase       = pxTCB->pxStack;
    246e:	6b2a      	ldr	r2, [r5, #48]	; 0x30
    2470:	61e2      	str	r2, [r4, #28]
	pxTaskStatus->xTaskNumber       = pxTCB->uxTCBNumber;
    2472:	6bea      	ldr	r2, [r5, #60]	; 0x3c
    2474:	60a2      	str	r2, [r4, #8]
		pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
    2476:	6c6a      	ldr	r2, [r5, #68]	; 0x44
    2478:	6162      	str	r2, [r4, #20]
		pxTaskStatus->ulRunTimeCounter = 0;
    247a:	2200      	movs	r2, #0
    247c:	61a2      	str	r2, [r4, #24]
	if (eState != eInvalid) {
    247e:	2b05      	cmp	r3, #5
    2480:	d01b      	beq.n	24ba <vTaskGetInfo+0x62>
		if (pxTCB == pxCurrentTCB) {
    2482:	4a17      	ldr	r2, [pc, #92]	; (24e0 <vTaskGetInfo+0x88>)
    2484:	6992      	ldr	r2, [r2, #24]
    2486:	4295      	cmp	r5, r2
    2488:	d00a      	beq.n	24a0 <vTaskGetInfo+0x48>
			pxTaskStatus->eCurrentState = eState;
    248a:	7323      	strb	r3, [r4, #12]
				if (eState == eSuspended) {
    248c:	2b03      	cmp	r3, #3
    248e:	d00a      	beq.n	24a6 <vTaskGetInfo+0x4e>
	if (xGetFreeStackSpace != pdFALSE) {
    2490:	2e00      	cmp	r6, #0
    2492:	d117      	bne.n	24c4 <vTaskGetInfo+0x6c>
		pxTaskStatus->usStackHighWaterMark = 0;
    2494:	2300      	movs	r3, #0
    2496:	8423      	strh	r3, [r4, #32]
}
    2498:	bd70      	pop	{r4, r5, r6, pc}
	pxTCB = prvGetTCBFromHandle(xTask);
    249a:	4a11      	ldr	r2, [pc, #68]	; (24e0 <vTaskGetInfo+0x88>)
    249c:	6995      	ldr	r5, [r2, #24]
    249e:	e7e0      	b.n	2462 <vTaskGetInfo+0xa>
			pxTaskStatus->eCurrentState = eRunning;
    24a0:	2300      	movs	r3, #0
    24a2:	7323      	strb	r3, [r4, #12]
    24a4:	e7f4      	b.n	2490 <vTaskGetInfo+0x38>
					vTaskSuspendAll();
    24a6:	4b0f      	ldr	r3, [pc, #60]	; (24e4 <vTaskGetInfo+0x8c>)
    24a8:	4798      	blx	r3
						if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
    24aa:	6aab      	ldr	r3, [r5, #40]	; 0x28
    24ac:	2b00      	cmp	r3, #0
    24ae:	d001      	beq.n	24b4 <vTaskGetInfo+0x5c>
							pxTaskStatus->eCurrentState = eBlocked;
    24b0:	2302      	movs	r3, #2
    24b2:	7323      	strb	r3, [r4, #12]
					(void)xTaskResumeAll();
    24b4:	4b0c      	ldr	r3, [pc, #48]	; (24e8 <vTaskGetInfo+0x90>)
    24b6:	4798      	blx	r3
    24b8:	e7ea      	b.n	2490 <vTaskGetInfo+0x38>
		pxTaskStatus->eCurrentState = eTaskGetState(pxTCB);
    24ba:	0028      	movs	r0, r5
    24bc:	4b0b      	ldr	r3, [pc, #44]	; (24ec <vTaskGetInfo+0x94>)
    24be:	4798      	blx	r3
    24c0:	7320      	strb	r0, [r4, #12]
    24c2:	e7e5      	b.n	2490 <vTaskGetInfo+0x38>
			pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace((uint8_t *)pxTCB->pxStack);
    24c4:	6b29      	ldr	r1, [r5, #48]	; 0x30
	while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
    24c6:	780b      	ldrb	r3, [r1, #0]
    24c8:	2ba5      	cmp	r3, #165	; 0xa5
    24ca:	d107      	bne.n	24dc <vTaskGetInfo+0x84>
    24cc:	2300      	movs	r3, #0
		ulCount++;
    24ce:	3301      	adds	r3, #1
	while (*pucStackByte == (uint8_t)tskSTACK_FILL_BYTE) {
    24d0:	5cca      	ldrb	r2, [r1, r3]
    24d2:	2aa5      	cmp	r2, #165	; 0xa5
    24d4:	d0fb      	beq.n	24ce <vTaskGetInfo+0x76>
	ulCount /= (uint32_t)sizeof(StackType_t); /*lint !e961 Casting is not redundant on smaller architectures. */
    24d6:	089b      	lsrs	r3, r3, #2
			pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace((uint8_t *)pxTCB->pxStack);
    24d8:	8423      	strh	r3, [r4, #32]
    24da:	e7dd      	b.n	2498 <vTaskGetInfo+0x40>
	uint32_t ulCount = 0U;
    24dc:	2300      	movs	r3, #0
    24de:	e7fa      	b.n	24d6 <vTaskGetInfo+0x7e>
    24e0:	20000aac 	.word	0x20000aac
    24e4:	00001f45 	.word	0x00001f45
    24e8:	00002079 	.word	0x00002079
    24ec:	00001e01 	.word	0x00001e01

000024f0 <prvListTasksWithinSingleList>:
{
    24f0:	b5f0      	push	{r4, r5, r6, r7, lr}
    24f2:	46de      	mov	lr, fp
    24f4:	4657      	mov	r7, sl
    24f6:	464e      	mov	r6, r9
    24f8:	b5c0      	push	{r6, r7, lr}
    24fa:	b082      	sub	sp, #8
    24fc:	000c      	movs	r4, r1
    24fe:	9201      	str	r2, [sp, #4]
	if (listCURRENT_LIST_LENGTH(pxList) > (UBaseType_t)0) {
    2500:	680b      	ldr	r3, [r1, #0]
	UBaseType_t                uxTask = 0;
    2502:	2700      	movs	r7, #0
	if (listCURRENT_LIST_LENGTH(pxList) > (UBaseType_t)0) {
    2504:	2b00      	cmp	r3, #0
    2506:	d025      	beq.n	2554 <prvListTasksWithinSingleList+0x64>
		listGET_OWNER_OF_NEXT_ENTRY(pxFirstTCB, pxList);
    2508:	684b      	ldr	r3, [r1, #4]
    250a:	685b      	ldr	r3, [r3, #4]
    250c:	604b      	str	r3, [r1, #4]
    250e:	2208      	movs	r2, #8
    2510:	4691      	mov	r9, r2
    2512:	4489      	add	r9, r1
    2514:	454b      	cmp	r3, r9
    2516:	d007      	beq.n	2528 <prvListTasksWithinSingleList+0x38>
    2518:	6863      	ldr	r3, [r4, #4]
    251a:	68db      	ldr	r3, [r3, #12]
    251c:	469b      	mov	fp, r3
    251e:	0005      	movs	r5, r0
	UBaseType_t                uxTask = 0;
    2520:	2700      	movs	r7, #0
			vTaskGetInfo((TaskHandle_t)pxNextTCB, &(pxTaskStatusArray[uxTask]), pdTRUE, eState);
    2522:	4b10      	ldr	r3, [pc, #64]	; (2564 <prvListTasksWithinSingleList+0x74>)
    2524:	469a      	mov	sl, r3
    2526:	e00d      	b.n	2544 <prvListTasksWithinSingleList+0x54>
		listGET_OWNER_OF_NEXT_ENTRY(pxFirstTCB, pxList);
    2528:	68cb      	ldr	r3, [r1, #12]
    252a:	604b      	str	r3, [r1, #4]
    252c:	e7f4      	b.n	2518 <prvListTasksWithinSingleList+0x28>
			listGET_OWNER_OF_NEXT_ENTRY(pxNextTCB, pxList);
    252e:	6863      	ldr	r3, [r4, #4]
    2530:	68de      	ldr	r6, [r3, #12]
			vTaskGetInfo((TaskHandle_t)pxNextTCB, &(pxTaskStatusArray[uxTask]), pdTRUE, eState);
    2532:	9b01      	ldr	r3, [sp, #4]
    2534:	2201      	movs	r2, #1
    2536:	0029      	movs	r1, r5
    2538:	0030      	movs	r0, r6
    253a:	47d0      	blx	sl
			uxTask++;
    253c:	3701      	adds	r7, #1
    253e:	3524      	adds	r5, #36	; 0x24
		} while (pxNextTCB != pxFirstTCB);
    2540:	45b3      	cmp	fp, r6
    2542:	d007      	beq.n	2554 <prvListTasksWithinSingleList+0x64>
			listGET_OWNER_OF_NEXT_ENTRY(pxNextTCB, pxList);
    2544:	6863      	ldr	r3, [r4, #4]
    2546:	685b      	ldr	r3, [r3, #4]
    2548:	6063      	str	r3, [r4, #4]
    254a:	4599      	cmp	r9, r3
    254c:	d1ef      	bne.n	252e <prvListTasksWithinSingleList+0x3e>
    254e:	68e3      	ldr	r3, [r4, #12]
    2550:	6063      	str	r3, [r4, #4]
    2552:	e7ec      	b.n	252e <prvListTasksWithinSingleList+0x3e>
}
    2554:	0038      	movs	r0, r7
    2556:	b002      	add	sp, #8
    2558:	bc1c      	pop	{r2, r3, r4}
    255a:	4691      	mov	r9, r2
    255c:	469a      	mov	sl, r3
    255e:	46a3      	mov	fp, r4
    2560:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2562:	46c0      	nop			; (mov r8, r8)
    2564:	00002459 	.word	0x00002459

00002568 <uxTaskGetSystemState>:
{
    2568:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    256a:	46ce      	mov	lr, r9
    256c:	4647      	mov	r7, r8
    256e:	b580      	push	{r7, lr}
    2570:	0006      	movs	r6, r0
    2572:	000d      	movs	r5, r1
    2574:	4691      	mov	r9, r2
	vTaskSuspendAll();
    2576:	4b20      	ldr	r3, [pc, #128]	; (25f8 <uxTaskGetSystemState+0x90>)
    2578:	4798      	blx	r3
		if (uxArraySize >= uxCurrentNumberOfTasks) {
    257a:	4b20      	ldr	r3, [pc, #128]	; (25fc <uxTaskGetSystemState+0x94>)
    257c:	6a1b      	ldr	r3, [r3, #32]
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
    257e:	2400      	movs	r4, #0
		if (uxArraySize >= uxCurrentNumberOfTasks) {
    2580:	42ab      	cmp	r3, r5
    2582:	d831      	bhi.n	25e8 <uxTaskGetSystemState+0x80>
    2584:	4f1e      	ldr	r7, [pc, #120]	; (2600 <uxTaskGetSystemState+0x98>)
    2586:	003d      	movs	r5, r7
    2588:	3580      	adds	r5, #128	; 0x80
    258a:	371c      	adds	r7, #28
				uxTask += prvListTasksWithinSingleList(
    258c:	4b1d      	ldr	r3, [pc, #116]	; (2604 <uxTaskGetSystemState+0x9c>)
    258e:	4698      	mov	r8, r3
				    &(pxTaskStatusArray[uxTask]), &(pxReadyTasksLists[uxQueue]), eReady);
    2590:	00e0      	lsls	r0, r4, #3
    2592:	1900      	adds	r0, r0, r4
    2594:	0080      	lsls	r0, r0, #2
				uxTask += prvListTasksWithinSingleList(
    2596:	1830      	adds	r0, r6, r0
    2598:	2201      	movs	r2, #1
    259a:	0029      	movs	r1, r5
    259c:	47c0      	blx	r8
    259e:	1824      	adds	r4, r4, r0
    25a0:	3d14      	subs	r5, #20
			          tskIDLE_PRIORITY); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    25a2:	42bd      	cmp	r5, r7
    25a4:	d1f4      	bne.n	2590 <uxTaskGetSystemState+0x28>
			uxTask += prvListTasksWithinSingleList(&(pxTaskStatusArray[uxTask]), (List_t *)pxDelayedTaskList, eBlocked);
    25a6:	4f16      	ldr	r7, [pc, #88]	; (2600 <uxTaskGetSystemState+0x98>)
    25a8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
    25aa:	00e0      	lsls	r0, r4, #3
    25ac:	1900      	adds	r0, r0, r4
    25ae:	0080      	lsls	r0, r0, #2
    25b0:	1830      	adds	r0, r6, r0
    25b2:	2202      	movs	r2, #2
    25b4:	4d13      	ldr	r5, [pc, #76]	; (2604 <uxTaskGetSystemState+0x9c>)
    25b6:	47a8      	blx	r5
    25b8:	1824      	adds	r4, r4, r0
			uxTask += prvListTasksWithinSingleList(
    25ba:	4b10      	ldr	r3, [pc, #64]	; (25fc <uxTaskGetSystemState+0x94>)
    25bc:	69d9      	ldr	r1, [r3, #28]
			    &(pxTaskStatusArray[uxTask]), (List_t *)pxOverflowDelayedTaskList, eBlocked);
    25be:	00e0      	lsls	r0, r4, #3
    25c0:	1900      	adds	r0, r0, r4
    25c2:	0080      	lsls	r0, r0, #2
			uxTask += prvListTasksWithinSingleList(
    25c4:	1830      	adds	r0, r6, r0
    25c6:	2202      	movs	r2, #2
    25c8:	47a8      	blx	r5
    25ca:	1824      	adds	r4, r4, r0
				uxTask += prvListTasksWithinSingleList(&(pxTaskStatusArray[uxTask]), &xSuspendedTaskList, eSuspended);
    25cc:	00e0      	lsls	r0, r4, #3
    25ce:	1900      	adds	r0, r0, r4
    25d0:	0080      	lsls	r0, r0, #2
    25d2:	1830      	adds	r0, r6, r0
    25d4:	2203      	movs	r2, #3
    25d6:	0039      	movs	r1, r7
    25d8:	47a8      	blx	r5
    25da:	1824      	adds	r4, r4, r0
				if (pulTotalRunTime != NULL) {
    25dc:	464b      	mov	r3, r9
    25de:	2b00      	cmp	r3, #0
    25e0:	d002      	beq.n	25e8 <uxTaskGetSystemState+0x80>
					*pulTotalRunTime = 0;
    25e2:	2300      	movs	r3, #0
    25e4:	464a      	mov	r2, r9
    25e6:	6013      	str	r3, [r2, #0]
	(void)xTaskResumeAll();
    25e8:	4b07      	ldr	r3, [pc, #28]	; (2608 <uxTaskGetSystemState+0xa0>)
    25ea:	4798      	blx	r3
}
    25ec:	0020      	movs	r0, r4
    25ee:	bc0c      	pop	{r2, r3}
    25f0:	4690      	mov	r8, r2
    25f2:	4699      	mov	r9, r3
    25f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    25f6:	46c0      	nop			; (mov r8, r8)
    25f8:	00001f45 	.word	0x00001f45
    25fc:	20000aac 	.word	0x20000aac
    2600:	20000a2c 	.word	0x20000a2c
    2604:	000024f1 	.word	0x000024f1
    2608:	00002079 	.word	0x00002079

0000260c <xTaskGetSchedulerState>:
	if (xSchedulerRunning == pdFALSE) {
    260c:	4b05      	ldr	r3, [pc, #20]	; (2624 <xTaskGetSchedulerState+0x18>)
    260e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
		xReturn = taskSCHEDULER_NOT_STARTED;
    2610:	2001      	movs	r0, #1
	if (xSchedulerRunning == pdFALSE) {
    2612:	2b00      	cmp	r3, #0
    2614:	d004      	beq.n	2620 <xTaskGetSchedulerState+0x14>
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    2616:	4b03      	ldr	r3, [pc, #12]	; (2624 <xTaskGetSchedulerState+0x18>)
    2618:	6d98      	ldr	r0, [r3, #88]	; 0x58
			xReturn = taskSCHEDULER_SUSPENDED;
    261a:	4243      	negs	r3, r0
    261c:	4158      	adcs	r0, r3
    261e:	0040      	lsls	r0, r0, #1
}
    2620:	4770      	bx	lr
    2622:	46c0      	nop			; (mov r8, r8)
    2624:	20000aac 	.word	0x20000aac

00002628 <xTaskPriorityInherit>:
{
    2628:	b570      	push	{r4, r5, r6, lr}
    262a:	1e04      	subs	r4, r0, #0
	if (pxMutexHolder != NULL) {
    262c:	d03d      	beq.n	26aa <xTaskPriorityInherit+0x82>
		if (pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority) {
    262e:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
    2630:	4b1f      	ldr	r3, [pc, #124]	; (26b0 <xTaskPriorityInherit+0x88>)
    2632:	699b      	ldr	r3, [r3, #24]
    2634:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2636:	4299      	cmp	r1, r3
    2638:	d22f      	bcs.n	269a <xTaskPriorityInherit+0x72>
			if ((listGET_LIST_ITEM_VALUE(&(pxMutexHolderTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE)
    263a:	6983      	ldr	r3, [r0, #24]
    263c:	2b00      	cmp	r3, #0
    263e:	db05      	blt.n	264c <xTaskPriorityInherit+0x24>
				listSET_LIST_ITEM_VALUE(
    2640:	4b1b      	ldr	r3, [pc, #108]	; (26b0 <xTaskPriorityInherit+0x88>)
    2642:	699b      	ldr	r3, [r3, #24]
    2644:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2646:	2305      	movs	r3, #5
    2648:	1a9b      	subs	r3, r3, r2
    264a:	6183      	str	r3, [r0, #24]
			if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[pxMutexHolderTCB->uxPriority]),
    264c:	008b      	lsls	r3, r1, #2
    264e:	1859      	adds	r1, r3, r1
    2650:	0089      	lsls	r1, r1, #2
    2652:	4b18      	ldr	r3, [pc, #96]	; (26b4 <xTaskPriorityInherit+0x8c>)
    2654:	3330      	adds	r3, #48	; 0x30
    2656:	185b      	adds	r3, r3, r1
    2658:	6962      	ldr	r2, [r4, #20]
    265a:	429a      	cmp	r2, r3
    265c:	d005      	beq.n	266a <xTaskPriorityInherit+0x42>
				pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    265e:	4b14      	ldr	r3, [pc, #80]	; (26b0 <xTaskPriorityInherit+0x88>)
    2660:	699b      	ldr	r3, [r3, #24]
    2662:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2664:	62e3      	str	r3, [r4, #44]	; 0x2c
			xReturn = pdTRUE;
    2666:	2001      	movs	r0, #1
    2668:	e01e      	b.n	26a8 <xTaskPriorityInherit+0x80>
				if (uxListRemove(&(pxMutexHolderTCB->xStateListItem)) == (UBaseType_t)0) {
    266a:	1d25      	adds	r5, r4, #4
    266c:	0028      	movs	r0, r5
    266e:	4b12      	ldr	r3, [pc, #72]	; (26b8 <xTaskPriorityInherit+0x90>)
    2670:	4798      	blx	r3
				pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    2672:	4b0f      	ldr	r3, [pc, #60]	; (26b0 <xTaskPriorityInherit+0x88>)
    2674:	699a      	ldr	r2, [r3, #24]
    2676:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    2678:	62e2      	str	r2, [r4, #44]	; 0x2c
				prvAddTaskToReadyList(pxMutexHolderTCB);
    267a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    267c:	429a      	cmp	r2, r3
    267e:	d901      	bls.n	2684 <xTaskPriorityInherit+0x5c>
    2680:	4b0b      	ldr	r3, [pc, #44]	; (26b0 <xTaskPriorityInherit+0x88>)
    2682:	655a      	str	r2, [r3, #84]	; 0x54
    2684:	0090      	lsls	r0, r2, #2
    2686:	1882      	adds	r2, r0, r2
    2688:	0092      	lsls	r2, r2, #2
    268a:	480a      	ldr	r0, [pc, #40]	; (26b4 <xTaskPriorityInherit+0x8c>)
    268c:	3030      	adds	r0, #48	; 0x30
    268e:	1880      	adds	r0, r0, r2
    2690:	0029      	movs	r1, r5
    2692:	4b0a      	ldr	r3, [pc, #40]	; (26bc <xTaskPriorityInherit+0x94>)
    2694:	4798      	blx	r3
			xReturn = pdTRUE;
    2696:	2001      	movs	r0, #1
    2698:	e006      	b.n	26a8 <xTaskPriorityInherit+0x80>
			if (pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority) {
    269a:	4b05      	ldr	r3, [pc, #20]	; (26b0 <xTaskPriorityInherit+0x88>)
    269c:	699b      	ldr	r3, [r3, #24]
    269e:	6c40      	ldr	r0, [r0, #68]	; 0x44
    26a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    26a2:	4298      	cmp	r0, r3
    26a4:	4180      	sbcs	r0, r0
    26a6:	4240      	negs	r0, r0
}
    26a8:	bd70      	pop	{r4, r5, r6, pc}
	BaseType_t   xReturn          = pdFALSE;
    26aa:	2000      	movs	r0, #0
	return xReturn;
    26ac:	e7fc      	b.n	26a8 <xTaskPriorityInherit+0x80>
    26ae:	46c0      	nop			; (mov r8, r8)
    26b0:	20000aac 	.word	0x20000aac
    26b4:	20000a2c 	.word	0x20000a2c
    26b8:	00000eff 	.word	0x00000eff
    26bc:	00000eb9 	.word	0x00000eb9

000026c0 <xTaskPriorityDisinherit>:
{
    26c0:	b570      	push	{r4, r5, r6, lr}
    26c2:	1e04      	subs	r4, r0, #0
	if (pxMutexHolder != NULL) {
    26c4:	d02d      	beq.n	2722 <xTaskPriorityDisinherit+0x62>
		configASSERT(pxTCB == pxCurrentTCB);
    26c6:	4b19      	ldr	r3, [pc, #100]	; (272c <xTaskPriorityDisinherit+0x6c>)
    26c8:	699b      	ldr	r3, [r3, #24]
    26ca:	4298      	cmp	r0, r3
    26cc:	d001      	beq.n	26d2 <xTaskPriorityDisinherit+0x12>
    26ce:	b672      	cpsid	i
    26d0:	e7fe      	b.n	26d0 <xTaskPriorityDisinherit+0x10>
		configASSERT(pxTCB->uxMutexesHeld);
    26d2:	6c83      	ldr	r3, [r0, #72]	; 0x48
    26d4:	2b00      	cmp	r3, #0
    26d6:	d101      	bne.n	26dc <xTaskPriorityDisinherit+0x1c>
    26d8:	b672      	cpsid	i
    26da:	e7fe      	b.n	26da <xTaskPriorityDisinherit+0x1a>
		(pxTCB->uxMutexesHeld)--;
    26dc:	3b01      	subs	r3, #1
    26de:	6483      	str	r3, [r0, #72]	; 0x48
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
    26e0:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    26e2:	6c41      	ldr	r1, [r0, #68]	; 0x44
    26e4:	428a      	cmp	r2, r1
    26e6:	d01e      	beq.n	2726 <xTaskPriorityDisinherit+0x66>
	BaseType_t   xReturn = pdFALSE;
    26e8:	2000      	movs	r0, #0
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
    26ea:	2b00      	cmp	r3, #0
    26ec:	d118      	bne.n	2720 <xTaskPriorityDisinherit+0x60>
				if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
    26ee:	1d25      	adds	r5, r4, #4
    26f0:	0028      	movs	r0, r5
    26f2:	4b0f      	ldr	r3, [pc, #60]	; (2730 <xTaskPriorityDisinherit+0x70>)
    26f4:	4798      	blx	r3
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    26f6:	6c63      	ldr	r3, [r4, #68]	; 0x44
    26f8:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE(
    26fa:	2205      	movs	r2, #5
    26fc:	1ad2      	subs	r2, r2, r3
    26fe:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyList(pxTCB);
    2700:	4a0a      	ldr	r2, [pc, #40]	; (272c <xTaskPriorityDisinherit+0x6c>)
    2702:	6d52      	ldr	r2, [r2, #84]	; 0x54
    2704:	4293      	cmp	r3, r2
    2706:	d901      	bls.n	270c <xTaskPriorityDisinherit+0x4c>
    2708:	4a08      	ldr	r2, [pc, #32]	; (272c <xTaskPriorityDisinherit+0x6c>)
    270a:	6553      	str	r3, [r2, #84]	; 0x54
    270c:	0098      	lsls	r0, r3, #2
    270e:	18c3      	adds	r3, r0, r3
    2710:	009b      	lsls	r3, r3, #2
    2712:	4808      	ldr	r0, [pc, #32]	; (2734 <xTaskPriorityDisinherit+0x74>)
    2714:	3030      	adds	r0, #48	; 0x30
    2716:	18c0      	adds	r0, r0, r3
    2718:	0029      	movs	r1, r5
    271a:	4b07      	ldr	r3, [pc, #28]	; (2738 <xTaskPriorityDisinherit+0x78>)
    271c:	4798      	blx	r3
				xReturn = pdTRUE;
    271e:	2001      	movs	r0, #1
}
    2720:	bd70      	pop	{r4, r5, r6, pc}
	BaseType_t   xReturn = pdFALSE;
    2722:	2000      	movs	r0, #0
    2724:	e7fc      	b.n	2720 <xTaskPriorityDisinherit+0x60>
    2726:	2000      	movs	r0, #0
    2728:	e7fa      	b.n	2720 <xTaskPriorityDisinherit+0x60>
    272a:	46c0      	nop			; (mov r8, r8)
    272c:	20000aac 	.word	0x20000aac
    2730:	00000eff 	.word	0x00000eff
    2734:	20000a2c 	.word	0x20000a2c
    2738:	00000eb9 	.word	0x00000eb9

0000273c <vTaskPriorityDisinheritAfterTimeout>:
{
    273c:	b570      	push	{r4, r5, r6, lr}
    273e:	1e04      	subs	r4, r0, #0
	if (pxMutexHolder != NULL) {
    2740:	d00d      	beq.n	275e <vTaskPriorityDisinheritAfterTimeout+0x22>
		configASSERT(pxTCB->uxMutexesHeld);
    2742:	6c83      	ldr	r3, [r0, #72]	; 0x48
    2744:	2b00      	cmp	r3, #0
    2746:	d101      	bne.n	274c <vTaskPriorityDisinheritAfterTimeout+0x10>
    2748:	b672      	cpsid	i
    274a:	e7fe      	b.n	274a <vTaskPriorityDisinheritAfterTimeout+0xe>
    274c:	6c40      	ldr	r0, [r0, #68]	; 0x44
    274e:	4288      	cmp	r0, r1
    2750:	d200      	bcs.n	2754 <vTaskPriorityDisinheritAfterTimeout+0x18>
    2752:	0008      	movs	r0, r1
		if (pxTCB->uxPriority != uxPriorityToUse) {
    2754:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    2756:	4282      	cmp	r2, r0
    2758:	d001      	beq.n	275e <vTaskPriorityDisinheritAfterTimeout+0x22>
			if (pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld) {
    275a:	2b01      	cmp	r3, #1
    275c:	d000      	beq.n	2760 <vTaskPriorityDisinheritAfterTimeout+0x24>
}
    275e:	bd70      	pop	{r4, r5, r6, pc}
				configASSERT(pxTCB != pxCurrentTCB);
    2760:	4b15      	ldr	r3, [pc, #84]	; (27b8 <vTaskPriorityDisinheritAfterTimeout+0x7c>)
    2762:	699b      	ldr	r3, [r3, #24]
    2764:	429c      	cmp	r4, r3
    2766:	d101      	bne.n	276c <vTaskPriorityDisinheritAfterTimeout+0x30>
    2768:	b672      	cpsid	i
    276a:	e7fe      	b.n	276a <vTaskPriorityDisinheritAfterTimeout+0x2e>
				pxTCB->uxPriority     = uxPriorityToUse;
    276c:	62e0      	str	r0, [r4, #44]	; 0x2c
				if ((listGET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem)) & taskEVENT_LIST_ITEM_VALUE_IN_USE) == 0UL) {
    276e:	69a3      	ldr	r3, [r4, #24]
    2770:	2b00      	cmp	r3, #0
    2772:	db02      	blt.n	277a <vTaskPriorityDisinheritAfterTimeout+0x3e>
					listSET_LIST_ITEM_VALUE(&(pxTCB->xEventListItem),
    2774:	2305      	movs	r3, #5
    2776:	1a18      	subs	r0, r3, r0
    2778:	61a0      	str	r0, [r4, #24]
				if (listIS_CONTAINED_WITHIN(&(pxReadyTasksLists[uxPriorityUsedOnEntry]), &(pxTCB->xStateListItem))
    277a:	0093      	lsls	r3, r2, #2
    277c:	189a      	adds	r2, r3, r2
    277e:	0092      	lsls	r2, r2, #2
    2780:	4b0e      	ldr	r3, [pc, #56]	; (27bc <vTaskPriorityDisinheritAfterTimeout+0x80>)
    2782:	3330      	adds	r3, #48	; 0x30
    2784:	189b      	adds	r3, r3, r2
    2786:	6962      	ldr	r2, [r4, #20]
    2788:	429a      	cmp	r2, r3
    278a:	d1e8      	bne.n	275e <vTaskPriorityDisinheritAfterTimeout+0x22>
					if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
    278c:	1d25      	adds	r5, r4, #4
    278e:	0028      	movs	r0, r5
    2790:	4b0b      	ldr	r3, [pc, #44]	; (27c0 <vTaskPriorityDisinheritAfterTimeout+0x84>)
    2792:	4798      	blx	r3
					prvAddTaskToReadyList(pxTCB);
    2794:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2796:	4a08      	ldr	r2, [pc, #32]	; (27b8 <vTaskPriorityDisinheritAfterTimeout+0x7c>)
    2798:	6d52      	ldr	r2, [r2, #84]	; 0x54
    279a:	4293      	cmp	r3, r2
    279c:	d901      	bls.n	27a2 <vTaskPriorityDisinheritAfterTimeout+0x66>
    279e:	4a06      	ldr	r2, [pc, #24]	; (27b8 <vTaskPriorityDisinheritAfterTimeout+0x7c>)
    27a0:	6553      	str	r3, [r2, #84]	; 0x54
    27a2:	0098      	lsls	r0, r3, #2
    27a4:	18c3      	adds	r3, r0, r3
    27a6:	009b      	lsls	r3, r3, #2
    27a8:	4804      	ldr	r0, [pc, #16]	; (27bc <vTaskPriorityDisinheritAfterTimeout+0x80>)
    27aa:	3030      	adds	r0, #48	; 0x30
    27ac:	18c0      	adds	r0, r0, r3
    27ae:	0029      	movs	r1, r5
    27b0:	4b04      	ldr	r3, [pc, #16]	; (27c4 <vTaskPriorityDisinheritAfterTimeout+0x88>)
    27b2:	4798      	blx	r3
}
    27b4:	e7d3      	b.n	275e <vTaskPriorityDisinheritAfterTimeout+0x22>
    27b6:	46c0      	nop			; (mov r8, r8)
    27b8:	20000aac 	.word	0x20000aac
    27bc:	20000a2c 	.word	0x20000a2c
    27c0:	00000eff 	.word	0x00000eff
    27c4:	00000eb9 	.word	0x00000eb9

000027c8 <vTaskList>:
{
    27c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    27ca:	46ce      	mov	lr, r9
    27cc:	4647      	mov	r7, r8
    27ce:	b580      	push	{r7, lr}
    27d0:	b085      	sub	sp, #20
    27d2:	0004      	movs	r4, r0
	*pcWriteBuffer = 0x00;
    27d4:	2300      	movs	r3, #0
    27d6:	7003      	strb	r3, [r0, #0]
	uxArraySize = uxCurrentNumberOfTasks;
    27d8:	4b3b      	ldr	r3, [pc, #236]	; (28c8 <vTaskList+0x100>)
    27da:	6a1a      	ldr	r2, [r3, #32]
    27dc:	9203      	str	r2, [sp, #12]
	pxTaskStatusArray = pvPortMalloc(uxCurrentNumberOfTasks * sizeof(TaskStatus_t));
    27de:	6a1b      	ldr	r3, [r3, #32]
    27e0:	00d8      	lsls	r0, r3, #3
    27e2:	18c0      	adds	r0, r0, r3
    27e4:	0080      	lsls	r0, r0, #2
    27e6:	4b39      	ldr	r3, [pc, #228]	; (28cc <vTaskList+0x104>)
    27e8:	4798      	blx	r3
    27ea:	1e06      	subs	r6, r0, #0
	if (pxTaskStatusArray != NULL) {
    27ec:	d066      	beq.n	28bc <vTaskList+0xf4>
		uxArraySize = uxTaskGetSystemState(pxTaskStatusArray, uxArraySize, NULL);
    27ee:	9903      	ldr	r1, [sp, #12]
    27f0:	2200      	movs	r2, #0
    27f2:	4b37      	ldr	r3, [pc, #220]	; (28d0 <vTaskList+0x108>)
    27f4:	4798      	blx	r3
    27f6:	9003      	str	r0, [sp, #12]
		for (x = 0; x < uxArraySize; x++) {
    27f8:	2300      	movs	r3, #0
    27fa:	9302      	str	r3, [sp, #8]
    27fc:	9a02      	ldr	r2, [sp, #8]
    27fe:	9b03      	ldr	r3, [sp, #12]
    2800:	429a      	cmp	r2, r3
    2802:	d258      	bcs.n	28b6 <vTaskList+0xee>
				cStatus = 0x00;
    2804:	2700      	movs	r7, #0
	strcpy(pcBuffer, pcTaskName);
    2806:	4b33      	ldr	r3, [pc, #204]	; (28d4 <vTaskList+0x10c>)
    2808:	4699      	mov	r9, r3
	for (x = strlen(pcBuffer); x < (size_t)(configMAX_TASK_NAME_LEN - 1); x++) {
    280a:	4b33      	ldr	r3, [pc, #204]	; (28d8 <vTaskList+0x110>)
    280c:	4698      	mov	r8, r3
    280e:	e03d      	b.n	288c <vTaskList+0xc4>
				cStatus = tskREADY_CHAR;
    2810:	2552      	movs	r5, #82	; 0x52
			switch (pxTaskStatusArray[x].eCurrentState) {
    2812:	2b01      	cmp	r3, #1
    2814:	d14b      	bne.n	28ae <vTaskList+0xe6>
			pcWriteBuffer = prvWriteNameToBuffer(pcWriteBuffer, pxTaskStatusArray[x].pcTaskName);
    2816:	9a02      	ldr	r2, [sp, #8]
    2818:	00d3      	lsls	r3, r2, #3
    281a:	189b      	adds	r3, r3, r2
    281c:	009b      	lsls	r3, r3, #2
    281e:	18f3      	adds	r3, r6, r3
	strcpy(pcBuffer, pcTaskName);
    2820:	6859      	ldr	r1, [r3, #4]
    2822:	0020      	movs	r0, r4
    2824:	47c8      	blx	r9
	for (x = strlen(pcBuffer); x < (size_t)(configMAX_TASK_NAME_LEN - 1); x++) {
    2826:	0020      	movs	r0, r4
    2828:	47c0      	blx	r8
    282a:	0003      	movs	r3, r0
    282c:	2806      	cmp	r0, #6
    282e:	d807      	bhi.n	2840 <vTaskList+0x78>
    2830:	1820      	adds	r0, r4, r0
    2832:	1de1      	adds	r1, r4, #7
		pcBuffer[x] = ' ';
    2834:	2220      	movs	r2, #32
    2836:	7002      	strb	r2, [r0, #0]
    2838:	3001      	adds	r0, #1
	for (x = strlen(pcBuffer); x < (size_t)(configMAX_TASK_NAME_LEN - 1); x++) {
    283a:	4281      	cmp	r1, r0
    283c:	d1fb      	bne.n	2836 <vTaskList+0x6e>
    283e:	2307      	movs	r3, #7
	pcBuffer[x] = 0x00;
    2840:	18e4      	adds	r4, r4, r3
    2842:	7027      	strb	r7, [r4, #0]
			        (unsigned int)pxTaskStatusArray[x].uxCurrentPriority,
    2844:	9902      	ldr	r1, [sp, #8]
			        (unsigned int)pxTaskStatusArray[x].usStackHighWaterMark,
    2846:	9802      	ldr	r0, [sp, #8]
			        (unsigned int)pxTaskStatusArray[x].xTaskNumber);
    2848:	9a02      	ldr	r2, [sp, #8]
			        (unsigned int)pxTaskStatusArray[x].uxCurrentPriority,
    284a:	00cb      	lsls	r3, r1, #3
    284c:	185b      	adds	r3, r3, r1
    284e:	009b      	lsls	r3, r3, #2
    2850:	18f3      	adds	r3, r6, r3
			sprintf(pcWriteBuffer,
    2852:	691b      	ldr	r3, [r3, #16]
			        (unsigned int)pxTaskStatusArray[x].xTaskNumber);
    2854:	00d1      	lsls	r1, r2, #3
    2856:	1889      	adds	r1, r1, r2
    2858:	0089      	lsls	r1, r1, #2
    285a:	1871      	adds	r1, r6, r1
			sprintf(pcWriteBuffer,
    285c:	688a      	ldr	r2, [r1, #8]
    285e:	9201      	str	r2, [sp, #4]
			        (unsigned int)pxTaskStatusArray[x].usStackHighWaterMark,
    2860:	00c2      	lsls	r2, r0, #3
    2862:	1812      	adds	r2, r2, r0
    2864:	0092      	lsls	r2, r2, #2
    2866:	18b2      	adds	r2, r6, r2
			sprintf(pcWriteBuffer,
    2868:	8c12      	ldrh	r2, [r2, #32]
    286a:	9200      	str	r2, [sp, #0]
    286c:	002a      	movs	r2, r5
    286e:	491b      	ldr	r1, [pc, #108]	; (28dc <vTaskList+0x114>)
    2870:	0020      	movs	r0, r4
    2872:	4d1b      	ldr	r5, [pc, #108]	; (28e0 <vTaskList+0x118>)
    2874:	47a8      	blx	r5
			pcWriteBuffer += strlen(pcWriteBuffer);
    2876:	0020      	movs	r0, r4
    2878:	4b17      	ldr	r3, [pc, #92]	; (28d8 <vTaskList+0x110>)
    287a:	4798      	blx	r3
    287c:	1824      	adds	r4, r4, r0
		for (x = 0; x < uxArraySize; x++) {
    287e:	9b02      	ldr	r3, [sp, #8]
    2880:	3301      	adds	r3, #1
    2882:	9302      	str	r3, [sp, #8]
    2884:	9a02      	ldr	r2, [sp, #8]
    2886:	9b03      	ldr	r3, [sp, #12]
    2888:	429a      	cmp	r2, r3
    288a:	d214      	bcs.n	28b6 <vTaskList+0xee>
			switch (pxTaskStatusArray[x].eCurrentState) {
    288c:	9a02      	ldr	r2, [sp, #8]
    288e:	00d3      	lsls	r3, r2, #3
    2890:	189b      	adds	r3, r3, r2
    2892:	009b      	lsls	r3, r3, #2
    2894:	18f3      	adds	r3, r6, r3
    2896:	7b1b      	ldrb	r3, [r3, #12]
    2898:	2b02      	cmp	r3, #2
    289a:	d00a      	beq.n	28b2 <vTaskList+0xea>
    289c:	b2da      	uxtb	r2, r3
    289e:	2a02      	cmp	r2, #2
    28a0:	d9b6      	bls.n	2810 <vTaskList+0x48>
				cStatus = tskSUSPENDED_CHAR;
    28a2:	2553      	movs	r5, #83	; 0x53
			switch (pxTaskStatusArray[x].eCurrentState) {
    28a4:	2b03      	cmp	r3, #3
    28a6:	d0b6      	beq.n	2816 <vTaskList+0x4e>
				cStatus = tskDELETED_CHAR;
    28a8:	3d0f      	subs	r5, #15
			switch (pxTaskStatusArray[x].eCurrentState) {
    28aa:	2b04      	cmp	r3, #4
    28ac:	d0b3      	beq.n	2816 <vTaskList+0x4e>
				cStatus = 0x00;
    28ae:	003d      	movs	r5, r7
				break;
    28b0:	e7b1      	b.n	2816 <vTaskList+0x4e>
				cStatus = tskBLOCKED_CHAR;
    28b2:	2542      	movs	r5, #66	; 0x42
    28b4:	e7af      	b.n	2816 <vTaskList+0x4e>
		vPortFree(pxTaskStatusArray);
    28b6:	0030      	movs	r0, r6
    28b8:	4b0a      	ldr	r3, [pc, #40]	; (28e4 <vTaskList+0x11c>)
    28ba:	4798      	blx	r3
}
    28bc:	b005      	add	sp, #20
    28be:	bc0c      	pop	{r2, r3}
    28c0:	4690      	mov	r8, r2
    28c2:	4699      	mov	r9, r3
    28c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    28c6:	46c0      	nop			; (mov r8, r8)
    28c8:	20000aac 	.word	0x20000aac
    28cc:	000010e5 	.word	0x000010e5
    28d0:	00002569 	.word	0x00002569
    28d4:	00002ce7 	.word	0x00002ce7
    28d8:	00002cf7 	.word	0x00002cf7
    28dc:	00002f50 	.word	0x00002f50
    28e0:	00000c69 	.word	0x00000c69
    28e4:	000011b1 	.word	0x000011b1

000028e8 <pvTaskIncrementMutexHeldCount>:
	if (pxCurrentTCB != NULL) {
    28e8:	4b05      	ldr	r3, [pc, #20]	; (2900 <pvTaskIncrementMutexHeldCount+0x18>)
    28ea:	699b      	ldr	r3, [r3, #24]
    28ec:	2b00      	cmp	r3, #0
    28ee:	d004      	beq.n	28fa <pvTaskIncrementMutexHeldCount+0x12>
		(pxCurrentTCB->uxMutexesHeld)++;
    28f0:	4b03      	ldr	r3, [pc, #12]	; (2900 <pvTaskIncrementMutexHeldCount+0x18>)
    28f2:	699a      	ldr	r2, [r3, #24]
    28f4:	6c93      	ldr	r3, [r2, #72]	; 0x48
    28f6:	3301      	adds	r3, #1
    28f8:	6493      	str	r3, [r2, #72]	; 0x48
	return pxCurrentTCB;
    28fa:	4b01      	ldr	r3, [pc, #4]	; (2900 <pvTaskIncrementMutexHeldCount+0x18>)
    28fc:	6998      	ldr	r0, [r3, #24]
}
    28fe:	4770      	bx	lr
    2900:	20000aac 	.word	0x20000aac

00002904 <prvInsertTimerInActiveList>:
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList(Timer_t *const pxTimer, const TickType_t xNextExpiryTime,
                                             const TickType_t xTimeNow, const TickType_t xCommandTime)
{
    2904:	b510      	push	{r4, lr}
	BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
    2906:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    2908:	6100      	str	r0, [r0, #16]

	if (xNextExpiryTime <= xTimeNow) {
    290a:	4291      	cmp	r1, r2
    290c:	d80b      	bhi.n	2926 <prvInsertTimerInActiveList+0x22>
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if (((TickType_t)(xTimeNow - xCommandTime))
    290e:	1ad2      	subs	r2, r2, r3
		    >= pxTimer->xTimerPeriodInTicks) /*lint !e961 MISRA exception as the casts are only redundant for some
		                                        ports. */
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    2910:	2401      	movs	r4, #1
		if (((TickType_t)(xTimeNow - xCommandTime))
    2912:	6983      	ldr	r3, [r0, #24]
    2914:	429a      	cmp	r2, r3
    2916:	d211      	bcs.n	293c <prvInsertTimerInActiveList+0x38>
		} else {
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
    2918:	1d01      	adds	r1, r0, #4
    291a:	4b09      	ldr	r3, [pc, #36]	; (2940 <prvInsertTimerInActiveList+0x3c>)
    291c:	6818      	ldr	r0, [r3, #0]
    291e:	4b09      	ldr	r3, [pc, #36]	; (2944 <prvInsertTimerInActiveList+0x40>)
    2920:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    2922:	2400      	movs	r4, #0
    2924:	e00a      	b.n	293c <prvInsertTimerInActiveList+0x38>
		}
	} else {
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    2926:	429a      	cmp	r2, r3
    2928:	d202      	bcs.n	2930 <prvInsertTimerInActiveList+0x2c>
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    292a:	2401      	movs	r4, #1
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    292c:	4299      	cmp	r1, r3
    292e:	d205      	bcs.n	293c <prvInsertTimerInActiveList+0x38>
		} else {
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    2930:	1d01      	adds	r1, r0, #4
    2932:	4b03      	ldr	r3, [pc, #12]	; (2940 <prvInsertTimerInActiveList+0x3c>)
    2934:	6858      	ldr	r0, [r3, #4]
    2936:	4b03      	ldr	r3, [pc, #12]	; (2944 <prvInsertTimerInActiveList+0x40>)
    2938:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    293a:	2400      	movs	r4, #0
		}
	}

	return xProcessTimerNow;
}
    293c:	0020      	movs	r0, r4
    293e:	bd10      	pop	{r4, pc}
    2940:	20000b18 	.word	0x20000b18
    2944:	00000ed1 	.word	0x00000ed1

00002948 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
    2948:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    294a:	4b0e      	ldr	r3, [pc, #56]	; (2984 <prvCheckForValidListAndQueue+0x3c>)
    294c:	4798      	blx	r3
	{
		if (xTimerQueue == NULL) {
    294e:	4b0e      	ldr	r3, [pc, #56]	; (2988 <prvCheckForValidListAndQueue+0x40>)
    2950:	689b      	ldr	r3, [r3, #8]
    2952:	2b00      	cmp	r3, #0
    2954:	d002      	beq.n	295c <prvCheckForValidListAndQueue+0x14>
#endif /* configQUEUE_REGISTRY_SIZE */
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2956:	4b0d      	ldr	r3, [pc, #52]	; (298c <prvCheckForValidListAndQueue+0x44>)
    2958:	4798      	blx	r3
}
    295a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			vListInitialise(&xActiveTimerList1);
    295c:	4c0a      	ldr	r4, [pc, #40]	; (2988 <prvCheckForValidListAndQueue+0x40>)
    295e:	0026      	movs	r6, r4
    2960:	360c      	adds	r6, #12
    2962:	0030      	movs	r0, r6
    2964:	4f0a      	ldr	r7, [pc, #40]	; (2990 <prvCheckForValidListAndQueue+0x48>)
    2966:	47b8      	blx	r7
			vListInitialise(&xActiveTimerList2);
    2968:	0025      	movs	r5, r4
    296a:	3520      	adds	r5, #32
    296c:	0028      	movs	r0, r5
    296e:	47b8      	blx	r7
			pxCurrentTimerList  = &xActiveTimerList1;
    2970:	6066      	str	r6, [r4, #4]
			pxOverflowTimerList = &xActiveTimerList2;
    2972:	6025      	str	r5, [r4, #0]
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    2974:	2200      	movs	r2, #0
    2976:	210c      	movs	r1, #12
    2978:	2002      	movs	r0, #2
    297a:	4b06      	ldr	r3, [pc, #24]	; (2994 <prvCheckForValidListAndQueue+0x4c>)
    297c:	4798      	blx	r3
    297e:	60a0      	str	r0, [r4, #8]
    2980:	e7e9      	b.n	2956 <prvCheckForValidListAndQueue+0xe>
    2982:	46c0      	nop			; (mov r8, r8)
    2984:	00001025 	.word	0x00001025
    2988:	20000b18 	.word	0x20000b18
    298c:	0000103d 	.word	0x0000103d
    2990:	00000e9d 	.word	0x00000e9d
    2994:	0000144d 	.word	0x0000144d

00002998 <xTimerCreateTimerTask>:
{
    2998:	b510      	push	{r4, lr}
    299a:	b082      	sub	sp, #8
	prvCheckForValidListAndQueue();
    299c:	4b0b      	ldr	r3, [pc, #44]	; (29cc <xTimerCreateTimerTask+0x34>)
    299e:	4798      	blx	r3
	if (xTimerQueue != NULL) {
    29a0:	4b0b      	ldr	r3, [pc, #44]	; (29d0 <xTimerCreateTimerTask+0x38>)
    29a2:	689b      	ldr	r3, [r3, #8]
    29a4:	2b00      	cmp	r3, #0
    29a6:	d00e      	beq.n	29c6 <xTimerCreateTimerTask+0x2e>
			xReturn = xTaskCreate(prvTimerTask,
    29a8:	4b09      	ldr	r3, [pc, #36]	; (29d0 <xTimerCreateTimerTask+0x38>)
    29aa:	3334      	adds	r3, #52	; 0x34
    29ac:	9301      	str	r3, [sp, #4]
    29ae:	2302      	movs	r3, #2
    29b0:	9300      	str	r3, [sp, #0]
    29b2:	2300      	movs	r3, #0
    29b4:	2240      	movs	r2, #64	; 0x40
    29b6:	4907      	ldr	r1, [pc, #28]	; (29d4 <xTimerCreateTimerTask+0x3c>)
    29b8:	4807      	ldr	r0, [pc, #28]	; (29d8 <xTimerCreateTimerTask+0x40>)
    29ba:	4c08      	ldr	r4, [pc, #32]	; (29dc <xTimerCreateTimerTask+0x44>)
    29bc:	47a0      	blx	r4
	configASSERT(xReturn);
    29be:	2800      	cmp	r0, #0
    29c0:	d001      	beq.n	29c6 <xTimerCreateTimerTask+0x2e>
}
    29c2:	b002      	add	sp, #8
    29c4:	bd10      	pop	{r4, pc}
	configASSERT(xReturn);
    29c6:	b672      	cpsid	i
    29c8:	e7fe      	b.n	29c8 <xTimerCreateTimerTask+0x30>
    29ca:	46c0      	nop			; (mov r8, r8)
    29cc:	00002949 	.word	0x00002949
    29d0:	20000b18 	.word	0x20000b18
    29d4:	00002f88 	.word	0x00002f88
    29d8:	00002afd 	.word	0x00002afd
    29dc:	00001c35 	.word	0x00001c35

000029e0 <xTimerGenericCommand>:
{
    29e0:	b530      	push	{r4, r5, lr}
    29e2:	b085      	sub	sp, #20
    29e4:	0004      	movs	r4, r0
    29e6:	001d      	movs	r5, r3
	configASSERT(xTimer);
    29e8:	2800      	cmp	r0, #0
    29ea:	d014      	beq.n	2a16 <xTimerGenericCommand+0x36>
	if (xTimerQueue != NULL) {
    29ec:	4b13      	ldr	r3, [pc, #76]	; (2a3c <xTimerGenericCommand+0x5c>)
    29ee:	6898      	ldr	r0, [r3, #8]
    29f0:	2800      	cmp	r0, #0
    29f2:	d021      	beq.n	2a38 <xTimerGenericCommand+0x58>
		xMessage.xMessageID                       = xCommandID;
    29f4:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    29f6:	9202      	str	r2, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
    29f8:	9403      	str	r4, [sp, #12]
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    29fa:	2905      	cmp	r1, #5
    29fc:	dc15      	bgt.n	2a2a <xTimerGenericCommand+0x4a>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
    29fe:	4b10      	ldr	r3, [pc, #64]	; (2a40 <xTimerGenericCommand+0x60>)
    2a00:	4798      	blx	r3
    2a02:	2802      	cmp	r0, #2
    2a04:	d009      	beq.n	2a1a <xTimerGenericCommand+0x3a>
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
    2a06:	4b0d      	ldr	r3, [pc, #52]	; (2a3c <xTimerGenericCommand+0x5c>)
    2a08:	6898      	ldr	r0, [r3, #8]
    2a0a:	2300      	movs	r3, #0
    2a0c:	2200      	movs	r2, #0
    2a0e:	a901      	add	r1, sp, #4
    2a10:	4c0c      	ldr	r4, [pc, #48]	; (2a44 <xTimerGenericCommand+0x64>)
    2a12:	47a0      	blx	r4
    2a14:	e00e      	b.n	2a34 <xTimerGenericCommand+0x54>
	configASSERT(xTimer);
    2a16:	b672      	cpsid	i
    2a18:	e7fe      	b.n	2a18 <xTimerGenericCommand+0x38>
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
    2a1a:	4b08      	ldr	r3, [pc, #32]	; (2a3c <xTimerGenericCommand+0x5c>)
    2a1c:	6898      	ldr	r0, [r3, #8]
    2a1e:	2300      	movs	r3, #0
    2a20:	9a08      	ldr	r2, [sp, #32]
    2a22:	a901      	add	r1, sp, #4
    2a24:	4c07      	ldr	r4, [pc, #28]	; (2a44 <xTimerGenericCommand+0x64>)
    2a26:	47a0      	blx	r4
    2a28:	e004      	b.n	2a34 <xTimerGenericCommand+0x54>
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    2a2a:	2300      	movs	r3, #0
    2a2c:	002a      	movs	r2, r5
    2a2e:	a901      	add	r1, sp, #4
    2a30:	4c05      	ldr	r4, [pc, #20]	; (2a48 <xTimerGenericCommand+0x68>)
    2a32:	47a0      	blx	r4
}
    2a34:	b005      	add	sp, #20
    2a36:	bd30      	pop	{r4, r5, pc}
	BaseType_t          xReturn = pdFAIL;
    2a38:	2000      	movs	r0, #0
	return xReturn;
    2a3a:	e7fb      	b.n	2a34 <xTimerGenericCommand+0x54>
    2a3c:	20000b18 	.word	0x20000b18
    2a40:	0000260d 	.word	0x0000260d
    2a44:	000014c1 	.word	0x000014c1
    2a48:	00001679 	.word	0x00001679

00002a4c <prvSampleTimeNow>:
{
    2a4c:	b5f0      	push	{r4, r5, r6, r7, lr}
    2a4e:	46d6      	mov	lr, sl
    2a50:	464f      	mov	r7, r9
    2a52:	4646      	mov	r6, r8
    2a54:	b5c0      	push	{r6, r7, lr}
    2a56:	b082      	sub	sp, #8
    2a58:	4680      	mov	r8, r0
	xTimeNow = xTaskGetTickCount();
    2a5a:	4b23      	ldr	r3, [pc, #140]	; (2ae8 <prvSampleTimeNow+0x9c>)
    2a5c:	4798      	blx	r3
    2a5e:	4682      	mov	sl, r0
	if (xTimeNow < xLastTime) {
    2a60:	4b22      	ldr	r3, [pc, #136]	; (2aec <prvSampleTimeNow+0xa0>)
    2a62:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    2a64:	4298      	cmp	r0, r3
    2a66:	d317      	bcc.n	2a98 <prvSampleTimeNow+0x4c>
		*pxTimerListsWereSwitched = pdFALSE;
    2a68:	2300      	movs	r3, #0
    2a6a:	4642      	mov	r2, r8
    2a6c:	6013      	str	r3, [r2, #0]
	xLastTime = xTimeNow;
    2a6e:	4b1f      	ldr	r3, [pc, #124]	; (2aec <prvSampleTimeNow+0xa0>)
    2a70:	4652      	mov	r2, sl
    2a72:	639a      	str	r2, [r3, #56]	; 0x38
}
    2a74:	4650      	mov	r0, sl
    2a76:	b002      	add	sp, #8
    2a78:	bc1c      	pop	{r2, r3, r4}
    2a7a:	4690      	mov	r8, r2
    2a7c:	4699      	mov	r9, r3
    2a7e:	46a2      	mov	sl, r4
    2a80:	bdf0      	pop	{r4, r5, r6, r7, pc}
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    2a82:	2300      	movs	r3, #0
    2a84:	9300      	str	r3, [sp, #0]
    2a86:	003a      	movs	r2, r7
    2a88:	2100      	movs	r1, #0
    2a8a:	0020      	movs	r0, r4
    2a8c:	4c18      	ldr	r4, [pc, #96]	; (2af0 <prvSampleTimeNow+0xa4>)
    2a8e:	47a0      	blx	r4
				configASSERT(xResult);
    2a90:	2800      	cmp	r0, #0
    2a92:	d104      	bne.n	2a9e <prvSampleTimeNow+0x52>
    2a94:	b672      	cpsid	i
    2a96:	e7fe      	b.n	2a96 <prvSampleTimeNow+0x4a>
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    2a98:	4d14      	ldr	r5, [pc, #80]	; (2aec <prvSampleTimeNow+0xa0>)
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    2a9a:	4b16      	ldr	r3, [pc, #88]	; (2af4 <prvSampleTimeNow+0xa8>)
    2a9c:	4699      	mov	r9, r3
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    2a9e:	686b      	ldr	r3, [r5, #4]
    2aa0:	681a      	ldr	r2, [r3, #0]
    2aa2:	2a00      	cmp	r2, #0
    2aa4:	d017      	beq.n	2ad6 <prvSampleTimeNow+0x8a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    2aa6:	68db      	ldr	r3, [r3, #12]
    2aa8:	681f      	ldr	r7, [r3, #0]
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    2aaa:	68dc      	ldr	r4, [r3, #12]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    2aac:	1d26      	adds	r6, r4, #4
    2aae:	0030      	movs	r0, r6
    2ab0:	47c8      	blx	r9
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    2ab2:	0020      	movs	r0, r4
    2ab4:	6a63      	ldr	r3, [r4, #36]	; 0x24
    2ab6:	4798      	blx	r3
		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    2ab8:	69e3      	ldr	r3, [r4, #28]
    2aba:	2b01      	cmp	r3, #1
    2abc:	d1ef      	bne.n	2a9e <prvSampleTimeNow+0x52>
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
    2abe:	69a3      	ldr	r3, [r4, #24]
    2ac0:	18fb      	adds	r3, r7, r3
			if (xReloadTime > xNextExpireTime) {
    2ac2:	429f      	cmp	r7, r3
    2ac4:	d2dd      	bcs.n	2a82 <prvSampleTimeNow+0x36>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
    2ac6:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    2ac8:	6124      	str	r4, [r4, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    2aca:	4b08      	ldr	r3, [pc, #32]	; (2aec <prvSampleTimeNow+0xa0>)
    2acc:	6858      	ldr	r0, [r3, #4]
    2ace:	0031      	movs	r1, r6
    2ad0:	4b09      	ldr	r3, [pc, #36]	; (2af8 <prvSampleTimeNow+0xac>)
    2ad2:	4798      	blx	r3
    2ad4:	e7e3      	b.n	2a9e <prvSampleTimeNow+0x52>
	pxCurrentTimerList  = pxOverflowTimerList;
    2ad6:	4a05      	ldr	r2, [pc, #20]	; (2aec <prvSampleTimeNow+0xa0>)
    2ad8:	6811      	ldr	r1, [r2, #0]
    2ada:	6051      	str	r1, [r2, #4]
	pxOverflowTimerList = pxTemp;
    2adc:	6013      	str	r3, [r2, #0]
		*pxTimerListsWereSwitched = pdTRUE;
    2ade:	2301      	movs	r3, #1
    2ae0:	4642      	mov	r2, r8
    2ae2:	6013      	str	r3, [r2, #0]
    2ae4:	e7c3      	b.n	2a6e <prvSampleTimeNow+0x22>
    2ae6:	46c0      	nop			; (mov r8, r8)
    2ae8:	00001f55 	.word	0x00001f55
    2aec:	20000b18 	.word	0x20000b18
    2af0:	000029e1 	.word	0x000029e1
    2af4:	00000eff 	.word	0x00000eff
    2af8:	00000ed1 	.word	0x00000ed1

00002afc <prvTimerTask>:
{
    2afc:	b5f0      	push	{r4, r5, r6, r7, lr}
    2afe:	b089      	sub	sp, #36	; 0x24
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    2b00:	4f52      	ldr	r7, [pc, #328]	; (2c4c <prvTimerTask+0x150>)
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    2b02:	4b53      	ldr	r3, [pc, #332]	; (2c50 <prvTimerTask+0x154>)
    2b04:	685b      	ldr	r3, [r3, #4]
    2b06:	681a      	ldr	r2, [r3, #0]
	if (*pxListWasEmpty == pdFALSE) {
    2b08:	2a00      	cmp	r2, #0
    2b0a:	d00e      	beq.n	2b2a <prvTimerTask+0x2e>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    2b0c:	68db      	ldr	r3, [r3, #12]
    2b0e:	681c      	ldr	r4, [r3, #0]
	vTaskSuspendAll();
    2b10:	4b50      	ldr	r3, [pc, #320]	; (2c54 <prvTimerTask+0x158>)
    2b12:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    2b14:	a805      	add	r0, sp, #20
    2b16:	4b50      	ldr	r3, [pc, #320]	; (2c58 <prvTimerTask+0x15c>)
    2b18:	4798      	blx	r3
    2b1a:	0005      	movs	r5, r0
		if (xTimerListsWereSwitched == pdFALSE) {
    2b1c:	9b05      	ldr	r3, [sp, #20]
    2b1e:	2b00      	cmp	r3, #0
    2b20:	d15f      	bne.n	2be2 <prvTimerTask+0xe6>
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
    2b22:	42a0      	cmp	r0, r4
    2b24:	d236      	bcs.n	2b94 <prvTimerTask+0x98>
    2b26:	2200      	movs	r2, #0
    2b28:	e00f      	b.n	2b4a <prvTimerTask+0x4e>
	vTaskSuspendAll();
    2b2a:	4b4a      	ldr	r3, [pc, #296]	; (2c54 <prvTimerTask+0x158>)
    2b2c:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    2b2e:	a805      	add	r0, sp, #20
    2b30:	4b49      	ldr	r3, [pc, #292]	; (2c58 <prvTimerTask+0x15c>)
    2b32:	4798      	blx	r3
    2b34:	0005      	movs	r5, r0
		if (xTimerListsWereSwitched == pdFALSE) {
    2b36:	9b05      	ldr	r3, [sp, #20]
    2b38:	2b00      	cmp	r3, #0
    2b3a:	d152      	bne.n	2be2 <prvTimerTask+0xe6>
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
    2b3c:	4b44      	ldr	r3, [pc, #272]	; (2c50 <prvTimerTask+0x154>)
    2b3e:	681b      	ldr	r3, [r3, #0]
    2b40:	681b      	ldr	r3, [r3, #0]
    2b42:	425a      	negs	r2, r3
    2b44:	415a      	adcs	r2, r3
    2b46:	b2d2      	uxtb	r2, r2
    2b48:	2400      	movs	r4, #0
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
    2b4a:	1b61      	subs	r1, r4, r5
    2b4c:	4b40      	ldr	r3, [pc, #256]	; (2c50 <prvTimerTask+0x154>)
    2b4e:	6898      	ldr	r0, [r3, #8]
    2b50:	4b42      	ldr	r3, [pc, #264]	; (2c5c <prvTimerTask+0x160>)
    2b52:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    2b54:	4b42      	ldr	r3, [pc, #264]	; (2c60 <prvTimerTask+0x164>)
    2b56:	4798      	blx	r3
    2b58:	2800      	cmp	r0, #0
    2b5a:	d03f      	beq.n	2bdc <prvTimerTask+0xe0>
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    2b5c:	4d3c      	ldr	r5, [pc, #240]	; (2c50 <prvTimerTask+0x154>)
    2b5e:	4c41      	ldr	r4, [pc, #260]	; (2c64 <prvTimerTask+0x168>)
    2b60:	2200      	movs	r2, #0
    2b62:	a905      	add	r1, sp, #20
    2b64:	68a8      	ldr	r0, [r5, #8]
    2b66:	47a0      	blx	r4
    2b68:	2800      	cmp	r0, #0
    2b6a:	d0ca      	beq.n	2b02 <prvTimerTask+0x6>
		if (xMessage.xMessageID >= (BaseType_t)0) {
    2b6c:	9b05      	ldr	r3, [sp, #20]
    2b6e:	9303      	str	r3, [sp, #12]
    2b70:	2b00      	cmp	r3, #0
    2b72:	dbf5      	blt.n	2b60 <prvTimerTask+0x64>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2b74:	9e07      	ldr	r6, [sp, #28]
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem))
    2b76:	6973      	ldr	r3, [r6, #20]
    2b78:	2b00      	cmp	r3, #0
    2b7a:	d001      	beq.n	2b80 <prvTimerTask+0x84>
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    2b7c:	1d30      	adds	r0, r6, #4
    2b7e:	47b8      	blx	r7
			xTimeNow = prvSampleTimeNow(&xTimerListsWereSwitched);
    2b80:	a804      	add	r0, sp, #16
    2b82:	4b35      	ldr	r3, [pc, #212]	; (2c58 <prvTimerTask+0x15c>)
    2b84:	4798      	blx	r3
			switch (xMessage.xMessageID) {
    2b86:	9b05      	ldr	r3, [sp, #20]
    2b88:	2b09      	cmp	r3, #9
    2b8a:	d8e9      	bhi.n	2b60 <prvTimerTask+0x64>
    2b8c:	009b      	lsls	r3, r3, #2
    2b8e:	4a36      	ldr	r2, [pc, #216]	; (2c68 <prvTimerTask+0x16c>)
    2b90:	58d3      	ldr	r3, [r2, r3]
    2b92:	469f      	mov	pc, r3
				(void)xTaskResumeAll();
    2b94:	4b32      	ldr	r3, [pc, #200]	; (2c60 <prvTimerTask+0x164>)
    2b96:	4798      	blx	r3
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    2b98:	4b2d      	ldr	r3, [pc, #180]	; (2c50 <prvTimerTask+0x154>)
    2b9a:	685b      	ldr	r3, [r3, #4]
    2b9c:	68db      	ldr	r3, [r3, #12]
    2b9e:	68de      	ldr	r6, [r3, #12]
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    2ba0:	1d30      	adds	r0, r6, #4
    2ba2:	4b2a      	ldr	r3, [pc, #168]	; (2c4c <prvTimerTask+0x150>)
    2ba4:	4798      	blx	r3
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    2ba6:	69f3      	ldr	r3, [r6, #28]
    2ba8:	2b01      	cmp	r3, #1
    2baa:	d003      	beq.n	2bb4 <prvTimerTask+0xb8>
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    2bac:	6a73      	ldr	r3, [r6, #36]	; 0x24
    2bae:	0030      	movs	r0, r6
    2bb0:	4798      	blx	r3
    2bb2:	e7d3      	b.n	2b5c <prvTimerTask+0x60>
		if (prvInsertTimerInActiveList(
    2bb4:	69b3      	ldr	r3, [r6, #24]
    2bb6:	18e1      	adds	r1, r4, r3
    2bb8:	0023      	movs	r3, r4
    2bba:	002a      	movs	r2, r5
    2bbc:	0030      	movs	r0, r6
    2bbe:	4d2b      	ldr	r5, [pc, #172]	; (2c6c <prvTimerTask+0x170>)
    2bc0:	47a8      	blx	r5
    2bc2:	2800      	cmp	r0, #0
    2bc4:	d0f2      	beq.n	2bac <prvTimerTask+0xb0>
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    2bc6:	2300      	movs	r3, #0
    2bc8:	9300      	str	r3, [sp, #0]
    2bca:	0022      	movs	r2, r4
    2bcc:	2100      	movs	r1, #0
    2bce:	0030      	movs	r0, r6
    2bd0:	4c27      	ldr	r4, [pc, #156]	; (2c70 <prvTimerTask+0x174>)
    2bd2:	47a0      	blx	r4
			configASSERT(xResult);
    2bd4:	2800      	cmp	r0, #0
    2bd6:	d1e9      	bne.n	2bac <prvTimerTask+0xb0>
    2bd8:	b672      	cpsid	i
    2bda:	e7fe      	b.n	2bda <prvTimerTask+0xde>
					portYIELD_WITHIN_API();
    2bdc:	4b25      	ldr	r3, [pc, #148]	; (2c74 <prvTimerTask+0x178>)
    2bde:	4798      	blx	r3
    2be0:	e7bc      	b.n	2b5c <prvTimerTask+0x60>
			(void)xTaskResumeAll();
    2be2:	4b1f      	ldr	r3, [pc, #124]	; (2c60 <prvTimerTask+0x164>)
    2be4:	4798      	blx	r3
    2be6:	e7b9      	b.n	2b5c <prvTimerTask+0x60>
				if (prvInsertTimerInActiveList(pxTimer,
    2be8:	9b06      	ldr	r3, [sp, #24]
    2bea:	69b2      	ldr	r2, [r6, #24]
    2bec:	4694      	mov	ip, r2
    2bee:	4463      	add	r3, ip
    2bf0:	0019      	movs	r1, r3
    2bf2:	9b06      	ldr	r3, [sp, #24]
    2bf4:	0002      	movs	r2, r0
    2bf6:	0030      	movs	r0, r6
    2bf8:	4c1c      	ldr	r4, [pc, #112]	; (2c6c <prvTimerTask+0x170>)
    2bfa:	47a0      	blx	r4
    2bfc:	2800      	cmp	r0, #0
    2bfe:	d0ae      	beq.n	2b5e <prvTimerTask+0x62>
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    2c00:	0030      	movs	r0, r6
    2c02:	6a73      	ldr	r3, [r6, #36]	; 0x24
    2c04:	4798      	blx	r3
					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    2c06:	69f3      	ldr	r3, [r6, #28]
    2c08:	2b01      	cmp	r3, #1
    2c0a:	d1a8      	bne.n	2b5e <prvTimerTask+0x62>
						xResult = xTimerGenericCommand(pxTimer,
    2c0c:	9b06      	ldr	r3, [sp, #24]
    2c0e:	69b1      	ldr	r1, [r6, #24]
    2c10:	468c      	mov	ip, r1
    2c12:	4463      	add	r3, ip
    2c14:	001a      	movs	r2, r3
    2c16:	2300      	movs	r3, #0
    2c18:	9300      	str	r3, [sp, #0]
    2c1a:	2100      	movs	r1, #0
    2c1c:	0030      	movs	r0, r6
    2c1e:	4c14      	ldr	r4, [pc, #80]	; (2c70 <prvTimerTask+0x174>)
    2c20:	47a0      	blx	r4
						configASSERT(xResult);
    2c22:	2800      	cmp	r0, #0
    2c24:	d19b      	bne.n	2b5e <prvTimerTask+0x62>
    2c26:	b672      	cpsid	i
    2c28:	e7fe      	b.n	2c28 <prvTimerTask+0x12c>
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2c2a:	9906      	ldr	r1, [sp, #24]
    2c2c:	61b1      	str	r1, [r6, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    2c2e:	2900      	cmp	r1, #0
    2c30:	d006      	beq.n	2c40 <prvTimerTask+0x144>
				(void)prvInsertTimerInActiveList(
    2c32:	1841      	adds	r1, r0, r1
    2c34:	0003      	movs	r3, r0
    2c36:	0002      	movs	r2, r0
    2c38:	0030      	movs	r0, r6
    2c3a:	4c0c      	ldr	r4, [pc, #48]	; (2c6c <prvTimerTask+0x170>)
    2c3c:	47a0      	blx	r4
    2c3e:	e78e      	b.n	2b5e <prvTimerTask+0x62>
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    2c40:	b672      	cpsid	i
    2c42:	e7fe      	b.n	2c42 <prvTimerTask+0x146>
				vPortFree(pxTimer);
    2c44:	0030      	movs	r0, r6
    2c46:	4b0c      	ldr	r3, [pc, #48]	; (2c78 <prvTimerTask+0x17c>)
    2c48:	4798      	blx	r3
    2c4a:	e788      	b.n	2b5e <prvTimerTask+0x62>
    2c4c:	00000eff 	.word	0x00000eff
    2c50:	20000b18 	.word	0x20000b18
    2c54:	00001f45 	.word	0x00001f45
    2c58:	00002a4d 	.word	0x00002a4d
    2c5c:	00001af9 	.word	0x00001af9
    2c60:	00002079 	.word	0x00002079
    2c64:	000017f9 	.word	0x000017f9
    2c68:	00002f60 	.word	0x00002f60
    2c6c:	00002905 	.word	0x00002905
    2c70:	000029e1 	.word	0x000029e1
    2c74:	0000100d 	.word	0x0000100d
    2c78:	000011b1 	.word	0x000011b1

00002c7c <__libc_init_array>:
    2c7c:	b570      	push	{r4, r5, r6, lr}
    2c7e:	2600      	movs	r6, #0
    2c80:	4d0c      	ldr	r5, [pc, #48]	; (2cb4 <__libc_init_array+0x38>)
    2c82:	4c0d      	ldr	r4, [pc, #52]	; (2cb8 <__libc_init_array+0x3c>)
    2c84:	1b64      	subs	r4, r4, r5
    2c86:	10a4      	asrs	r4, r4, #2
    2c88:	42a6      	cmp	r6, r4
    2c8a:	d109      	bne.n	2ca0 <__libc_init_array+0x24>
    2c8c:	2600      	movs	r6, #0
    2c8e:	f000 f97f 	bl	2f90 <_init>
    2c92:	4d0a      	ldr	r5, [pc, #40]	; (2cbc <__libc_init_array+0x40>)
    2c94:	4c0a      	ldr	r4, [pc, #40]	; (2cc0 <__libc_init_array+0x44>)
    2c96:	1b64      	subs	r4, r4, r5
    2c98:	10a4      	asrs	r4, r4, #2
    2c9a:	42a6      	cmp	r6, r4
    2c9c:	d105      	bne.n	2caa <__libc_init_array+0x2e>
    2c9e:	bd70      	pop	{r4, r5, r6, pc}
    2ca0:	00b3      	lsls	r3, r6, #2
    2ca2:	58eb      	ldr	r3, [r5, r3]
    2ca4:	4798      	blx	r3
    2ca6:	3601      	adds	r6, #1
    2ca8:	e7ee      	b.n	2c88 <__libc_init_array+0xc>
    2caa:	00b3      	lsls	r3, r6, #2
    2cac:	58eb      	ldr	r3, [r5, r3]
    2cae:	4798      	blx	r3
    2cb0:	3601      	adds	r6, #1
    2cb2:	e7f2      	b.n	2c9a <__libc_init_array+0x1e>
    2cb4:	00002f9c 	.word	0x00002f9c
    2cb8:	00002f9c 	.word	0x00002f9c
    2cbc:	00002f9c 	.word	0x00002f9c
    2cc0:	00002fa0 	.word	0x00002fa0

00002cc4 <memcpy>:
    2cc4:	2300      	movs	r3, #0
    2cc6:	b510      	push	{r4, lr}
    2cc8:	429a      	cmp	r2, r3
    2cca:	d100      	bne.n	2cce <memcpy+0xa>
    2ccc:	bd10      	pop	{r4, pc}
    2cce:	5ccc      	ldrb	r4, [r1, r3]
    2cd0:	54c4      	strb	r4, [r0, r3]
    2cd2:	3301      	adds	r3, #1
    2cd4:	e7f8      	b.n	2cc8 <memcpy+0x4>

00002cd6 <memset>:
    2cd6:	0003      	movs	r3, r0
    2cd8:	1882      	adds	r2, r0, r2
    2cda:	4293      	cmp	r3, r2
    2cdc:	d100      	bne.n	2ce0 <memset+0xa>
    2cde:	4770      	bx	lr
    2ce0:	7019      	strb	r1, [r3, #0]
    2ce2:	3301      	adds	r3, #1
    2ce4:	e7f9      	b.n	2cda <memset+0x4>

00002ce6 <strcpy>:
    2ce6:	1c03      	adds	r3, r0, #0
    2ce8:	780a      	ldrb	r2, [r1, #0]
    2cea:	3101      	adds	r1, #1
    2cec:	701a      	strb	r2, [r3, #0]
    2cee:	3301      	adds	r3, #1
    2cf0:	2a00      	cmp	r2, #0
    2cf2:	d1f9      	bne.n	2ce8 <strcpy+0x2>
    2cf4:	4770      	bx	lr

00002cf6 <strlen>:
    2cf6:	2300      	movs	r3, #0
    2cf8:	5cc2      	ldrb	r2, [r0, r3]
    2cfa:	3301      	adds	r3, #1
    2cfc:	2a00      	cmp	r2, #0
    2cfe:	d1fb      	bne.n	2cf8 <strlen+0x2>
    2d00:	1e58      	subs	r0, r3, #1
    2d02:	4770      	bx	lr
    2d04:	682f2e2e 	.word	0x682f2e2e
    2d08:	732f6c61 	.word	0x732f6c61
    2d0c:	682f6372 	.word	0x682f6372
    2d10:	695f6c61 	.word	0x695f6c61
    2d14:	00632e6f 	.word	0x00632e6f
    2d18:	682f2e2e 	.word	0x682f2e2e
    2d1c:	732f6c61 	.word	0x732f6c61
    2d20:	682f6372 	.word	0x682f6372
    2d24:	755f6c61 	.word	0x755f6c61
    2d28:	74726173 	.word	0x74726173
    2d2c:	2e736f5f 	.word	0x2e736f5f
    2d30:	00000063 	.word	0x00000063
    2d34:	682f2e2e 	.word	0x682f2e2e
    2d38:	752f6c61 	.word	0x752f6c61
    2d3c:	736c6974 	.word	0x736c6974
    2d40:	6372732f 	.word	0x6372732f
    2d44:	6974752f 	.word	0x6974752f
    2d48:	725f736c 	.word	0x725f736c
    2d4c:	62676e69 	.word	0x62676e69
    2d50:	65666675 	.word	0x65666675
    2d54:	00632e72 	.word	0x00632e72
    2d58:	682f2e2e 	.word	0x682f2e2e
    2d5c:	732f6c70 	.word	0x732f6c70
    2d60:	6f637265 	.word	0x6f637265
    2d64:	70682f6d 	.word	0x70682f6d
    2d68:	65735f6c 	.word	0x65735f6c
    2d6c:	6d6f6372 	.word	0x6d6f6372
    2d70:	0000632e 	.word	0x0000632e

00002d74 <m_val>:
    2d74:	3b9aca00 05f5e100 00989680 000f4240     ...;........@B..
    2d84:	000186a0 00002710 000003e8 00000064     .....'......d...
    2d94:	0000000a 00000001 454c202d 6c622044     ........- LED bl
    2da4:	206b6e69 6b736174 74636120 2e657669     ink task active.
    2db4:	00000a0d 454c202d 464f2044 6e612046     ....- LED OFF an
    2dc4:	6c622064 206b6e69 6b736174 73757320     d blink task sus
    2dd4:	646e6570 0d2e6465 0000000a 6f4d202d     pended......- Mo
    2de4:	6f74696e 61742072 61206b73 76697463     nitor task activ
    2df4:	0a0d2e65 00000000 6f4d202d 6f74696e     e.......- Monito
    2e04:	61742072 73206b73 65707375 6465646e     r task suspended
    2e14:	000a0d2e 696e6f4d 00726f74 0064654c     ....Monitor.Led.
    2e24:	736e6f43 00656c6f 313b315b 00000048     Console.[1;1H...
    2e34:	73256325 73256325 00000000 004a325b     %c%s%c%s....[2J.
    2e44:	202d2d2d 626d754e 6f207265 61742066     --- Number of ta
    2e54:	3a736b73 0d752520 0000000a 6154203e     sks: %u.....> Ta
    2e64:	09736b73 74617453 72500965 74530969     sks.State.Pri.St
    2e74:	096b6361 0d6d754e 0000000a 2a2a2a2a     ack.Num.....****
    2e84:	2a2a2a2a 2a2a2a2a 2a2a2a2a 2a2a2a2a     ****************
    2e94:	2a2a2a2a 2a2a2a2a 2a2a2a2a 0d2a2a2a     ***************.
    2ea4:	0000000a 202d2d2d 73657250 20612073     ....--- Press a 
    2eb4:	3a79656b 61200a0d 454c203a 6c622044     key:.. a: LED bl
    2ec4:	206b6e69 6b736174 74636120 0d657669     ink task active.
    2ed4:	3a73200a 44454c20 46464f20 646e6120     . s: LED OFF and
    2ee4:	696c6220 74206b6e 206b7361 70737573      blink task susp
    2ef4:	0d646e65 746f200a 73726568 6345203a     end.. others: Ec
    2f04:	62206f68 0d6b6361 0000230a 742f2e2e     ho back..#..../t
    2f14:	64726968 74726170 54522f79 662f534f     hirdparty/RTOS/f
    2f24:	72656572 2f736f74 65657246 534f5452     reertos/FreeRTOS
    2f34:	2e303156 2f302e30 736f7472 726f705f     V10.0.0/rtos_por
    2f44:	00632e74 454c4449 00000000 09632509     t.c.IDLE.....%c.
    2f54:	25097525 75250975 00000a0d 00002be8     %u.%u.%u.....+..
    2f64:	00002be8 00002be8 00002b60 00002c2a     .+...+..`+..*,..
    2f74:	00002c44 00002be8 00002be8 00002b60     D,...+...+..`+..
    2f84:	00002c2a 20726d54 00637653              *,..Tmr Svc.

00002f90 <_init>:
    2f90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2f92:	46c0      	nop			; (mov r8, r8)
    2f94:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2f96:	bc08      	pop	{r3}
    2f98:	469e      	mov	lr, r3
    2f9a:	4770      	bx	lr

00002f9c <__init_array_start>:
    2f9c:	000000dd 	.word	0x000000dd

00002fa0 <_fini>:
    2fa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2fa2:	46c0      	nop			; (mov r8, r8)
    2fa4:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2fa6:	bc08      	pop	{r3}
    2fa8:	469e      	mov	lr, r3
    2faa:	4770      	bx	lr

00002fac <__fini_array_start>:
    2fac:	000000b5 	.word	0x000000b5
